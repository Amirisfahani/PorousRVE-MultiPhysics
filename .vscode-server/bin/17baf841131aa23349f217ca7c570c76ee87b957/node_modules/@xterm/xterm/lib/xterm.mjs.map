{
  "version": 3,
  "sources": ["../src/browser/LocalizableStrings.ts", "../src/browser/Clipboard.ts", "../src/common/input/TextDecoder.ts", "../src/common/buffer/Constants.ts", "../src/common/buffer/AttributeData.ts", "../src/common/buffer/CellData.ts", "../src/common/services/ServiceRegistry.ts", "../src/common/services/Services.ts", "../src/browser/OscLinkProvider.ts", "../src/browser/services/Services.ts", "../src/vs/base/common/errors.ts", "../src/vs/base/common/arraysFind.ts", "../src/vs/base/common/arrays.ts", "../src/vs/base/common/collections.ts", "../src/vs/base/common/map.ts", "../src/vs/base/common/functional.ts", "../src/vs/base/common/iterator.ts", "../src/vs/base/common/lifecycle.ts", "../src/vs/base/browser/window.ts", "../src/vs/base/common/linkedList.ts", "../src/vs/base/common/stopwatch.ts", "../src/vs/base/common/event.ts", "../src/vs/base/browser/browser.ts", "../src/vs/base/common/platform.ts", "../src/vs/base/browser/canIUse.ts", "../src/vs/base/common/keyCodes.ts", "../src/vs/base/common/keybindings.ts", "../src/vs/base/browser/keyboardEvent.ts", "../src/vs/base/browser/iframe.ts", "../src/vs/base/browser/mouseEvent.ts", "../src/vs/base/common/cancellation.ts", "../src/vs/base/common/symbols.ts", "../src/vs/base/common/async.ts", "../src/vs/base/common/strings.ts", "../src/vs/base/common/hash.ts", "../src/vs/base/browser/dom.ts", "../src/vs/base/browser/fastDomNode.ts", "../src/vs/base/browser/globalPointerMoveMonitor.ts", "../src/vs/base/common/decorators.ts", "../src/vs/base/browser/touch.ts", "../src/vs/base/browser/ui/widget.ts", "../src/vs/base/browser/ui/scrollbar/scrollbarArrow.ts", "../src/vs/base/common/scrollable.ts", "../src/vs/base/browser/ui/scrollbar/scrollbarVisibilityController.ts", "../src/vs/base/browser/ui/scrollbar/abstractScrollbar.ts", "../src/vs/base/browser/ui/scrollbar/scrollbarState.ts", "../src/vs/base/browser/ui/scrollbar/horizontalScrollbar.ts", "../src/vs/base/browser/ui/scrollbar/verticalScrollbar.ts", "../src/vs/base/browser/ui/scrollbar/scrollableElement.ts", "../src/browser/Viewport.ts", "../src/browser/decorations/BufferDecorationRenderer.ts", "../src/browser/decorations/ColorZoneStore.ts", "../src/browser/decorations/OverviewRulerRenderer.ts", "../src/common/data/EscapeSequences.ts", "../src/browser/input/CompositionHelper.ts", "../src/common/Color.ts", "../src/browser/services/CharacterJoinerService.ts", "../src/browser/renderer/shared/RendererUtils.ts", "../src/browser/renderer/dom/DomRendererRowFactory.ts", "../src/browser/renderer/dom/WidthCache.ts", "../src/browser/renderer/shared/SelectionRenderModel.ts", "../src/browser/renderer/dom/DomRenderer.ts", "../src/browser/services/CharSizeService.ts", "../src/browser/services/CoreBrowserService.ts", "../src/browser/services/LinkProviderService.ts", "../src/browser/input/Mouse.ts", "../src/browser/services/MouseService.ts", "../src/browser/RenderDebouncer.ts", "../src/common/Platform.ts", "../src/common/TaskQueue.ts", "../src/browser/services/RenderService.ts", "../src/browser/input/MoveToCell.ts", "../src/browser/selection/SelectionModel.ts", "../src/common/buffer/BufferRange.ts", "../src/browser/services/SelectionService.ts", "../src/common/MultiKeyMap.ts", "../src/browser/ColorContrastCache.ts", "../src/browser/Types.ts", "../src/browser/services/ThemeService.ts", "../src/common/services/InstantiationService.ts", "../src/common/services/LogService.ts", "../src/common/CircularList.ts", "../src/common/buffer/BufferLine.ts", "../src/common/buffer/BufferReflow.ts", "../src/common/buffer/Marker.ts", "../src/common/data/Charsets.ts", "../src/common/buffer/Buffer.ts", "../src/common/buffer/BufferSet.ts", "../src/common/services/BufferService.ts", "../src/common/services/OptionsService.ts", "../src/common/Clone.ts", "../src/common/services/CoreService.ts", "../src/common/services/CoreMouseService.ts", "../src/common/input/UnicodeV6.ts", "../src/common/services/UnicodeService.ts", "../src/common/services/CharsetService.ts", "../src/common/WindowsMode.ts", "../src/common/parser/Params.ts", "../src/common/parser/OscParser.ts", "../src/common/parser/DcsParser.ts", "../src/common/parser/EscapeSequenceParser.ts", "../src/common/input/XParseColor.ts", "../src/common/InputHandler.ts", "../src/common/input/WriteBuffer.ts", "../src/common/services/OscLinkService.ts", "../src/common/CoreTerminal.ts", "../src/common/input/Keyboard.ts", "../src/common/SortedList.ts", "../src/common/services/DecorationService.ts", "../src/browser/TimeBasedDebouncer.ts", "../src/browser/AccessibilityManager.ts", "../src/browser/Linkifier.ts", "../src/browser/CoreBrowserTerminal.ts", "../src/common/public/AddonManager.ts", "../src/common/public/BufferLineApiView.ts", "../src/common/public/BufferApiView.ts", "../src/common/public/BufferNamespaceApi.ts", "../src/common/public/ParserApi.ts", "../src/common/public/UnicodeApi.ts", "../src/browser/public/Terminal.ts"],
  "sourcesContent": ["/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\n// This file contains strings that get exported in the API so they can be localized\n\nlet promptLabelInternal = 'Terminal input';\nconst promptLabel = {\n  get: () => promptLabelInternal,\n  set: (value: string) => promptLabelInternal = value\n};\n\nlet tooMuchOutputInternal = 'Too much output to announce, navigate to rows manually to read';\nconst tooMuchOutput = {\n  get: () => tooMuchOutputInternal,\n  set: (value: string) => tooMuchOutputInternal = value\n};\n\nexport {\n  promptLabel,\n  tooMuchOutput\n};\n", "/**\n * Copyright (c) 2016 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { ISelectionService } from 'browser/services/Services';\nimport { ICoreService, IOptionsService } from 'common/services/Services';\n\n/**\n * Prepares text to be pasted into the terminal by normalizing the line endings\n * @param text The pasted text that needs processing before inserting into the terminal\n */\nexport function prepareTextForTerminal(text: string): string {\n  return text.replace(/\\r?\\n/g, '\\r');\n}\n\n/**\n * Bracket text for paste, if necessary, as per https://cirw.in/blog/bracketed-paste\n * @param text The pasted text to bracket\n */\nexport function bracketTextForPaste(text: string, bracketedPasteMode: boolean): string {\n  if (bracketedPasteMode) {\n    return '\\x1b[200~' + text + '\\x1b[201~';\n  }\n  return text;\n}\n\n/**\n * Binds copy functionality to the given terminal.\n * @param ev The original copy event to be handled\n */\nexport function copyHandler(ev: ClipboardEvent, selectionService: ISelectionService): void {\n  if (ev.clipboardData) {\n    ev.clipboardData.setData('text/plain', selectionService.selectionText);\n  }\n  // Prevent or the original text will be copied.\n  ev.preventDefault();\n}\n\n/**\n * Redirect the clipboard's data to the terminal's input handler.\n */\nexport function handlePasteEvent(ev: ClipboardEvent, textarea: HTMLTextAreaElement, coreService: ICoreService, optionsService: IOptionsService): void {\n  ev.stopPropagation();\n  if (ev.clipboardData) {\n    const text = ev.clipboardData.getData('text/plain');\n    paste(text, textarea, coreService, optionsService);\n  }\n}\n\nexport function paste(text: string, textarea: HTMLTextAreaElement, coreService: ICoreService, optionsService: IOptionsService): void {\n  text = prepareTextForTerminal(text);\n  text = bracketTextForPaste(text, coreService.decPrivateModes.bracketedPasteMode && optionsService.rawOptions.ignoreBracketedPasteMode !== true);\n  coreService.triggerDataEvent(text, true);\n  textarea.value = '';\n}\n\n/**\n * Moves the textarea under the mouse cursor and focuses it.\n * @param ev The original right click event to be handled.\n * @param textarea The terminal's textarea.\n */\nexport function moveTextAreaUnderMouseCursor(ev: MouseEvent, textarea: HTMLTextAreaElement, screenElement: HTMLElement): void {\n\n  // Calculate textarea position relative to the screen element\n  const pos = screenElement.getBoundingClientRect();\n  const left = ev.clientX - pos.left - 10;\n  const top = ev.clientY - pos.top - 10;\n\n  // Bring textarea at the cursor position\n  textarea.style.width = '20px';\n  textarea.style.height = '20px';\n  textarea.style.left = `${left}px`;\n  textarea.style.top = `${top}px`;\n  textarea.style.zIndex = '1000';\n\n  textarea.focus();\n}\n\n/**\n * Bind to right-click event and allow right-click copy and paste.\n */\nexport function rightClickHandler(ev: MouseEvent, textarea: HTMLTextAreaElement, screenElement: HTMLElement, selectionService: ISelectionService, shouldSelectWord: boolean): void {\n  moveTextAreaUnderMouseCursor(ev, textarea, screenElement);\n\n  if (shouldSelectWord) {\n    selectionService.rightClickSelect(ev);\n  }\n\n  // Get textarea ready to copy from the context menu\n  textarea.value = selectionService.selectionText;\n  textarea.select();\n}\n", "/**\n * Copyright (c) 2019 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\n/**\n * Polyfill - Convert UTF32 codepoint into JS string.\n * Note: The built-in String.fromCodePoint happens to be much slower\n *       due to additional sanity checks. We can avoid them since\n *       we always operate on legal UTF32 (granted by the input decoders)\n *       and use this faster version instead.\n */\nexport function stringFromCodePoint(codePoint: number): string {\n  if (codePoint > 0xFFFF) {\n    codePoint -= 0x10000;\n    return String.fromCharCode((codePoint >> 10) + 0xD800) + String.fromCharCode((codePoint % 0x400) + 0xDC00);\n  }\n  return String.fromCharCode(codePoint);\n}\n\n/**\n * Convert UTF32 char codes into JS string.\n * Basically the same as `stringFromCodePoint` but for multiple codepoints\n * in a loop (which is a lot faster).\n */\nexport function utf32ToString(data: Uint32Array, start: number = 0, end: number = data.length): string {\n  let result = '';\n  for (let i = start; i < end; ++i) {\n    let codepoint = data[i];\n    if (codepoint > 0xFFFF) {\n      // JS strings are encoded as UTF16, thus a non BMP codepoint gets converted into a surrogate\n      // pair conversion rules:\n      //  - subtract 0x10000 from code point, leaving a 20 bit number\n      //  - add high 10 bits to 0xD800  --> first surrogate\n      //  - add low 10 bits to 0xDC00   --> second surrogate\n      codepoint -= 0x10000;\n      result += String.fromCharCode((codepoint >> 10) + 0xD800) + String.fromCharCode((codepoint % 0x400) + 0xDC00);\n    } else {\n      result += String.fromCharCode(codepoint);\n    }\n  }\n  return result;\n}\n\n/**\n * StringToUtf32 - decodes UTF16 sequences into UTF32 codepoints.\n * To keep the decoder in line with JS strings it handles single surrogates as UCS2.\n */\nexport class StringToUtf32 {\n  private _interim: number = 0;\n\n  /**\n   * Clears interim and resets decoder to clean state.\n   */\n  public clear(): void {\n    this._interim = 0;\n  }\n\n  /**\n   * Decode JS string to UTF32 codepoints.\n   * The methods assumes stream input and will store partly transmitted\n   * surrogate pairs and decode them with the next data chunk.\n   * Note: The method does no bound checks for target, therefore make sure\n   * the provided input data does not exceed the size of `target`.\n   * Returns the number of written codepoints in `target`.\n   */\n  public decode(input: string, target: Uint32Array): number {\n    const length = input.length;\n\n    if (!length) {\n      return 0;\n    }\n\n    let size = 0;\n    let startPos = 0;\n\n    // handle leftover surrogate high\n    if (this._interim) {\n      const second = input.charCodeAt(startPos++);\n      if (0xDC00 <= second && second <= 0xDFFF) {\n        target[size++] = (this._interim - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n      } else {\n        // illegal codepoint (USC2 handling)\n        target[size++] = this._interim;\n        target[size++] = second;\n      }\n      this._interim = 0;\n    }\n\n    for (let i = startPos; i < length; ++i) {\n      const code = input.charCodeAt(i);\n      // surrogate pair first\n      if (0xD800 <= code && code <= 0xDBFF) {\n        if (++i >= length) {\n          this._interim = code;\n          return size;\n        }\n        const second = input.charCodeAt(i);\n        if (0xDC00 <= second && second <= 0xDFFF) {\n          target[size++] = (code - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n        } else {\n          // illegal codepoint (USC2 handling)\n          target[size++] = code;\n          target[size++] = second;\n        }\n        continue;\n      }\n      if (code === 0xFEFF) {\n        // BOM\n        continue;\n      }\n      target[size++] = code;\n    }\n    return size;\n  }\n}\n\n/**\n * Utf8Decoder - decodes UTF8 byte sequences into UTF32 codepoints.\n */\nexport class Utf8ToUtf32 {\n  public interim: Uint8Array = new Uint8Array(3);\n\n  /**\n   * Clears interim bytes and resets decoder to clean state.\n   */\n  public clear(): void {\n    this.interim.fill(0);\n  }\n\n  /**\n   * Decodes UTF8 byte sequences in `input` to UTF32 codepoints in `target`.\n   * The methods assumes stream input and will store partly transmitted bytes\n   * and decode them with the next data chunk.\n   * Note: The method does no bound checks for target, therefore make sure\n   * the provided data chunk does not exceed the size of `target`.\n   * Returns the number of written codepoints in `target`.\n   */\n  public decode(input: Uint8Array, target: Uint32Array): number {\n    const length = input.length;\n\n    if (!length) {\n      return 0;\n    }\n\n    let size = 0;\n    let byte1: number;\n    let byte2: number;\n    let byte3: number;\n    let byte4: number;\n    let codepoint = 0;\n    let startPos = 0;\n\n    // handle leftover bytes\n    if (this.interim[0]) {\n      let discardInterim = false;\n      let cp = this.interim[0];\n      cp &= ((((cp & 0xE0) === 0xC0)) ? 0x1F : (((cp & 0xF0) === 0xE0)) ? 0x0F : 0x07);\n      let pos = 0;\n      let tmp: number;\n      while ((tmp = this.interim[++pos] & 0x3F) && pos < 4) {\n        cp <<= 6;\n        cp |= tmp;\n      }\n      // missing bytes - read ahead from input\n      const type = (((this.interim[0] & 0xE0) === 0xC0)) ? 2 : (((this.interim[0] & 0xF0) === 0xE0)) ? 3 : 4;\n      const missing = type - pos;\n      while (startPos < missing) {\n        if (startPos >= length) {\n          return 0;\n        }\n        tmp = input[startPos++];\n        if ((tmp & 0xC0) !== 0x80) {\n          // wrong continuation, discard interim bytes completely\n          startPos--;\n          discardInterim = true;\n          break;\n        } else {\n          // need to save so we can continue short inputs in next call\n          this.interim[pos++] = tmp;\n          cp <<= 6;\n          cp |= tmp & 0x3F;\n        }\n      }\n      if (!discardInterim) {\n        // final test is type dependent\n        if (type === 2) {\n          if (cp < 0x80) {\n            // wrong starter byte\n            startPos--;\n          } else {\n            target[size++] = cp;\n          }\n        } else if (type === 3) {\n          if (cp < 0x0800 || (cp >= 0xD800 && cp <= 0xDFFF) || cp === 0xFEFF) {\n            // illegal codepoint or BOM\n          } else {\n            target[size++] = cp;\n          }\n        } else {\n          if (cp < 0x010000 || cp > 0x10FFFF) {\n            // illegal codepoint\n          } else {\n            target[size++] = cp;\n          }\n        }\n      }\n      this.interim.fill(0);\n    }\n\n    // loop through input\n    const fourStop = length - 4;\n    let i = startPos;\n    while (i < length) {\n      /**\n       * ASCII shortcut with loop unrolled to 4 consecutive ASCII chars.\n       * This is a compromise between speed gain for ASCII\n       * and penalty for non ASCII:\n       * For best ASCII performance the char should be stored directly into target,\n       * but even a single attempt to write to target and compare afterwards\n       * penalizes non ASCII really bad (-50%), thus we load the char into byteX first,\n       * which reduces ASCII performance by ~15%.\n       * This trial for ASCII reduces non ASCII performance by ~10% which seems acceptible\n       * compared to the gains.\n       * Note that this optimization only takes place for 4 consecutive ASCII chars,\n       * for any shorter it bails out. Worst case - all 4 bytes being read but\n       * thrown away due to the last being a non ASCII char (-10% performance).\n       */\n      while (i < fourStop\n        && !((byte1 = input[i]) & 0x80)\n        && !((byte2 = input[i + 1]) & 0x80)\n        && !((byte3 = input[i + 2]) & 0x80)\n        && !((byte4 = input[i + 3]) & 0x80))\n      {\n        target[size++] = byte1;\n        target[size++] = byte2;\n        target[size++] = byte3;\n        target[size++] = byte4;\n        i += 4;\n      }\n\n      // reread byte1\n      byte1 = input[i++];\n\n      // 1 byte\n      if (byte1 < 0x80) {\n        target[size++] = byte1;\n\n        // 2 bytes\n      } else if ((byte1 & 0xE0) === 0xC0) {\n        if (i >= length) {\n          this.interim[0] = byte1;\n          return size;\n        }\n        byte2 = input[i++];\n        if ((byte2 & 0xC0) !== 0x80) {\n          // wrong continuation\n          i--;\n          continue;\n        }\n        codepoint = (byte1 & 0x1F) << 6 | (byte2 & 0x3F);\n        if (codepoint < 0x80) {\n          // wrong starter byte\n          i--;\n          continue;\n        }\n        target[size++] = codepoint;\n\n        // 3 bytes\n      } else if ((byte1 & 0xF0) === 0xE0) {\n        if (i >= length) {\n          this.interim[0] = byte1;\n          return size;\n        }\n        byte2 = input[i++];\n        if ((byte2 & 0xC0) !== 0x80) {\n          // wrong continuation\n          i--;\n          continue;\n        }\n        if (i >= length) {\n          this.interim[0] = byte1;\n          this.interim[1] = byte2;\n          return size;\n        }\n        byte3 = input[i++];\n        if ((byte3 & 0xC0) !== 0x80) {\n          // wrong continuation\n          i--;\n          continue;\n        }\n        codepoint = (byte1 & 0x0F) << 12 | (byte2 & 0x3F) << 6 | (byte3 & 0x3F);\n        if (codepoint < 0x0800 || (codepoint >= 0xD800 && codepoint <= 0xDFFF) || codepoint === 0xFEFF) {\n          // illegal codepoint or BOM, no i-- here\n          continue;\n        }\n        target[size++] = codepoint;\n\n        // 4 bytes\n      } else if ((byte1 & 0xF8) === 0xF0) {\n        if (i >= length) {\n          this.interim[0] = byte1;\n          return size;\n        }\n        byte2 = input[i++];\n        if ((byte2 & 0xC0) !== 0x80) {\n          // wrong continuation\n          i--;\n          continue;\n        }\n        if (i >= length) {\n          this.interim[0] = byte1;\n          this.interim[1] = byte2;\n          return size;\n        }\n        byte3 = input[i++];\n        if ((byte3 & 0xC0) !== 0x80) {\n          // wrong continuation\n          i--;\n          continue;\n        }\n        if (i >= length) {\n          this.interim[0] = byte1;\n          this.interim[1] = byte2;\n          this.interim[2] = byte3;\n          return size;\n        }\n        byte4 = input[i++];\n        if ((byte4 & 0xC0) !== 0x80) {\n          // wrong continuation\n          i--;\n          continue;\n        }\n        codepoint = (byte1 & 0x07) << 18 | (byte2 & 0x3F) << 12 | (byte3 & 0x3F) << 6 | (byte4 & 0x3F);\n        if (codepoint < 0x010000 || codepoint > 0x10FFFF) {\n          // illegal codepoint, no i-- here\n          continue;\n        }\n        target[size++] = codepoint;\n      } else {\n        // illegal byte, just skip\n      }\n    }\n    return size;\n  }\n}\n", "/**\n * Copyright (c) 2019 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nexport const DEFAULT_COLOR = 0;\nexport const DEFAULT_ATTR = (0 << 18) | (DEFAULT_COLOR << 9) | (256 << 0);\nexport const DEFAULT_EXT = 0;\n\nexport const CHAR_DATA_ATTR_INDEX = 0;\nexport const CHAR_DATA_CHAR_INDEX = 1;\nexport const CHAR_DATA_WIDTH_INDEX = 2;\nexport const CHAR_DATA_CODE_INDEX = 3;\n\n/**\n * Null cell - a real empty cell (containing nothing).\n * Note that code should always be 0 for a null cell as\n * several test condition of the buffer line rely on this.\n */\nexport const NULL_CELL_CHAR = '';\nexport const NULL_CELL_WIDTH = 1;\nexport const NULL_CELL_CODE = 0;\n\n/**\n * Whitespace cell.\n * This is meant as a replacement for empty cells when needed\n * during rendering lines to preserve correct aligment.\n */\nexport const WHITESPACE_CELL_CHAR = ' ';\nexport const WHITESPACE_CELL_WIDTH = 1;\nexport const WHITESPACE_CELL_CODE = 32;\n\n/**\n * Bitmasks for accessing data in `content`.\n */\nexport const enum Content {\n  /**\n   * bit 1..21    codepoint, max allowed in UTF32 is 0x10FFFF (21 bits taken)\n   *              read:   `codepoint = content & Content.codepointMask;`\n   *              write:  `content |= codepoint & Content.codepointMask;`\n   *                      shortcut if precondition `codepoint <= 0x10FFFF` is met:\n   *                      `content |= codepoint;`\n   */\n  CODEPOINT_MASK = 0x1FFFFF,\n\n  /**\n   * bit 22       flag indication whether a cell contains combined content\n   *              read:   `isCombined = content & Content.isCombined;`\n   *              set:    `content |= Content.isCombined;`\n   *              clear:  `content &= ~Content.isCombined;`\n   */\n  IS_COMBINED_MASK = 0x200000,  // 1 << 21\n\n  /**\n   * bit 1..22    mask to check whether a cell contains any string data\n   *              we need to check for codepoint and isCombined bits to see\n   *              whether a cell contains anything\n   *              read:   `isEmpty = !(content & Content.hasContent)`\n   */\n  HAS_CONTENT_MASK = 0x3FFFFF,\n\n  /**\n   * bit 23..24   wcwidth value of cell, takes 2 bits (ranges from 0..2)\n   *              read:   `width = (content & Content.widthMask) >> Content.widthShift;`\n   *                      `hasWidth = content & Content.widthMask;`\n   *                      as long as wcwidth is highest value in `content`:\n   *                      `width = content >> Content.widthShift;`\n   *              write:  `content |= (width << Content.widthShift) & Content.widthMask;`\n   *                      shortcut if precondition `0 <= width <= 3` is met:\n   *                      `content |= width << Content.widthShift;`\n   */\n  WIDTH_MASK = 0xC00000,   // 3 << 22\n  WIDTH_SHIFT = 22\n}\n\nexport const enum Attributes {\n  /**\n   * bit 1..8     blue in RGB, color in P256 and P16\n   */\n  BLUE_MASK = 0xFF,\n  BLUE_SHIFT = 0,\n  PCOLOR_MASK = 0xFF,\n  PCOLOR_SHIFT = 0,\n\n  /**\n   * bit 9..16    green in RGB\n   */\n  GREEN_MASK = 0xFF00,\n  GREEN_SHIFT = 8,\n\n  /**\n   * bit 17..24   red in RGB\n   */\n  RED_MASK = 0xFF0000,\n  RED_SHIFT = 16,\n\n  /**\n   * bit 25..26   color mode: DEFAULT (0) | P16 (1) | P256 (2) | RGB (3)\n   */\n  CM_MASK = 0x3000000,\n  CM_DEFAULT = 0,\n  CM_P16 = 0x1000000,\n  CM_P256 = 0x2000000,\n  CM_RGB = 0x3000000,\n\n  /**\n   * bit 1..24  RGB room\n   */\n  RGB_MASK = 0xFFFFFF\n}\n\nexport const enum FgFlags {\n  /**\n   * bit 27..32\n   */\n  INVERSE = 0x4000000,\n  BOLD = 0x8000000,\n  UNDERLINE = 0x10000000,\n  BLINK = 0x20000000,\n  INVISIBLE = 0x40000000,\n  STRIKETHROUGH = 0x80000000,\n}\n\nexport const enum BgFlags {\n  /**\n   * bit 27..32 (upper 2 unused)\n   */\n  ITALIC = 0x4000000,\n  DIM = 0x8000000,\n  HAS_EXTENDED = 0x10000000,\n  PROTECTED = 0x20000000,\n  OVERLINE = 0x40000000\n}\n\nexport const enum ExtFlags {\n  /**\n   * bit 27..29\n   */\n  UNDERLINE_STYLE = 0x1C000000,\n\n  /**\n   * bit 30..32\n   *\n   * An optional variant for the glyph, this can be used for example to offset underlines by a\n   * number of pixels to create a perfect pattern.\n   */\n  VARIANT_OFFSET = 0xE0000000\n}\n\nexport const enum UnderlineStyle {\n  NONE = 0,\n  SINGLE = 1,\n  DOUBLE = 2,\n  CURLY = 3,\n  DOTTED = 4,\n  DASHED = 5\n}\n", "/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { IAttributeData, IColorRGB, IExtendedAttrs } from 'common/Types';\nimport { Attributes, FgFlags, BgFlags, UnderlineStyle, ExtFlags } from 'common/buffer/Constants';\n\nexport class AttributeData implements IAttributeData {\n  public static toColorRGB(value: number): IColorRGB {\n    return [\n      value >>> Attributes.RED_SHIFT & 255,\n      value >>> Attributes.GREEN_SHIFT & 255,\n      value & 255\n    ];\n  }\n\n  public static fromColorRGB(value: IColorRGB): number {\n    return (value[0] & 255) << Attributes.RED_SHIFT | (value[1] & 255) << Attributes.GREEN_SHIFT | value[2] & 255;\n  }\n\n  public clone(): IAttributeData {\n    const newObj = new AttributeData();\n    newObj.fg = this.fg;\n    newObj.bg = this.bg;\n    newObj.extended = this.extended.clone();\n    return newObj;\n  }\n\n  // data\n  public fg = 0;\n  public bg = 0;\n  public extended: IExtendedAttrs = new ExtendedAttrs();\n\n  // flags\n  public isInverse(): number       { return this.fg & FgFlags.INVERSE; }\n  public isBold(): number          { return this.fg & FgFlags.BOLD; }\n  public isUnderline(): number     {\n    if (this.hasExtendedAttrs() && this.extended.underlineStyle !== UnderlineStyle.NONE) {\n      return 1;\n    }\n    return this.fg & FgFlags.UNDERLINE;\n  }\n  public isBlink(): number         { return this.fg & FgFlags.BLINK; }\n  public isInvisible(): number     { return this.fg & FgFlags.INVISIBLE; }\n  public isItalic(): number        { return this.bg & BgFlags.ITALIC; }\n  public isDim(): number           { return this.bg & BgFlags.DIM; }\n  public isStrikethrough(): number { return this.fg & FgFlags.STRIKETHROUGH; }\n  public isProtected(): number     { return this.bg & BgFlags.PROTECTED; }\n  public isOverline(): number      { return this.bg & BgFlags.OVERLINE; }\n\n  // color modes\n  public getFgColorMode(): number { return this.fg & Attributes.CM_MASK; }\n  public getBgColorMode(): number { return this.bg & Attributes.CM_MASK; }\n  public isFgRGB(): boolean       { return (this.fg & Attributes.CM_MASK) === Attributes.CM_RGB; }\n  public isBgRGB(): boolean       { return (this.bg & Attributes.CM_MASK) === Attributes.CM_RGB; }\n  public isFgPalette(): boolean   { return (this.fg & Attributes.CM_MASK) === Attributes.CM_P16 || (this.fg & Attributes.CM_MASK) === Attributes.CM_P256; }\n  public isBgPalette(): boolean   { return (this.bg & Attributes.CM_MASK) === Attributes.CM_P16 || (this.bg & Attributes.CM_MASK) === Attributes.CM_P256; }\n  public isFgDefault(): boolean   { return (this.fg & Attributes.CM_MASK) === 0; }\n  public isBgDefault(): boolean   { return (this.bg & Attributes.CM_MASK) === 0; }\n  public isAttributeDefault(): boolean { return this.fg === 0 && this.bg === 0; }\n\n  // colors\n  public getFgColor(): number {\n    switch (this.fg & Attributes.CM_MASK) {\n      case Attributes.CM_P16:\n      case Attributes.CM_P256:  return this.fg & Attributes.PCOLOR_MASK;\n      case Attributes.CM_RGB:   return this.fg & Attributes.RGB_MASK;\n      default:                  return -1;  // CM_DEFAULT defaults to -1\n    }\n  }\n  public getBgColor(): number {\n    switch (this.bg & Attributes.CM_MASK) {\n      case Attributes.CM_P16:\n      case Attributes.CM_P256:  return this.bg & Attributes.PCOLOR_MASK;\n      case Attributes.CM_RGB:   return this.bg & Attributes.RGB_MASK;\n      default:                  return -1;  // CM_DEFAULT defaults to -1\n    }\n  }\n\n  // extended attrs\n  public hasExtendedAttrs(): number {\n    return this.bg & BgFlags.HAS_EXTENDED;\n  }\n  public updateExtended(): void {\n    if (this.extended.isEmpty()) {\n      this.bg &= ~BgFlags.HAS_EXTENDED;\n    } else {\n      this.bg |= BgFlags.HAS_EXTENDED;\n    }\n  }\n  public getUnderlineColor(): number {\n    if ((this.bg & BgFlags.HAS_EXTENDED) && ~this.extended.underlineColor) {\n      switch (this.extended.underlineColor & Attributes.CM_MASK) {\n        case Attributes.CM_P16:\n        case Attributes.CM_P256:  return this.extended.underlineColor & Attributes.PCOLOR_MASK;\n        case Attributes.CM_RGB:   return this.extended.underlineColor & Attributes.RGB_MASK;\n        default:                  return this.getFgColor();\n      }\n    }\n    return this.getFgColor();\n  }\n  public getUnderlineColorMode(): number {\n    return (this.bg & BgFlags.HAS_EXTENDED) && ~this.extended.underlineColor\n      ? this.extended.underlineColor & Attributes.CM_MASK\n      : this.getFgColorMode();\n  }\n  public isUnderlineColorRGB(): boolean {\n    return (this.bg & BgFlags.HAS_EXTENDED) && ~this.extended.underlineColor\n      ? (this.extended.underlineColor & Attributes.CM_MASK) === Attributes.CM_RGB\n      : this.isFgRGB();\n  }\n  public isUnderlineColorPalette(): boolean {\n    return (this.bg & BgFlags.HAS_EXTENDED) && ~this.extended.underlineColor\n      ? (this.extended.underlineColor & Attributes.CM_MASK) === Attributes.CM_P16\n          || (this.extended.underlineColor & Attributes.CM_MASK) === Attributes.CM_P256\n      : this.isFgPalette();\n  }\n  public isUnderlineColorDefault(): boolean {\n    return (this.bg & BgFlags.HAS_EXTENDED) && ~this.extended.underlineColor\n      ? (this.extended.underlineColor & Attributes.CM_MASK) === 0\n      : this.isFgDefault();\n  }\n  public getUnderlineStyle(): UnderlineStyle {\n    return this.fg & FgFlags.UNDERLINE\n      ? (this.bg & BgFlags.HAS_EXTENDED ? this.extended.underlineStyle : UnderlineStyle.SINGLE)\n      : UnderlineStyle.NONE;\n  }\n  public getUnderlineVariantOffset(): number {\n    return this.extended.underlineVariantOffset;\n  }\n}\n\n\n/**\n * Extended attributes for a cell.\n * Holds information about different underline styles and color.\n */\nexport class ExtendedAttrs implements IExtendedAttrs {\n  private _ext: number = 0;\n  public get ext(): number {\n    if (this._urlId) {\n      return (\n        (this._ext & ~ExtFlags.UNDERLINE_STYLE) |\n        (this.underlineStyle << 26)\n      );\n    }\n    return this._ext;\n  }\n  public set ext(value: number) { this._ext = value; }\n\n  public get underlineStyle(): UnderlineStyle {\n    // Always return the URL style if it has one\n    if (this._urlId) {\n      return UnderlineStyle.DASHED;\n    }\n    return (this._ext & ExtFlags.UNDERLINE_STYLE) >> 26;\n  }\n  public set underlineStyle(value: UnderlineStyle) {\n    this._ext &= ~ExtFlags.UNDERLINE_STYLE;\n    this._ext |= (value << 26) & ExtFlags.UNDERLINE_STYLE;\n  }\n\n  public get underlineColor(): number {\n    return this._ext & (Attributes.CM_MASK | Attributes.RGB_MASK);\n  }\n  public set underlineColor(value: number) {\n    this._ext &= ~(Attributes.CM_MASK | Attributes.RGB_MASK);\n    this._ext |= value & (Attributes.CM_MASK | Attributes.RGB_MASK);\n  }\n\n  private _urlId: number = 0;\n  public get urlId(): number {\n    return this._urlId;\n  }\n  public set urlId(value: number) {\n    this._urlId = value;\n  }\n\n  public get underlineVariantOffset(): number {\n    const val = (this._ext & ExtFlags.VARIANT_OFFSET) >> 29;\n    if (val < 0) {\n      return val ^ 0xFFFFFFF8;\n    }\n    return val;\n  }\n  public set underlineVariantOffset(value: number) {\n    this._ext &= ~ExtFlags.VARIANT_OFFSET;\n    this._ext |= (value << 29) & ExtFlags.VARIANT_OFFSET;\n  }\n\n  constructor(\n    ext: number = 0,\n    urlId: number = 0\n  ) {\n    this._ext = ext;\n    this._urlId = urlId;\n  }\n\n  public clone(): IExtendedAttrs {\n    return new ExtendedAttrs(this._ext, this._urlId);\n  }\n\n  /**\n   * Convenient method to indicate whether the object holds no additional information,\n   * that needs to be persistant in the buffer.\n   */\n  public isEmpty(): boolean {\n    return this.underlineStyle === UnderlineStyle.NONE && this._urlId === 0;\n  }\n}\n", "/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { CharData, ICellData, IExtendedAttrs } from 'common/Types';\nimport { stringFromCodePoint } from 'common/input/TextDecoder';\nimport { CHAR_DATA_CHAR_INDEX, CHAR_DATA_WIDTH_INDEX, CHAR_DATA_ATTR_INDEX, Content } from 'common/buffer/Constants';\nimport { AttributeData, ExtendedAttrs } from 'common/buffer/AttributeData';\n\n/**\n * CellData - represents a single Cell in the terminal buffer.\n */\nexport class CellData extends AttributeData implements ICellData {\n  /** Helper to create CellData from CharData. */\n  public static fromCharData(value: CharData): CellData {\n    const obj = new CellData();\n    obj.setFromCharData(value);\n    return obj;\n  }\n  /** Primitives from terminal buffer. */\n  public content = 0;\n  public fg = 0;\n  public bg = 0;\n  public extended: IExtendedAttrs = new ExtendedAttrs();\n  public combinedData = '';\n  /** Whether cell contains a combined string. */\n  public isCombined(): number {\n    return this.content & Content.IS_COMBINED_MASK;\n  }\n  /** Width of the cell. */\n  public getWidth(): number {\n    return this.content >> Content.WIDTH_SHIFT;\n  }\n  /** JS string of the content. */\n  public getChars(): string {\n    if (this.content & Content.IS_COMBINED_MASK) {\n      return this.combinedData;\n    }\n    if (this.content & Content.CODEPOINT_MASK) {\n      return stringFromCodePoint(this.content & Content.CODEPOINT_MASK);\n    }\n    return '';\n  }\n  /**\n   * Codepoint of cell\n   * Note this returns the UTF32 codepoint of single chars,\n   * if content is a combined string it returns the codepoint\n   * of the last char in string to be in line with code in CharData.\n   */\n  public getCode(): number {\n    return (this.isCombined())\n      ? this.combinedData.charCodeAt(this.combinedData.length - 1)\n      : this.content & Content.CODEPOINT_MASK;\n  }\n  /** Set data from CharData */\n  public setFromCharData(value: CharData): void {\n    this.fg = value[CHAR_DATA_ATTR_INDEX];\n    this.bg = 0;\n    let combined = false;\n    // surrogates and combined strings need special treatment\n    if (value[CHAR_DATA_CHAR_INDEX].length > 2) {\n      combined = true;\n    }\n    else if (value[CHAR_DATA_CHAR_INDEX].length === 2) {\n      const code = value[CHAR_DATA_CHAR_INDEX].charCodeAt(0);\n      // if the 2-char string is a surrogate create single codepoint\n      // everything else is combined\n      if (0xD800 <= code && code <= 0xDBFF) {\n        const second = value[CHAR_DATA_CHAR_INDEX].charCodeAt(1);\n        if (0xDC00 <= second && second <= 0xDFFF) {\n          this.content = ((code - 0xD800) * 0x400 + second - 0xDC00 + 0x10000) | (value[CHAR_DATA_WIDTH_INDEX] << Content.WIDTH_SHIFT);\n        }\n        else {\n          combined = true;\n        }\n      }\n      else {\n        combined = true;\n      }\n    }\n    else {\n      this.content = value[CHAR_DATA_CHAR_INDEX].charCodeAt(0) | (value[CHAR_DATA_WIDTH_INDEX] << Content.WIDTH_SHIFT);\n    }\n    if (combined) {\n      this.combinedData = value[CHAR_DATA_CHAR_INDEX];\n      this.content = Content.IS_COMBINED_MASK | (value[CHAR_DATA_WIDTH_INDEX] << Content.WIDTH_SHIFT);\n    }\n  }\n  /** Get data as CharData. */\n  public getAsCharData(): CharData {\n    return [this.fg, this.getChars(), this.getWidth(), this.getCode()];\n  }\n}\n", "/**\n * Copyright (c) 2019 The xterm.js authors. All rights reserved.\n * @license MIT\n *\n * This was heavily inspired from microsoft/vscode's dependency injection system (MIT).\n */\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IServiceIdentifier } from 'common/services/Services';\n\nconst DI_TARGET = 'di$target';\nconst DI_DEPENDENCIES = 'di$dependencies';\n\nexport const serviceRegistry: Map<string, IServiceIdentifier<any>> = new Map();\n\nexport function getServiceDependencies(ctor: any): { id: IServiceIdentifier<any>, index: number, optional: boolean }[] {\n  return ctor[DI_DEPENDENCIES] || [];\n}\n\nexport function createDecorator<T>(id: string): IServiceIdentifier<T> {\n  if (serviceRegistry.has(id)) {\n    return serviceRegistry.get(id)!;\n  }\n\n  const decorator: any = function (target: Function, key: string, index: number): any {\n    if (arguments.length !== 3) {\n      throw new Error('@IServiceName-decorator can only be used to decorate a parameter');\n    }\n\n    storeServiceDependency(decorator, target, index);\n  };\n\n  decorator._id = id;\n\n  serviceRegistry.set(id, decorator);\n  return decorator;\n}\n\nfunction storeServiceDependency(id: Function, target: Function, index: number): void {\n  if ((target as any)[DI_TARGET] === target) {\n    (target as any)[DI_DEPENDENCIES].push({ id, index });\n  } else {\n    (target as any)[DI_DEPENDENCIES] = [{ id, index }];\n    (target as any)[DI_TARGET] = target;\n  }\n}\n", "/**\n * Copyright (c) 2019 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { IDecoration, IDecorationOptions, ILinkHandler, ILogger, IWindowsPty, type IOverviewRulerOptions } from '@xterm/xterm';\nimport { CoreMouseEncoding, CoreMouseEventType, CursorInactiveStyle, CursorStyle, IAttributeData, ICharset, IColor, ICoreMouseEvent, ICoreMouseProtocol, IDecPrivateModes, IDisposable, IModes, IOscLinkData, IWindowOptions } from 'common/Types';\nimport { IBuffer, IBufferSet } from 'common/buffer/Types';\nimport { createDecorator } from 'common/services/ServiceRegistry';\nimport type { Emitter, Event } from 'vs/base/common/event';\n\nexport const IBufferService = createDecorator<IBufferService>('BufferService');\nexport interface IBufferService {\n  serviceBrand: undefined;\n\n  readonly cols: number;\n  readonly rows: number;\n  readonly buffer: IBuffer;\n  readonly buffers: IBufferSet;\n  isUserScrolling: boolean;\n  onResize: Event<{ cols: number, rows: number }>;\n  onScroll: Event<number>;\n  scroll(eraseAttr: IAttributeData, isWrapped?: boolean): void;\n  scrollLines(disp: number, suppressScrollEvent?: boolean): void;\n  resize(cols: number, rows: number): void;\n  reset(): void;\n}\n\nexport const ICoreMouseService = createDecorator<ICoreMouseService>('CoreMouseService');\nexport interface ICoreMouseService {\n  serviceBrand: undefined;\n\n  activeProtocol: string;\n  activeEncoding: string;\n  areMouseEventsActive: boolean;\n  addProtocol(name: string, protocol: ICoreMouseProtocol): void;\n  addEncoding(name: string, encoding: CoreMouseEncoding): void;\n  reset(): void;\n\n  /**\n   * Triggers a mouse event to be sent.\n   *\n   * Returns true if the event passed all protocol restrictions and a report\n   * was sent, otherwise false. The return value may be used to decide whether\n   * the default event action in the bowser component should be omitted.\n   *\n   * Note: The method will change values of the given event object\n   * to fullfill protocol and encoding restrictions.\n   */\n  triggerMouseEvent(event: ICoreMouseEvent): boolean;\n\n  /**\n   * Event to announce changes in mouse tracking.\n   */\n  onProtocolChange: Event<CoreMouseEventType>;\n\n  /**\n   * Human readable version of mouse events.\n   */\n  explainEvents(events: CoreMouseEventType): { [event: string]: boolean };\n}\n\nexport const ICoreService = createDecorator<ICoreService>('CoreService');\nexport interface ICoreService {\n  serviceBrand: undefined;\n\n  /**\n   * Initially the cursor will not be visible until the first time the terminal\n   * is focused.\n   */\n  isCursorInitialized: boolean;\n  isCursorHidden: boolean;\n\n  readonly modes: IModes;\n  readonly decPrivateModes: IDecPrivateModes;\n\n  readonly onData: Event<string>;\n  readonly onUserInput: Event<void>;\n  readonly onBinary: Event<string>;\n  readonly onRequestScrollToBottom: Event<void>;\n\n  reset(): void;\n\n  /**\n   * Triggers the onData event in the public API.\n   * @param data The data that is being emitted.\n   * @param wasUserInput Whether the data originated from the user (as opposed to\n   * resulting from parsing incoming data). When true this will also:\n   * - Scroll to the bottom of the buffer if option scrollOnUserInput is true.\n   * - Fire the `onUserInput` event (so selection can be cleared).\n   */\n  triggerDataEvent(data: string, wasUserInput?: boolean): void;\n\n  /**\n   * Triggers the onBinary event in the public API.\n   * @param data The data that is being emitted.\n   */\n  triggerBinaryEvent(data: string): void;\n}\n\nexport const ICharsetService = createDecorator<ICharsetService>('CharsetService');\nexport interface ICharsetService {\n  serviceBrand: undefined;\n\n  charset: ICharset | undefined;\n  readonly glevel: number;\n\n  reset(): void;\n\n  /**\n   * Set the G level of the terminal.\n   * @param g\n   */\n  setgLevel(g: number): void;\n\n  /**\n   * Set the charset for the given G level of the terminal.\n   * @param g\n   * @param charset\n   */\n  setgCharset(g: number, charset: ICharset | undefined): void;\n}\n\nexport interface IServiceIdentifier<T> {\n  (...args: any[]): void;\n  type: T;\n  _id: string;\n}\n\nexport interface IBrandedService {\n  serviceBrand: undefined;\n}\n\ntype GetLeadingNonServiceArgs<TArgs extends any[]> = TArgs extends [] ? []\n  : TArgs extends [...infer TFirst, infer TLast] ? TLast extends IBrandedService ? GetLeadingNonServiceArgs<TFirst> : TArgs\n    : never;\n\nexport const IInstantiationService = createDecorator<IInstantiationService>('InstantiationService');\nexport interface IInstantiationService {\n  serviceBrand: undefined;\n\n  setService<T>(id: IServiceIdentifier<T>, instance: T): void;\n  getService<T>(id: IServiceIdentifier<T>): T | undefined;\n  createInstance<Ctor extends new (...args: any[]) => any, R extends InstanceType<Ctor>>(t: Ctor, ...args: GetLeadingNonServiceArgs<ConstructorParameters<Ctor>>): R;\n}\n\nexport enum LogLevelEnum {\n  TRACE = 0,\n  DEBUG = 1,\n  INFO = 2,\n  WARN = 3,\n  ERROR = 4,\n  OFF = 5\n}\n\nexport const ILogService = createDecorator<ILogService>('LogService');\nexport interface ILogService {\n  serviceBrand: undefined;\n\n  readonly logLevel: LogLevelEnum;\n\n  trace(message: any, ...optionalParams: any[]): void;\n  debug(message: any, ...optionalParams: any[]): void;\n  info(message: any, ...optionalParams: any[]): void;\n  warn(message: any, ...optionalParams: any[]): void;\n  error(message: any, ...optionalParams: any[]): void;\n}\n\nexport const IOptionsService = createDecorator<IOptionsService>('OptionsService');\nexport interface IOptionsService {\n  serviceBrand: undefined;\n\n  /**\n   * Read only access to the raw options object, this is an internal-only fast path for accessing\n   * single options without any validation as we trust TypeScript to enforce correct usage\n   * internally.\n   */\n  readonly rawOptions: Required<ITerminalOptions>;\n\n  /**\n   * Options as exposed through the public API, this property uses getters and setters with\n   * validation which makes it safer but slower. {@link rawOptions} should be used for pretty much\n   * all internal usage for performance reasons.\n   */\n  readonly options: Required<ITerminalOptions>;\n\n  /**\n   * Adds an event listener for when any option changes.\n   */\n  readonly onOptionChange: Event<keyof ITerminalOptions>;\n\n  /**\n   * Adds an event listener for when a specific option changes, this is a convenience method that is\n   * preferred over {@link onOptionChange} when only a single option is being listened to.\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  onSpecificOptionChange<T extends keyof ITerminalOptions>(key: T, listener: (arg1: Required<ITerminalOptions>[T]) => any): IDisposable;\n\n  /**\n   * Adds an event listener for when a set of specific options change, this is a convenience method\n   * that is preferred over {@link onOptionChange} when multiple options are being listened to and\n   * handled the same way.\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  onMultipleOptionChange(keys: (keyof ITerminalOptions)[], listener: () => any): IDisposable;\n}\n\nexport type FontWeight = 'normal' | 'bold' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900' | number;\nexport type LogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'off';\n\nexport interface ITerminalOptions {\n  allowProposedApi?: boolean;\n  allowTransparency?: boolean;\n  altClickMovesCursor?: boolean;\n  cols?: number;\n  convertEol?: boolean;\n  cursorBlink?: boolean;\n  cursorStyle?: CursorStyle;\n  cursorWidth?: number;\n  cursorInactiveStyle?: CursorInactiveStyle;\n  customGlyphs?: boolean;\n  disableStdin?: boolean;\n  documentOverride?: any | null;\n  drawBoldTextInBrightColors?: boolean;\n  /** @deprecated No longer supported */\n  fastScrollModifier?: 'none' | 'alt' | 'ctrl' | 'shift';\n  fastScrollSensitivity?: number;\n  fontSize?: number;\n  fontFamily?: string;\n  fontWeight?: FontWeight;\n  fontWeightBold?: FontWeight;\n  ignoreBracketedPasteMode?: boolean;\n  letterSpacing?: number;\n  lineHeight?: number;\n  linkHandler?: ILinkHandler | null;\n  logLevel?: LogLevel;\n  logger?: ILogger | null;\n  macOptionIsMeta?: boolean;\n  macOptionClickForcesSelection?: boolean;\n  minimumContrastRatio?: number;\n  reflowCursorLine?: boolean;\n  rescaleOverlappingGlyphs?: boolean;\n  rightClickSelectsWord?: boolean;\n  rows?: number;\n  screenReaderMode?: boolean;\n  scrollback?: number;\n  scrollOnUserInput?: boolean;\n  scrollSensitivity?: number;\n  smoothScrollDuration?: number;\n  tabStopWidth?: number;\n  theme?: ITheme;\n  windowsMode?: boolean;\n  windowsPty?: IWindowsPty;\n  windowOptions?: IWindowOptions;\n  wordSeparator?: string;\n  overviewRuler?: IOverviewRulerOptions;\n\n  [key: string]: any;\n  cancelEvents: boolean;\n  termName: string;\n}\n\nexport interface ITheme {\n  foreground?: string;\n  background?: string;\n  cursor?: string;\n  cursorAccent?: string;\n  selectionForeground?: string;\n  selectionBackground?: string;\n  selectionInactiveBackground?: string;\n  scrollbarSliderBackground?: string;\n  scrollbarSliderHoverBackground?: string;\n  scrollbarSliderActiveBackground?: string;\n  overviewRulerBorder?: string;\n  black?: string;\n  red?: string;\n  green?: string;\n  yellow?: string;\n  blue?: string;\n  magenta?: string;\n  cyan?: string;\n  white?: string;\n  brightBlack?: string;\n  brightRed?: string;\n  brightGreen?: string;\n  brightYellow?: string;\n  brightBlue?: string;\n  brightMagenta?: string;\n  brightCyan?: string;\n  brightWhite?: string;\n  extendedAnsi?: string[];\n}\n\nexport const IOscLinkService = createDecorator<IOscLinkService>('OscLinkService');\nexport interface IOscLinkService {\n  serviceBrand: undefined;\n  /**\n   * Registers a link to the service, returning the link ID. The link data is managed by this\n   * service and will be freed when this current cursor position is trimmed off the buffer.\n   */\n  registerLink(linkData: IOscLinkData): number;\n  /**\n   * Adds a line to a link if needed.\n   */\n  addLineToLink(linkId: number, y: number): void;\n  /** Get the link data associated with a link ID. */\n  getLinkData(linkId: number): IOscLinkData | undefined;\n}\n\n/*\n * Width and Grapheme_Cluster_Break properties of a character as a bit mask.\n *\n * bit 0: shouldJoin - should combine with preceding character.\n * bit 1..2: wcwidth - see UnicodeCharWidth.\n * bit 3..31: class of character (currently only 4 bits are used).\n *   This is used to determined grapheme clustering - i.e. which codepoints\n *   are to be combined into a single compound character.\n *\n * Use the UnicodeService static function createPropertyValue to create a\n * UnicodeCharProperties; use extractShouldJoin, extractWidth, and\n * extractCharKind to extract the components.\n */\nexport type UnicodeCharProperties = number;\n\n/**\n * Width in columns of a character.\n * In a CJK context, \"half-width\" characters (such as Latin) are width 1,\n * while \"full-width\" characters (such as Kanji) are 2 columns wide.\n * Combining characters (such as accents) are width 0.\n */\nexport type UnicodeCharWidth = 0 | 1 | 2;\n\nexport const IUnicodeService = createDecorator<IUnicodeService>('UnicodeService');\nexport interface IUnicodeService {\n  serviceBrand: undefined;\n  /** Register an Unicode version provider. */\n  register(provider: IUnicodeVersionProvider): void;\n  /** Registered Unicode versions. */\n  readonly versions: string[];\n  /** Currently active version. */\n  activeVersion: string;\n  /** Event triggered, when activate version changed. */\n  readonly onChange: Event<string>;\n\n  /**\n   * Unicode version dependent\n   */\n  wcwidth(codepoint: number): UnicodeCharWidth;\n  getStringCellWidth(s: string): number;\n  /**\n   * Return character width and type for grapheme clustering.\n   * If preceding != 0, it is the return code from the previous character;\n   * in that case the result specifies if the characters should be joined.\n   */\n  charProperties(codepoint: number, preceding: UnicodeCharProperties): UnicodeCharProperties;\n}\n\nexport interface IUnicodeVersionProvider {\n  readonly version: string;\n  wcwidth(ucs: number): UnicodeCharWidth;\n  charProperties(codepoint: number, preceding: UnicodeCharProperties): UnicodeCharProperties;\n}\n\nexport const IDecorationService = createDecorator<IDecorationService>('DecorationService');\nexport interface IDecorationService extends IDisposable {\n  serviceBrand: undefined;\n  readonly decorations: IterableIterator<IInternalDecoration>;\n  readonly onDecorationRegistered: Event<IInternalDecoration>;\n  readonly onDecorationRemoved: Event<IInternalDecoration>;\n  registerDecoration(decorationOptions: IDecorationOptions): IDecoration | undefined;\n  reset(): void;\n  /**\n   * Trigger a callback over the decoration at a cell (in no particular order). This uses a callback\n   * instead of an iterator as it's typically used in hot code paths.\n   */\n  forEachDecorationAtCell(x: number, line: number, layer: 'bottom' | 'top' | undefined, callback: (decoration: IInternalDecoration) => void): void;\n}\nexport interface IInternalDecoration extends IDecoration {\n  readonly options: IDecorationOptions;\n  readonly backgroundColorRGB: IColor | undefined;\n  readonly foregroundColorRGB: IColor | undefined;\n  readonly onRenderEmitter: Emitter<HTMLElement>;\n}\n", "/**\n * Copyright (c) 2022 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { IBufferRange, ILink } from 'browser/Types';\nimport { ILinkProvider } from 'browser/services/Services';\nimport { CellData } from 'common/buffer/CellData';\nimport { IBufferService, IOptionsService, IOscLinkService } from 'common/services/Services';\n\nexport class OscLinkProvider implements ILinkProvider {\n  constructor(\n    @IBufferService private readonly _bufferService: IBufferService,\n    @IOptionsService private readonly _optionsService: IOptionsService,\n    @IOscLinkService private readonly _oscLinkService: IOscLinkService\n  ) {\n  }\n\n  public provideLinks(y: number, callback: (links: ILink[] | undefined) => void): void {\n    const line = this._bufferService.buffer.lines.get(y - 1);\n    if (!line) {\n      callback(undefined);\n      return;\n    }\n\n    const result: ILink[] = [];\n    const linkHandler = this._optionsService.rawOptions.linkHandler;\n    const cell = new CellData();\n    const lineLength = line.getTrimmedLength();\n    let currentLinkId = -1;\n    let currentStart = -1;\n    let finishLink = false;\n    for (let x = 0; x < lineLength; x++) {\n      // Minor optimization, only check for content if there isn't a link in case the link ends with\n      // a null cell\n      if (currentStart === -1 && !line.hasContent(x)) {\n        continue;\n      }\n\n      line.loadCell(x, cell);\n      if (cell.hasExtendedAttrs() && cell.extended.urlId) {\n        if (currentStart === -1) {\n          currentStart = x;\n          currentLinkId = cell.extended.urlId;\n          continue;\n        } else {\n          finishLink = cell.extended.urlId !== currentLinkId;\n        }\n      } else {\n        if (currentStart !== -1) {\n          finishLink = true;\n        }\n      }\n\n      if (finishLink || (currentStart !== -1 && x === lineLength - 1)) {\n        const text = this._oscLinkService.getLinkData(currentLinkId)?.uri;\n        if (text) {\n          // These ranges are 1-based\n          const range: IBufferRange = {\n            start: {\n              x: currentStart + 1,\n              y\n            },\n            end: {\n              // Offset end x if it's a link that ends on the last cell in the line\n              x: x + (!finishLink && x === lineLength - 1 ? 1 : 0),\n              y\n            }\n          };\n\n          let ignoreLink = false;\n          if (!linkHandler?.allowNonHttpProtocols) {\n            try {\n              const parsed = new URL(text);\n              if (!['http:', 'https:'].includes(parsed.protocol)) {\n                ignoreLink = true;\n              }\n            } catch (e) {\n              // Ignore invalid URLs to prevent unexpected behaviors\n              ignoreLink = true;\n            }\n          }\n\n          if (!ignoreLink) {\n            // OSC links always use underline and pointer decorations\n            result.push({\n              text,\n              range,\n              activate: (e, text) => (linkHandler ? linkHandler.activate(e, text, range) : defaultActivate(e, text)),\n              hover: (e, text) => linkHandler?.hover?.(e, text, range),\n              leave: (e, text) => linkHandler?.leave?.(e, text, range)\n            });\n          }\n        }\n        finishLink = false;\n\n        // Clear link or start a new link if one starts immediately\n        if (cell.hasExtendedAttrs() && cell.extended.urlId) {\n          currentStart = x;\n          currentLinkId = cell.extended.urlId;\n        } else {\n          currentStart = -1;\n          currentLinkId = -1;\n        }\n      }\n    }\n\n    // TODO: Handle fetching and returning other link ranges to underline other links with the same\n    //       id\n    callback(result);\n  }\n}\n\nfunction defaultActivate(e: MouseEvent, uri: string): void {\n  const answer = confirm(`Do you want to navigate to ${uri}?\\n\\nWARNING: This link could potentially be dangerous`);\n  if (answer) {\n    const newWindow = window.open();\n    if (newWindow) {\n      try {\n        newWindow.opener = null;\n      } catch {\n        // no-op, Electron can throw\n      }\n      newWindow.location.href = uri;\n    } else {\n      console.warn('Opening link blocked as opener could not be cleared');\n    }\n  }\n}\n", "/**\n * Copyright (c) 2019 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { IRenderDimensions, IRenderer } from 'browser/renderer/shared/Types';\nimport { IColorSet, ILink, ReadonlyColorSet } from 'browser/Types';\nimport { ISelectionRedrawRequestEvent as ISelectionRequestRedrawEvent, ISelectionRequestScrollLinesEvent } from 'browser/selection/Types';\nimport { createDecorator } from 'common/services/ServiceRegistry';\nimport { AllColorIndex, IDisposable } from 'common/Types';\nimport type { Event } from 'vs/base/common/event';\n\nexport const ICharSizeService = createDecorator<ICharSizeService>('CharSizeService');\nexport interface ICharSizeService {\n  serviceBrand: undefined;\n\n  readonly width: number;\n  readonly height: number;\n  readonly hasValidSize: boolean;\n\n  readonly onCharSizeChange: Event<void>;\n\n  measure(): void;\n}\n\nexport const ICoreBrowserService = createDecorator<ICoreBrowserService>('CoreBrowserService');\nexport interface ICoreBrowserService {\n  serviceBrand: undefined;\n\n  readonly isFocused: boolean;\n\n  readonly onDprChange: Event<number>;\n  readonly onWindowChange: Event<Window & typeof globalThis>;\n\n  /**\n   * Gets or sets the parent window that the terminal is rendered into. DOM and rendering APIs (e.g.\n   * requestAnimationFrame) should be invoked in the context of this window. This should be set when\n   * the window hosting the xterm.js instance changes.\n   */\n  window: Window & typeof globalThis;\n  /**\n   * The document of the primary window to be used to create elements when working with multiple\n   * windows. This is defined by the documentOverride setting.\n   */\n  readonly mainDocument: Document;\n  /**\n   * Helper for getting the devicePixelRatio of the parent window.\n   */\n  readonly dpr: number;\n}\n\nexport const IMouseService = createDecorator<IMouseService>('MouseService');\nexport interface IMouseService {\n  serviceBrand: undefined;\n\n  getCoords(event: {clientX: number, clientY: number}, element: HTMLElement, colCount: number, rowCount: number, isSelection?: boolean): [number, number] | undefined;\n  getMouseReportCoords(event: MouseEvent, element: HTMLElement): { col: number, row: number, x: number, y: number } | undefined;\n}\n\nexport const IRenderService = createDecorator<IRenderService>('RenderService');\nexport interface IRenderService extends IDisposable {\n  serviceBrand: undefined;\n\n  onDimensionsChange: Event<IRenderDimensions>;\n  /**\n   * Fires when buffer changes are rendered. This does not fire when only cursor\n   * or selections are rendered.\n   */\n  onRenderedViewportChange: Event<{ start: number, end: number }>;\n  /**\n   * Fires on render\n   */\n  onRender: Event<{ start: number, end: number }>;\n  onRefreshRequest: Event<{ start: number, end: number }>;\n\n  dimensions: IRenderDimensions;\n\n  addRefreshCallback(callback: FrameRequestCallback): number;\n\n  refreshRows(start: number, end: number): void;\n  clearTextureAtlas(): void;\n  resize(cols: number, rows: number): void;\n  hasRenderer(): boolean;\n  setRenderer(renderer: IRenderer): void;\n  handleDevicePixelRatioChange(): void;\n  handleResize(cols: number, rows: number): void;\n  handleCharSizeChanged(): void;\n  handleBlur(): void;\n  handleFocus(): void;\n  handleSelectionChanged(start: [number, number] | undefined, end: [number, number] | undefined, columnSelectMode: boolean): void;\n  handleCursorMove(): void;\n  clear(): void;\n}\n\nexport const ISelectionService = createDecorator<ISelectionService>('SelectionService');\nexport interface ISelectionService {\n  serviceBrand: undefined;\n\n  readonly selectionText: string;\n  readonly hasSelection: boolean;\n  readonly selectionStart: [number, number] | undefined;\n  readonly selectionEnd: [number, number] | undefined;\n\n  readonly onLinuxMouseSelection: Event<string>;\n  readonly onRequestRedraw: Event<ISelectionRequestRedrawEvent>;\n  readonly onRequestScrollLines: Event<ISelectionRequestScrollLinesEvent>;\n  readonly onSelectionChange: Event<void>;\n\n  disable(): void;\n  enable(): void;\n  reset(): void;\n  setSelection(row: number, col: number, length: number): void;\n  selectAll(): void;\n  selectLines(start: number, end: number): void;\n  clearSelection(): void;\n  rightClickSelect(event: MouseEvent): void;\n  shouldColumnSelect(event: KeyboardEvent | MouseEvent): boolean;\n  shouldForceSelection(event: MouseEvent): boolean;\n  refresh(isLinuxMouseSelection?: boolean): void;\n  handleMouseDown(event: MouseEvent): void;\n  isCellInSelection(x: number, y: number): boolean;\n}\n\nexport const ICharacterJoinerService = createDecorator<ICharacterJoinerService>('CharacterJoinerService');\nexport interface ICharacterJoinerService {\n  serviceBrand: undefined;\n\n  register(handler: (text: string) => [number, number][]): number;\n  deregister(joinerId: number): boolean;\n  getJoinedCharacters(row: number): [number, number][];\n}\n\nexport const IThemeService = createDecorator<IThemeService>('ThemeService');\nexport interface IThemeService {\n  serviceBrand: undefined;\n\n  readonly colors: ReadonlyColorSet;\n\n  readonly onChangeColors: Event<ReadonlyColorSet>;\n\n  restoreColor(slot?: AllColorIndex): void;\n  /**\n   * Allows external modifying of colors in the theme, this is used instead of {@link colors} to\n   * prevent accidental writes.\n   */\n  modifyColors(callback: (colors: IColorSet) => void): void;\n}\n\n\nexport const ILinkProviderService = createDecorator<ILinkProviderService>('LinkProviderService');\nexport interface ILinkProviderService extends IDisposable {\n  serviceBrand: undefined;\n  readonly linkProviders: ReadonlyArray<ILinkProvider>;\n  registerLinkProvider(linkProvider: ILinkProvider): IDisposable;\n}\nexport interface ILinkProvider {\n  provideLinks(y: number, callback: (links: ILink[] | undefined) => void): void;\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport interface ErrorListenerCallback {\n\t(error: any): void;\n}\n\nexport interface ErrorListenerUnbind {\n\t(): void;\n}\n\n// Avoid circular dependency on EventEmitter by implementing a subset of the interface.\nexport class ErrorHandler {\n\tprivate unexpectedErrorHandler: (e: any) => void;\n\tprivate listeners: ErrorListenerCallback[];\n\n\tconstructor() {\n\n\t\tthis.listeners = [];\n\n\t\tthis.unexpectedErrorHandler = function (e: any) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (e.stack) {\n\t\t\t\t\tif (ErrorNoTelemetry.isErrorNoTelemetry(e)) {\n\t\t\t\t\t\tthrow new ErrorNoTelemetry(e.message + '\\n\\n' + e.stack);\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new Error(e.message + '\\n\\n' + e.stack);\n\t\t\t\t}\n\n\t\t\t\tthrow e;\n\t\t\t}, 0);\n\t\t};\n\t}\n\n\taddListener(listener: ErrorListenerCallback): ErrorListenerUnbind {\n\t\tthis.listeners.push(listener);\n\n\t\treturn () => {\n\t\t\tthis._removeListener(listener);\n\t\t};\n\t}\n\n\tprivate emit(e: any): void {\n\t\tthis.listeners.forEach((listener) => {\n\t\t\tlistener(e);\n\t\t});\n\t}\n\n\tprivate _removeListener(listener: ErrorListenerCallback): void {\n\t\tthis.listeners.splice(this.listeners.indexOf(listener), 1);\n\t}\n\n\tsetUnexpectedErrorHandler(newUnexpectedErrorHandler: (e: any) => void): void {\n\t\tthis.unexpectedErrorHandler = newUnexpectedErrorHandler;\n\t}\n\n\tgetUnexpectedErrorHandler(): (e: any) => void {\n\t\treturn this.unexpectedErrorHandler;\n\t}\n\n\tonUnexpectedError(e: any): void {\n\t\tthis.unexpectedErrorHandler(e);\n\t\tthis.emit(e);\n\t}\n\n\t// For external errors, we don't want the listeners to be called\n\tonUnexpectedExternalError(e: any): void {\n\t\tthis.unexpectedErrorHandler(e);\n\t}\n}\n\nexport const errorHandler = new ErrorHandler();\n\n/** @skipMangle */\nexport function setUnexpectedErrorHandler(newUnexpectedErrorHandler: (e: any) => void): void {\n\terrorHandler.setUnexpectedErrorHandler(newUnexpectedErrorHandler);\n}\n\n/**\n * Returns if the error is a SIGPIPE error. SIGPIPE errors should generally be\n * logged at most once, to avoid a loop.\n *\n * @see https://github.com/microsoft/vscode-remote-release/issues/6481\n */\nexport function isSigPipeError(e: unknown): e is Error {\n\tif (!e || typeof e !== 'object') {\n\t\treturn false;\n\t}\n\n\tconst cast = e as Record<string, string | undefined>;\n\treturn cast.code === 'EPIPE' && cast.syscall?.toUpperCase() === 'WRITE';\n}\n\nexport function onUnexpectedError(e: any): undefined {\n\t// ignore errors from cancelled promises\n\tif (!isCancellationError(e)) {\n\t\terrorHandler.onUnexpectedError(e);\n\t}\n\treturn undefined;\n}\n\nexport function onUnexpectedExternalError(e: any): undefined {\n\t// ignore errors from cancelled promises\n\tif (!isCancellationError(e)) {\n\t\terrorHandler.onUnexpectedExternalError(e);\n\t}\n\treturn undefined;\n}\n\nexport interface SerializedError {\n\treadonly $isError: true;\n\treadonly name: string;\n\treadonly message: string;\n\treadonly stack: string;\n\treadonly noTelemetry: boolean;\n}\n\nexport function transformErrorForSerialization(error: Error): SerializedError;\nexport function transformErrorForSerialization(error: any): any;\nexport function transformErrorForSerialization(error: any): any {\n\tif (error instanceof Error) {\n\t\tconst { name, message } = error;\n\t\tconst stack: string = (<any>error).stacktrace || (<any>error).stack;\n\t\treturn {\n\t\t\t$isError: true,\n\t\t\tname,\n\t\t\tmessage,\n\t\t\tstack,\n\t\t\tnoTelemetry: ErrorNoTelemetry.isErrorNoTelemetry(error)\n\t\t};\n\t}\n\n\t// return as is\n\treturn error;\n}\n\nexport function transformErrorFromSerialization(data: SerializedError): Error {\n\tlet error: Error;\n\tif (data.noTelemetry) {\n\t\terror = new ErrorNoTelemetry();\n\t} else {\n\t\terror = new Error();\n\t\terror.name = data.name;\n\t}\n\terror.message = data.message;\n\terror.stack = data.stack;\n\treturn error;\n}\n\n// see https://github.com/v8/v8/wiki/Stack%20Trace%20API#basic-stack-traces\nexport interface V8CallSite {\n\tgetThis(): unknown;\n\tgetTypeName(): string | null;\n\tgetFunction(): Function | undefined;\n\tgetFunctionName(): string | null;\n\tgetMethodName(): string | null;\n\tgetFileName(): string | null;\n\tgetLineNumber(): number | null;\n\tgetColumnNumber(): number | null;\n\tgetEvalOrigin(): string | undefined;\n\tisToplevel(): boolean;\n\tisEval(): boolean;\n\tisNative(): boolean;\n\tisConstructor(): boolean;\n\ttoString(): string;\n}\n\nconst canceledName = 'Canceled';\n\n/**\n * Checks if the given error is a promise in canceled state\n */\nexport function isCancellationError(error: any): boolean {\n\tif (error instanceof CancellationError) {\n\t\treturn true;\n\t}\n\treturn error instanceof Error && error.name === canceledName && error.message === canceledName;\n}\n\n// !!!IMPORTANT!!!\n// Do NOT change this class because it is also used as an API-type.\nexport class CancellationError extends Error {\n\tconstructor() {\n\t\tsuper(canceledName);\n\t\tthis.name = this.message;\n\t}\n}\n\n/**\n * @deprecated use {@link CancellationError `new CancellationError()`} instead\n */\nexport function canceled(): Error {\n\tconst error = new Error(canceledName);\n\terror.name = error.message;\n\treturn error;\n}\n\nexport function illegalArgument(name?: string): Error {\n\tif (name) {\n\t\treturn new Error(`Illegal argument: ${name}`);\n\t} else {\n\t\treturn new Error('Illegal argument');\n\t}\n}\n\nexport function illegalState(name?: string): Error {\n\tif (name) {\n\t\treturn new Error(`Illegal state: ${name}`);\n\t} else {\n\t\treturn new Error('Illegal state');\n\t}\n}\n\nexport class ReadonlyError extends TypeError {\n\tconstructor(name?: string) {\n\t\tsuper(name ? `${name} is read-only and cannot be changed` : 'Cannot change read-only property');\n\t}\n}\n\nexport function getErrorMessage(err: any): string {\n\tif (!err) {\n\t\treturn 'Error';\n\t}\n\n\tif (err.message) {\n\t\treturn err.message;\n\t}\n\n\tif (err.stack) {\n\t\treturn err.stack.split('\\n')[0];\n\t}\n\n\treturn String(err);\n}\n\nexport class NotImplementedError extends Error {\n\tconstructor(message?: string) {\n\t\tsuper('NotImplemented');\n\t\tif (message) {\n\t\t\tthis.message = message;\n\t\t}\n\t}\n}\n\nexport class NotSupportedError extends Error {\n\tconstructor(message?: string) {\n\t\tsuper('NotSupported');\n\t\tif (message) {\n\t\t\tthis.message = message;\n\t\t}\n\t}\n}\n\nexport class ExpectedError extends Error {\n\treadonly isExpected = true;\n}\n\n/**\n * Error that when thrown won't be logged in telemetry as an unhandled error.\n */\nexport class ErrorNoTelemetry extends Error {\n\toverride readonly name: string;\n\n\tconstructor(msg?: string) {\n\t\tsuper(msg);\n\t\tthis.name = 'CodeExpectedError';\n\t}\n\n\tpublic static fromError(err: Error): ErrorNoTelemetry {\n\t\tif (err instanceof ErrorNoTelemetry) {\n\t\t\treturn err;\n\t\t}\n\n\t\tconst result = new ErrorNoTelemetry();\n\t\tresult.message = err.message;\n\t\tresult.stack = err.stack;\n\t\treturn result;\n\t}\n\n\tpublic static isErrorNoTelemetry(err: Error): err is ErrorNoTelemetry {\n\t\treturn err.name === 'CodeExpectedError';\n\t}\n}\n\n/**\n * This error indicates a bug.\n * Do not throw this for invalid user input.\n * Only catch this error to recover gracefully from bugs.\n */\nexport class BugIndicatingError extends Error {\n\tconstructor(message?: string) {\n\t\tsuper(message || 'An unexpected bug occurred.');\n\t\tObject.setPrototypeOf(this, BugIndicatingError.prototype);\n\n\t\t// Because we know for sure only buggy code throws this,\n\t\t// we definitely want to break here and fix the bug.\n\t\t// eslint-disable-next-line no-debugger\n\t\t// debugger;\n\t}\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Comparator } from './arrays';\n\nexport function findLast<T>(array: readonly T[], predicate: (item: T) => boolean): T | undefined {\n\tconst idx = findLastIdx(array, predicate);\n\tif (idx === -1) {\n\t\treturn undefined;\n\t}\n\treturn array[idx];\n}\n\nexport function findLastIdx<T>(array: readonly T[], predicate: (item: T) => boolean, fromIndex = array.length - 1): number {\n\tfor (let i = fromIndex; i >= 0; i--) {\n\t\tconst element = array[i];\n\n\t\tif (predicate(element)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/**\n * Finds the last item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n *\n * @returns `undefined` if no item matches, otherwise the last item that matches the predicate.\n */\nexport function findLastMonotonous<T>(array: readonly T[], predicate: (item: T) => boolean): T | undefined {\n\tconst idx = findLastIdxMonotonous(array, predicate);\n\treturn idx === -1 ? undefined : array[idx];\n}\n\n/**\n * Finds the last item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n *\n * @returns `startIdx - 1` if predicate is false for all items, otherwise the index of the last item that matches the predicate.\n */\nexport function findLastIdxMonotonous<T>(array: readonly T[], predicate: (item: T) => boolean, startIdx = 0, endIdxEx = array.length): number {\n\tlet i = startIdx;\n\tlet j = endIdxEx;\n\twhile (i < j) {\n\t\tconst k = Math.floor((i + j) / 2);\n\t\tif (predicate(array[k])) {\n\t\t\ti = k + 1;\n\t\t} else {\n\t\t\tj = k;\n\t\t}\n\t}\n\treturn i - 1;\n}\n\n/**\n * Finds the first item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[false, ..., false, true, ..., true]`!\n *\n * @returns `undefined` if no item matches, otherwise the first item that matches the predicate.\n */\nexport function findFirstMonotonous<T>(array: readonly T[], predicate: (item: T) => boolean): T | undefined {\n\tconst idx = findFirstIdxMonotonousOrArrLen(array, predicate);\n\treturn idx === array.length ? undefined : array[idx];\n}\n\n/**\n * Finds the first item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[false, ..., false, true, ..., true]`!\n *\n * @returns `endIdxEx` if predicate is false for all items, otherwise the index of the first item that matches the predicate.\n */\nexport function findFirstIdxMonotonousOrArrLen<T>(array: readonly T[], predicate: (item: T) => boolean, startIdx = 0, endIdxEx = array.length): number {\n\tlet i = startIdx;\n\tlet j = endIdxEx;\n\twhile (i < j) {\n\t\tconst k = Math.floor((i + j) / 2);\n\t\tif (predicate(array[k])) {\n\t\t\tj = k;\n\t\t} else {\n\t\t\ti = k + 1;\n\t\t}\n\t}\n\treturn i;\n}\n\nexport function findFirstIdxMonotonous<T>(array: readonly T[], predicate: (item: T) => boolean, startIdx = 0, endIdxEx = array.length): number {\n\tconst idx = findFirstIdxMonotonousOrArrLen(array, predicate, startIdx, endIdxEx);\n\treturn idx === array.length ? -1 : idx;\n}\n\n/**\n * Use this when\n * * You have a sorted array\n * * You query this array with a monotonous predicate to find the last item that has a certain property.\n * * You query this array multiple times with monotonous predicates that get weaker and weaker.\n */\nexport class MonotonousArray<T> {\n\tpublic static assertInvariants = false;\n\n\tprivate _findLastMonotonousLastIdx = 0;\n\tprivate _prevFindLastPredicate: ((item: T) => boolean) | undefined;\n\n\tconstructor(private readonly _array: readonly T[]) {\n\t}\n\n\t/**\n\t * The predicate must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n\t * For subsequent calls, current predicate must be weaker than (or equal to) the previous predicate, i.e. more entries must be `true`.\n\t */\n\tfindLastMonotonous(predicate: (item: T) => boolean): T | undefined {\n\t\tif (MonotonousArray.assertInvariants) {\n\t\t\tif (this._prevFindLastPredicate) {\n\t\t\t\tfor (const item of this._array) {\n\t\t\t\t\tif (this._prevFindLastPredicate(item) && !predicate(item)) {\n\t\t\t\t\t\tthrow new Error('MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._prevFindLastPredicate = predicate;\n\t\t}\n\n\t\tconst idx = findLastIdxMonotonous(this._array, predicate, this._findLastMonotonousLastIdx);\n\t\tthis._findLastMonotonousLastIdx = idx + 1;\n\t\treturn idx === -1 ? undefined : this._array[idx];\n\t}\n}\n\n/**\n * Returns the first item that is equal to or greater than every other item.\n*/\nexport function findFirstMax<T>(array: readonly T[], comparator: Comparator<T>): T | undefined {\n\tif (array.length === 0) {\n\t\treturn undefined;\n\t}\n\n\tlet max = array[0];\n\tfor (let i = 1; i < array.length; i++) {\n\t\tconst item = array[i];\n\t\tif (comparator(item, max) > 0) {\n\t\t\tmax = item;\n\t\t}\n\t}\n\treturn max;\n}\n\n/**\n * Returns the last item that is equal to or greater than every other item.\n*/\nexport function findLastMax<T>(array: readonly T[], comparator: Comparator<T>): T | undefined {\n\tif (array.length === 0) {\n\t\treturn undefined;\n\t}\n\n\tlet max = array[0];\n\tfor (let i = 1; i < array.length; i++) {\n\t\tconst item = array[i];\n\t\tif (comparator(item, max) >= 0) {\n\t\t\tmax = item;\n\t\t}\n\t}\n\treturn max;\n}\n\n/**\n * Returns the first item that is equal to or less than every other item.\n*/\nexport function findFirstMin<T>(array: readonly T[], comparator: Comparator<T>): T | undefined {\n\treturn findFirstMax(array, (a, b) => -comparator(a, b));\n}\n\nexport function findMaxIdx<T>(array: readonly T[], comparator: Comparator<T>): number {\n\tif (array.length === 0) {\n\t\treturn -1;\n\t}\n\n\tlet maxIdx = 0;\n\tfor (let i = 1; i < array.length; i++) {\n\t\tconst item = array[i];\n\t\tif (comparator(item, array[maxIdx]) > 0) {\n\t\t\tmaxIdx = i;\n\t\t}\n\t}\n\treturn maxIdx;\n}\n\n/**\n * Returns the first mapped value of the array which is not undefined.\n */\nexport function mapFindFirst<T, R>(items: Iterable<T>, mapFn: (value: T) => R | undefined): R | undefined {\n\tfor (const value of items) {\n\t\tconst mapped = mapFn(value);\n\t\tif (mapped !== undefined) {\n\t\t\treturn mapped;\n\t\t}\n\t}\n\n\treturn undefined;\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { CancellationError } from 'vs/base/common/errors';\nimport { ISplice } from 'vs/base/common/sequence';\nimport { findFirstIdxMonotonousOrArrLen } from './arraysFind';\n\n/**\n * Returns the last element of an array.\n * @param array The array.\n * @param n Which element from the end (default is zero).\n */\nexport function tail<T>(array: ArrayLike<T>, n: number = 0): T | undefined {\n\treturn array[array.length - (1 + n)];\n}\n\nexport function tail2<T>(arr: T[]): [T[], T] {\n\tif (arr.length === 0) {\n\t\tthrow new Error('Invalid tail call');\n\t}\n\n\treturn [arr.slice(0, arr.length - 1), arr[arr.length - 1]];\n}\n\nexport function equals<T>(one: ReadonlyArray<T> | undefined, other: ReadonlyArray<T> | undefined, itemEquals: (a: T, b: T) => boolean = (a, b) => a === b): boolean {\n\tif (one === other) {\n\t\treturn true;\n\t}\n\n\tif (!one || !other) {\n\t\treturn false;\n\t}\n\n\tif (one.length !== other.length) {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0, len = one.length; i < len; i++) {\n\t\tif (!itemEquals(one[i], other[i])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * Remove the element at `index` by replacing it with the last element. This is faster than `splice`\n * but changes the order of the array\n */\nexport function removeFastWithoutKeepingOrder<T>(array: T[], index: number) {\n\tconst last = array.length - 1;\n\tif (index < last) {\n\t\tarray[index] = array[last];\n\t}\n\tarray.pop();\n}\n\n/**\n * Performs a binary search algorithm over a sorted array.\n *\n * @param array The array being searched.\n * @param key The value we search for.\n * @param comparator A function that takes two array elements and returns zero\n *   if they are equal, a negative number if the first element precedes the\n *   second one in the sorting order, or a positive number if the second element\n *   precedes the first one.\n * @return See {@link binarySearch2}\n */\nexport function binarySearch<T>(array: ReadonlyArray<T>, key: T, comparator: (op1: T, op2: T) => number): number {\n\treturn binarySearch2(array.length, i => comparator(array[i], key));\n}\n\n/**\n * Performs a binary search algorithm over a sorted collection. Useful for cases\n * when we need to perform a binary search over something that isn't actually an\n * array, and converting data to an array would defeat the use of binary search\n * in the first place.\n *\n * @param length The collection length.\n * @param compareToKey A function that takes an index of an element in the\n *   collection and returns zero if the value at this index is equal to the\n *   search key, a negative number if the value precedes the search key in the\n *   sorting order, or a positive number if the search key precedes the value.\n * @return A non-negative index of an element, if found. If not found, the\n *   result is -(n+1) (or ~n, using bitwise notation), where n is the index\n *   where the key should be inserted to maintain the sorting order.\n */\nexport function binarySearch2(length: number, compareToKey: (index: number) => number): number {\n\tlet low = 0,\n\t\thigh = length - 1;\n\n\twhile (low <= high) {\n\t\tconst mid = ((low + high) / 2) | 0;\n\t\tconst comp = compareToKey(mid);\n\t\tif (comp < 0) {\n\t\t\tlow = mid + 1;\n\t\t} else if (comp > 0) {\n\t\t\thigh = mid - 1;\n\t\t} else {\n\t\t\treturn mid;\n\t\t}\n\t}\n\treturn -(low + 1);\n}\n\ntype Compare<T> = (a: T, b: T) => number;\n\n\nexport function quickSelect<T>(nth: number, data: T[], compare: Compare<T>): T {\n\n\tnth = nth | 0;\n\n\tif (nth >= data.length) {\n\t\tthrow new TypeError('invalid index');\n\t}\n\n\tconst pivotValue = data[Math.floor(data.length * Math.random())];\n\tconst lower: T[] = [];\n\tconst higher: T[] = [];\n\tconst pivots: T[] = [];\n\n\tfor (const value of data) {\n\t\tconst val = compare(value, pivotValue);\n\t\tif (val < 0) {\n\t\t\tlower.push(value);\n\t\t} else if (val > 0) {\n\t\t\thigher.push(value);\n\t\t} else {\n\t\t\tpivots.push(value);\n\t\t}\n\t}\n\n\tif (nth < lower.length) {\n\t\treturn quickSelect(nth, lower, compare);\n\t} else if (nth < lower.length + pivots.length) {\n\t\treturn pivots[0];\n\t} else {\n\t\treturn quickSelect(nth - (lower.length + pivots.length), higher, compare);\n\t}\n}\n\nexport function groupBy<T>(data: ReadonlyArray<T>, compare: (a: T, b: T) => number): T[][] {\n\tconst result: T[][] = [];\n\tlet currentGroup: T[] | undefined = undefined;\n\tfor (const element of data.slice(0).sort(compare)) {\n\t\tif (!currentGroup || compare(currentGroup[0], element) !== 0) {\n\t\t\tcurrentGroup = [element];\n\t\t\tresult.push(currentGroup);\n\t\t} else {\n\t\t\tcurrentGroup.push(element);\n\t\t}\n\t}\n\treturn result;\n}\n\n/**\n * Splits the given items into a list of (non-empty) groups.\n * `shouldBeGrouped` is used to decide if two consecutive items should be in the same group.\n * The order of the items is preserved.\n */\nexport function* groupAdjacentBy<T>(items: Iterable<T>, shouldBeGrouped: (item1: T, item2: T) => boolean): Iterable<T[]> {\n\tlet currentGroup: T[] | undefined;\n\tlet last: T | undefined;\n\tfor (const item of items) {\n\t\tif (last !== undefined && shouldBeGrouped(last, item)) {\n\t\t\tcurrentGroup!.push(item);\n\t\t} else {\n\t\t\tif (currentGroup) {\n\t\t\t\tyield currentGroup;\n\t\t\t}\n\t\t\tcurrentGroup = [item];\n\t\t}\n\t\tlast = item;\n\t}\n\tif (currentGroup) {\n\t\tyield currentGroup;\n\t}\n}\n\nexport function forEachAdjacent<T>(arr: T[], f: (item1: T | undefined, item2: T | undefined) => void): void {\n\tfor (let i = 0; i <= arr.length; i++) {\n\t\tf(i === 0 ? undefined : arr[i - 1], i === arr.length ? undefined : arr[i]);\n\t}\n}\n\nexport function forEachWithNeighbors<T>(arr: T[], f: (before: T | undefined, element: T, after: T | undefined) => void): void {\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tf(i === 0 ? undefined : arr[i - 1], arr[i], i + 1 === arr.length ? undefined : arr[i + 1]);\n\t}\n}\n\ninterface IMutableSplice<T> extends ISplice<T> {\n\treadonly toInsert: T[];\n\tdeleteCount: number;\n}\n\n/**\n * Diffs two *sorted* arrays and computes the splices which apply the diff.\n */\nexport function sortedDiff<T>(before: ReadonlyArray<T>, after: ReadonlyArray<T>, compare: (a: T, b: T) => number): ISplice<T>[] {\n\tconst result: IMutableSplice<T>[] = [];\n\n\tfunction pushSplice(start: number, deleteCount: number, toInsert: T[]): void {\n\t\tif (deleteCount === 0 && toInsert.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst latest = result[result.length - 1];\n\n\t\tif (latest && latest.start + latest.deleteCount === start) {\n\t\t\tlatest.deleteCount += deleteCount;\n\t\t\tlatest.toInsert.push(...toInsert);\n\t\t} else {\n\t\t\tresult.push({ start, deleteCount, toInsert });\n\t\t}\n\t}\n\n\tlet beforeIdx = 0;\n\tlet afterIdx = 0;\n\n\twhile (true) {\n\t\tif (beforeIdx === before.length) {\n\t\t\tpushSplice(beforeIdx, 0, after.slice(afterIdx));\n\t\t\tbreak;\n\t\t}\n\t\tif (afterIdx === after.length) {\n\t\t\tpushSplice(beforeIdx, before.length - beforeIdx, []);\n\t\t\tbreak;\n\t\t}\n\n\t\tconst beforeElement = before[beforeIdx];\n\t\tconst afterElement = after[afterIdx];\n\t\tconst n = compare(beforeElement, afterElement);\n\t\tif (n === 0) {\n\t\t\t// equal\n\t\t\tbeforeIdx += 1;\n\t\t\tafterIdx += 1;\n\t\t} else if (n < 0) {\n\t\t\t// beforeElement is smaller -> before element removed\n\t\t\tpushSplice(beforeIdx, 1, []);\n\t\t\tbeforeIdx += 1;\n\t\t} else if (n > 0) {\n\t\t\t// beforeElement is greater -> after element added\n\t\t\tpushSplice(beforeIdx, 0, [afterElement]);\n\t\t\tafterIdx += 1;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Takes two *sorted* arrays and computes their delta (removed, added elements).\n * Finishes in `Math.min(before.length, after.length)` steps.\n */\nexport function delta<T>(before: ReadonlyArray<T>, after: ReadonlyArray<T>, compare: (a: T, b: T) => number): { removed: T[]; added: T[] } {\n\tconst splices = sortedDiff(before, after, compare);\n\tconst removed: T[] = [];\n\tconst added: T[] = [];\n\n\tfor (const splice of splices) {\n\t\tremoved.push(...before.slice(splice.start, splice.start + splice.deleteCount));\n\t\tadded.push(...splice.toInsert);\n\t}\n\n\treturn { removed, added };\n}\n\n/**\n * Returns the top N elements from the array.\n *\n * Faster than sorting the entire array when the array is a lot larger than N.\n *\n * @param array The unsorted array.\n * @param compare A sort function for the elements.\n * @param n The number of elements to return.\n * @return The first n elements from array when sorted with compare.\n */\nexport function top<T>(array: ReadonlyArray<T>, compare: (a: T, b: T) => number, n: number): T[] {\n\tif (n === 0) {\n\t\treturn [];\n\t}\n\tconst result = array.slice(0, n).sort(compare);\n\ttopStep(array, compare, result, n, array.length);\n\treturn result;\n}\n\n/**\n * Asynchronous variant of `top()` allowing for splitting up work in batches between which the event loop can run.\n *\n * Returns the top N elements from the array.\n *\n * Faster than sorting the entire array when the array is a lot larger than N.\n *\n * @param array The unsorted array.\n * @param compare A sort function for the elements.\n * @param n The number of elements to return.\n * @param batch The number of elements to examine before yielding to the event loop.\n * @return The first n elements from array when sorted with compare.\n */\nexport function topAsync<T>(array: T[], compare: (a: T, b: T) => number, n: number, batch: number, token?: CancellationToken): Promise<T[]> {\n\tif (n === 0) {\n\t\treturn Promise.resolve([]);\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\t(async () => {\n\t\t\tconst o = array.length;\n\t\t\tconst result = array.slice(0, n).sort(compare);\n\t\t\tfor (let i = n, m = Math.min(n + batch, o); i < o; i = m, m = Math.min(m + batch, o)) {\n\t\t\t\tif (i > n) {\n\t\t\t\t\tawait new Promise(resolve => setTimeout(resolve)); // any other delay function would starve I/O\n\t\t\t\t}\n\t\t\t\tif (token && token.isCancellationRequested) {\n\t\t\t\t\tthrow new CancellationError();\n\t\t\t\t}\n\t\t\t\ttopStep(array, compare, result, i, m);\n\t\t\t}\n\t\t\treturn result;\n\t\t})()\n\t\t\t.then(resolve, reject);\n\t});\n}\n\nfunction topStep<T>(array: ReadonlyArray<T>, compare: (a: T, b: T) => number, result: T[], i: number, m: number): void {\n\tfor (const n = result.length; i < m; i++) {\n\t\tconst element = array[i];\n\t\tif (compare(element, result[n - 1]) < 0) {\n\t\t\tresult.pop();\n\t\t\tconst j = findFirstIdxMonotonousOrArrLen(result, e => compare(element, e) < 0);\n\t\t\tresult.splice(j, 0, element);\n\t\t}\n\t}\n}\n\n/**\n * @returns New array with all falsy values removed. The original array IS NOT modified.\n */\nexport function coalesce<T>(array: ReadonlyArray<T | undefined | null>): T[] {\n\treturn array.filter((e): e is T => !!e);\n}\n\n/**\n * Remove all falsy values from `array`. The original array IS modified.\n */\nexport function coalesceInPlace<T>(array: Array<T | undefined | null>): asserts array is Array<T> {\n\tlet to = 0;\n\tfor (let i = 0; i < array.length; i++) {\n\t\tif (!!array[i]) {\n\t\t\tarray[to] = array[i];\n\t\t\tto += 1;\n\t\t}\n\t}\n\tarray.length = to;\n}\n\n/**\n * @deprecated Use `Array.copyWithin` instead\n */\nexport function move(array: any[], from: number, to: number): void {\n\tarray.splice(to, 0, array.splice(from, 1)[0]);\n}\n\n/**\n * @returns false if the provided object is an array and not empty.\n */\nexport function isFalsyOrEmpty(obj: any): boolean {\n\treturn !Array.isArray(obj) || obj.length === 0;\n}\n\n/**\n * @returns True if the provided object is an array and has at least one element.\n */\nexport function isNonEmptyArray<T>(obj: T[] | undefined | null): obj is T[];\nexport function isNonEmptyArray<T>(obj: readonly T[] | undefined | null): obj is readonly T[];\nexport function isNonEmptyArray<T>(obj: T[] | readonly T[] | undefined | null): obj is T[] | readonly T[] {\n\treturn Array.isArray(obj) && obj.length > 0;\n}\n\n/**\n * Removes duplicates from the given array. The optional keyFn allows to specify\n * how elements are checked for equality by returning an alternate value for each.\n */\nexport function distinct<T>(array: ReadonlyArray<T>, keyFn: (value: T) => any = value => value): T[] {\n\tconst seen = new Set<any>();\n\n\treturn array.filter(element => {\n\t\tconst key = keyFn!(element);\n\t\tif (seen.has(key)) {\n\t\t\treturn false;\n\t\t}\n\t\tseen.add(key);\n\t\treturn true;\n\t});\n}\n\nexport function uniqueFilter<T, R>(keyFn: (t: T) => R): (t: T) => boolean {\n\tconst seen = new Set<R>();\n\n\treturn element => {\n\t\tconst key = keyFn(element);\n\n\t\tif (seen.has(key)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tseen.add(key);\n\t\treturn true;\n\t};\n}\n\nexport function firstOrDefault<T, NotFound = T>(array: ReadonlyArray<T>, notFoundValue: NotFound): T | NotFound;\nexport function firstOrDefault<T>(array: ReadonlyArray<T>): T | undefined;\nexport function firstOrDefault<T, NotFound = T>(array: ReadonlyArray<T>, notFoundValue?: NotFound): T | NotFound | undefined {\n\treturn array.length > 0 ? array[0] : notFoundValue;\n}\n\nexport function lastOrDefault<T, NotFound = T>(array: ReadonlyArray<T>, notFoundValue: NotFound): T | NotFound;\nexport function lastOrDefault<T>(array: ReadonlyArray<T>): T | undefined;\nexport function lastOrDefault<T, NotFound = T>(array: ReadonlyArray<T>, notFoundValue?: NotFound): T | NotFound | undefined {\n\treturn array.length > 0 ? array[array.length - 1] : notFoundValue;\n}\n\nexport function commonPrefixLength<T>(one: ReadonlyArray<T>, other: ReadonlyArray<T>, equals: (a: T, b: T) => boolean = (a, b) => a === b): number {\n\tlet result = 0;\n\n\tfor (let i = 0, len = Math.min(one.length, other.length); i < len && equals(one[i], other[i]); i++) {\n\t\tresult++;\n\t}\n\n\treturn result;\n}\n\nexport function range(to: number): number[];\nexport function range(from: number, to: number): number[];\nexport function range(arg: number, to?: number): number[] {\n\tlet from = typeof to === 'number' ? arg : 0;\n\n\tif (typeof to === 'number') {\n\t\tfrom = arg;\n\t} else {\n\t\tfrom = 0;\n\t\tto = arg;\n\t}\n\n\tconst result: number[] = [];\n\n\tif (from <= to) {\n\t\tfor (let i = from; i < to; i++) {\n\t\t\tresult.push(i);\n\t\t}\n\t} else {\n\t\tfor (let i = from; i > to; i--) {\n\t\t\tresult.push(i);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function index<T>(array: ReadonlyArray<T>, indexer: (t: T) => string): { [key: string]: T };\nexport function index<T, R>(array: ReadonlyArray<T>, indexer: (t: T) => string, mapper: (t: T) => R): { [key: string]: R };\nexport function index<T, R>(array: ReadonlyArray<T>, indexer: (t: T) => string, mapper?: (t: T) => R): { [key: string]: R } {\n\treturn array.reduce((r, t) => {\n\t\tr[indexer(t)] = mapper ? mapper(t) : t;\n\t\treturn r;\n\t}, Object.create(null));\n}\n\n/**\n * Inserts an element into an array. Returns a function which, when\n * called, will remove that element from the array.\n *\n * @deprecated In almost all cases, use a `Set<T>` instead.\n */\nexport function insert<T>(array: T[], element: T): () => void {\n\tarray.push(element);\n\n\treturn () => remove(array, element);\n}\n\n/**\n * Removes an element from an array if it can be found.\n *\n * @deprecated In almost all cases, use a `Set<T>` instead.\n */\nexport function remove<T>(array: T[], element: T): T | undefined {\n\tconst index = array.indexOf(element);\n\tif (index > -1) {\n\t\tarray.splice(index, 1);\n\n\t\treturn element;\n\t}\n\n\treturn undefined;\n}\n\n/**\n * Insert `insertArr` inside `target` at `insertIndex`.\n * Please don't touch unless you understand https://jsperf.com/inserting-an-array-within-an-array\n */\nexport function arrayInsert<T>(target: T[], insertIndex: number, insertArr: T[]): T[] {\n\tconst before = target.slice(0, insertIndex);\n\tconst after = target.slice(insertIndex);\n\treturn before.concat(insertArr, after);\n}\n\n/**\n * Uses Fisher-Yates shuffle to shuffle the given array\n */\nexport function shuffle<T>(array: T[], _seed?: number): void {\n\tlet rand: () => number;\n\n\tif (typeof _seed === 'number') {\n\t\tlet seed = _seed;\n\t\t// Seeded random number generator in JS. Modified from:\n\t\t// https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript\n\t\trand = () => {\n\t\t\tconst x = Math.sin(seed++) * 179426549; // throw away most significant digits and reduce any potential bias\n\t\t\treturn x - Math.floor(x);\n\t\t};\n\t} else {\n\t\trand = Math.random;\n\t}\n\n\tfor (let i = array.length - 1; i > 0; i -= 1) {\n\t\tconst j = Math.floor(rand() * (i + 1));\n\t\tconst temp = array[i];\n\t\tarray[i] = array[j];\n\t\tarray[j] = temp;\n\t}\n}\n\n/**\n * Pushes an element to the start of the array, if found.\n */\nexport function pushToStart<T>(arr: T[], value: T): void {\n\tconst index = arr.indexOf(value);\n\n\tif (index > -1) {\n\t\tarr.splice(index, 1);\n\t\tarr.unshift(value);\n\t}\n}\n\n/**\n * Pushes an element to the end of the array, if found.\n */\nexport function pushToEnd<T>(arr: T[], value: T): void {\n\tconst index = arr.indexOf(value);\n\n\tif (index > -1) {\n\t\tarr.splice(index, 1);\n\t\tarr.push(value);\n\t}\n}\n\nexport function pushMany<T>(arr: T[], items: ReadonlyArray<T>): void {\n\tfor (const item of items) {\n\t\tarr.push(item);\n\t}\n}\n\nexport function mapArrayOrNot<T, U>(items: T | T[], fn: (_: T) => U): U | U[] {\n\treturn Array.isArray(items) ?\n\t\titems.map(fn) :\n\t\tfn(items);\n}\n\nexport function asArray<T>(x: T | T[]): T[];\nexport function asArray<T>(x: T | readonly T[]): readonly T[];\nexport function asArray<T>(x: T | T[]): T[] {\n\treturn Array.isArray(x) ? x : [x];\n}\n\nexport function getRandomElement<T>(arr: T[]): T | undefined {\n\treturn arr[Math.floor(Math.random() * arr.length)];\n}\n\n/**\n * Insert the new items in the array.\n * @param array The original array.\n * @param start The zero-based location in the array from which to start inserting elements.\n * @param newItems The items to be inserted\n */\nexport function insertInto<T>(array: T[], start: number, newItems: T[]): void {\n\tconst startIdx = getActualStartIndex(array, start);\n\tconst originalLength = array.length;\n\tconst newItemsLength = newItems.length;\n\tarray.length = originalLength + newItemsLength;\n\t// Move the items after the start index, start from the end so that we don't overwrite any value.\n\tfor (let i = originalLength - 1; i >= startIdx; i--) {\n\t\tarray[i + newItemsLength] = array[i];\n\t}\n\n\tfor (let i = 0; i < newItemsLength; i++) {\n\t\tarray[i + startIdx] = newItems[i];\n\t}\n}\n\n/**\n * Removes elements from an array and inserts new elements in their place, returning the deleted elements. Alternative to the native Array.splice method, it\n * can only support limited number of items due to the maximum call stack size limit.\n * @param array The original array.\n * @param start The zero-based location in the array from which to start removing elements.\n * @param deleteCount The number of elements to remove.\n * @returns An array containing the elements that were deleted.\n */\nexport function splice<T>(array: T[], start: number, deleteCount: number, newItems: T[]): T[] {\n\tconst index = getActualStartIndex(array, start);\n\tlet result = array.splice(index, deleteCount);\n\tif (result === undefined) {\n\t\t// see https://bugs.webkit.org/show_bug.cgi?id=261140\n\t\tresult = [];\n\t}\n\tinsertInto(array, index, newItems);\n\treturn result;\n}\n\n/**\n * Determine the actual start index (same logic as the native splice() or slice())\n * If greater than the length of the array, start will be set to the length of the array. In this case, no element will be deleted but the method will behave as an adding function, adding as many element as item[n*] provided.\n * If negative, it will begin that many elements from the end of the array. (In this case, the origin -1, meaning -n is the index of the nth last element, and is therefore equivalent to the index of array.length - n.) If array.length + start is less than 0, it will begin from index 0.\n * @param array The target array.\n * @param start The operation index.\n */\nfunction getActualStartIndex<T>(array: T[], start: number): number {\n\treturn start < 0 ? Math.max(start + array.length, 0) : Math.min(start, array.length);\n}\n\n/**\n * When comparing two values,\n * a negative number indicates that the first value is less than the second,\n * a positive number indicates that the first value is greater than the second,\n * and zero indicates that neither is the case.\n*/\nexport type CompareResult = number;\n\nexport namespace CompareResult {\n\texport function isLessThan(result: CompareResult): boolean {\n\t\treturn result < 0;\n\t}\n\n\texport function isLessThanOrEqual(result: CompareResult): boolean {\n\t\treturn result <= 0;\n\t}\n\n\texport function isGreaterThan(result: CompareResult): boolean {\n\t\treturn result > 0;\n\t}\n\n\texport function isNeitherLessOrGreaterThan(result: CompareResult): boolean {\n\t\treturn result === 0;\n\t}\n\n\texport const greaterThan = 1;\n\texport const lessThan = -1;\n\texport const neitherLessOrGreaterThan = 0;\n}\n\n/**\n * A comparator `c` defines a total order `<=` on `T` as following:\n * `c(a, b) <= 0` iff `a` <= `b`.\n * We also have `c(a, b) == 0` iff `c(b, a) == 0`.\n*/\nexport type Comparator<T> = (a: T, b: T) => CompareResult;\n\nexport function compareBy<TItem, TCompareBy>(selector: (item: TItem) => TCompareBy, comparator: Comparator<TCompareBy>): Comparator<TItem> {\n\treturn (a, b) => comparator(selector(a), selector(b));\n}\n\nexport function tieBreakComparators<TItem>(...comparators: Comparator<TItem>[]): Comparator<TItem> {\n\treturn (item1, item2) => {\n\t\tfor (const comparator of comparators) {\n\t\t\tconst result = comparator(item1, item2);\n\t\t\tif (!CompareResult.isNeitherLessOrGreaterThan(result)) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn CompareResult.neitherLessOrGreaterThan;\n\t};\n}\n\n/**\n * The natural order on numbers.\n*/\nexport const numberComparator: Comparator<number> = (a, b) => a - b;\n\nexport const booleanComparator: Comparator<boolean> = (a, b) => numberComparator(a ? 1 : 0, b ? 1 : 0);\n\nexport function reverseOrder<TItem>(comparator: Comparator<TItem>): Comparator<TItem> {\n\treturn (a, b) => -comparator(a, b);\n}\n\nexport class ArrayQueue<T> {\n\tprivate firstIdx = 0;\n\tprivate lastIdx = this.items.length - 1;\n\n\t/**\n\t * Constructs a queue that is backed by the given array. Runtime is O(1).\n\t*/\n\tconstructor(private readonly items: readonly T[]) { }\n\n\tget length(): number {\n\t\treturn this.lastIdx - this.firstIdx + 1;\n\t}\n\n\t/**\n\t * Consumes elements from the beginning of the queue as long as the predicate returns true.\n\t * If no elements were consumed, `null` is returned. Has a runtime of O(result.length).\n\t*/\n\ttakeWhile(predicate: (value: T) => boolean): T[] | null {\n\t\t// P(k) := k <= this.lastIdx && predicate(this.items[k])\n\t\t// Find s := min { k | k >= this.firstIdx && !P(k) } and return this.data[this.firstIdx...s)\n\n\t\tlet startIdx = this.firstIdx;\n\t\twhile (startIdx < this.items.length && predicate(this.items[startIdx])) {\n\t\t\tstartIdx++;\n\t\t}\n\t\tconst result = startIdx === this.firstIdx ? null : this.items.slice(this.firstIdx, startIdx);\n\t\tthis.firstIdx = startIdx;\n\t\treturn result;\n\t}\n\n\t/**\n\t * Consumes elements from the end of the queue as long as the predicate returns true.\n\t * If no elements were consumed, `null` is returned.\n\t * The result has the same order as the underlying array!\n\t*/\n\ttakeFromEndWhile(predicate: (value: T) => boolean): T[] | null {\n\t\t// P(k) := this.firstIdx >= k && predicate(this.items[k])\n\t\t// Find s := max { k | k <= this.lastIdx && !P(k) } and return this.data(s...this.lastIdx]\n\n\t\tlet endIdx = this.lastIdx;\n\t\twhile (endIdx >= 0 && predicate(this.items[endIdx])) {\n\t\t\tendIdx--;\n\t\t}\n\t\tconst result = endIdx === this.lastIdx ? null : this.items.slice(endIdx + 1, this.lastIdx + 1);\n\t\tthis.lastIdx = endIdx;\n\t\treturn result;\n\t}\n\n\tpeek(): T | undefined {\n\t\tif (this.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this.items[this.firstIdx];\n\t}\n\n\tpeekLast(): T | undefined {\n\t\tif (this.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this.items[this.lastIdx];\n\t}\n\n\tdequeue(): T | undefined {\n\t\tconst result = this.items[this.firstIdx];\n\t\tthis.firstIdx++;\n\t\treturn result;\n\t}\n\n\tremoveLast(): T | undefined {\n\t\tconst result = this.items[this.lastIdx];\n\t\tthis.lastIdx--;\n\t\treturn result;\n\t}\n\n\ttakeCount(count: number): T[] {\n\t\tconst result = this.items.slice(this.firstIdx, this.firstIdx + count);\n\t\tthis.firstIdx += count;\n\t\treturn result;\n\t}\n}\n\n/**\n * This class is faster than an iterator and array for lazy computed data.\n*/\nexport class CallbackIterable<T> {\n\tpublic static readonly empty = new CallbackIterable<never>(_callback => { });\n\n\tconstructor(\n\t\t/**\n\t\t * Calls the callback for every item.\n\t\t * Stops when the callback returns false.\n\t\t*/\n\t\tpublic readonly iterate: (callback: (item: T) => boolean) => void\n\t) {\n\t}\n\n\tforEach(handler: (item: T) => void) {\n\t\tthis.iterate(item => { handler(item); return true; });\n\t}\n\n\ttoArray(): T[] {\n\t\tconst result: T[] = [];\n\t\tthis.iterate(item => { result.push(item); return true; });\n\t\treturn result;\n\t}\n\n\tfilter(predicate: (item: T) => boolean): CallbackIterable<T> {\n\t\treturn new CallbackIterable(cb => this.iterate(item => predicate(item) ? cb(item) : true));\n\t}\n\n\tmap<TResult>(mapFn: (item: T) => TResult): CallbackIterable<TResult> {\n\t\treturn new CallbackIterable<TResult>(cb => this.iterate(item => cb(mapFn(item))));\n\t}\n\n\tsome(predicate: (item: T) => boolean): boolean {\n\t\tlet result = false;\n\t\tthis.iterate(item => { result = predicate(item); return !result; });\n\t\treturn result;\n\t}\n\n\tfindFirst(predicate: (item: T) => boolean): T | undefined {\n\t\tlet result: T | undefined;\n\t\tthis.iterate(item => {\n\t\t\tif (predicate(item)) {\n\t\t\t\tresult = item;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t\treturn result;\n\t}\n\n\tfindLast(predicate: (item: T) => boolean): T | undefined {\n\t\tlet result: T | undefined;\n\t\tthis.iterate(item => {\n\t\t\tif (predicate(item)) {\n\t\t\t\tresult = item;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t\treturn result;\n\t}\n\n\tfindLastMaxBy(comparator: Comparator<T>): T | undefined {\n\t\tlet result: T | undefined;\n\t\tlet first = true;\n\t\tthis.iterate(item => {\n\t\t\tif (first || CompareResult.isGreaterThan(comparator(item, result!))) {\n\t\t\t\tfirst = false;\n\t\t\t\tresult = item;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t\treturn result;\n\t}\n}\n\n/**\n * Represents a re-arrangement of items in an array.\n */\nexport class Permutation {\n\tconstructor(private readonly _indexMap: readonly number[]) { }\n\n\t/**\n\t * Returns a permutation that sorts the given array according to the given compare function.\n\t */\n\tpublic static createSortPermutation<T>(arr: readonly T[], compareFn: (a: T, b: T) => number): Permutation {\n\t\tconst sortIndices = Array.from(arr.keys()).sort((index1, index2) => compareFn(arr[index1], arr[index2]));\n\t\treturn new Permutation(sortIndices);\n\t}\n\n\t/**\n\t * Returns a new array with the elements of the given array re-arranged according to this permutation.\n\t */\n\tapply<T>(arr: readonly T[]): T[] {\n\t\treturn arr.map((_, index) => arr[this._indexMap[index]]);\n\t}\n\n\t/**\n\t * Returns a new permutation that undoes the re-arrangement of this permutation.\n\t*/\n\tinverse(): Permutation {\n\t\tconst inverseIndexMap = this._indexMap.slice();\n\t\tfor (let i = 0; i < this._indexMap.length; i++) {\n\t\t\tinverseIndexMap[this._indexMap[i]] = i;\n\t\t}\n\t\treturn new Permutation(inverseIndexMap);\n\t}\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * An interface for a JavaScript object that\n * acts a dictionary. The keys are strings.\n */\nexport type IStringDictionary<V> = Record<string, V>;\n\n/**\n * An interface for a JavaScript object that\n * acts a dictionary. The keys are numbers.\n */\nexport type INumberDictionary<V> = Record<number, V>;\n\n/**\n * Groups the collection into a dictionary based on the provided\n * group function.\n */\nexport function groupBy<K extends string | number | symbol, V>(data: V[], groupFn: (element: V) => K): Record<K, V[]> {\n\tconst result: Record<K, V[]> = Object.create(null);\n\tfor (const element of data) {\n\t\tconst key = groupFn(element);\n\t\tlet target = result[key];\n\t\tif (!target) {\n\t\t\ttarget = result[key] = [];\n\t\t}\n\t\ttarget.push(element);\n\t}\n\treturn result;\n}\n\nexport function diffSets<T>(before: Set<T>, after: Set<T>): { removed: T[]; added: T[] } {\n\tconst removed: T[] = [];\n\tconst added: T[] = [];\n\tfor (const element of before) {\n\t\tif (!after.has(element)) {\n\t\t\tremoved.push(element);\n\t\t}\n\t}\n\tfor (const element of after) {\n\t\tif (!before.has(element)) {\n\t\t\tadded.push(element);\n\t\t}\n\t}\n\treturn { removed, added };\n}\n\nexport function diffMaps<K, V>(before: Map<K, V>, after: Map<K, V>): { removed: V[]; added: V[] } {\n\tconst removed: V[] = [];\n\tconst added: V[] = [];\n\tfor (const [index, value] of before) {\n\t\tif (!after.has(index)) {\n\t\t\tremoved.push(value);\n\t\t}\n\t}\n\tfor (const [index, value] of after) {\n\t\tif (!before.has(index)) {\n\t\t\tadded.push(value);\n\t\t}\n\t}\n\treturn { removed, added };\n}\n\n/**\n * Computes the intersection of two sets.\n *\n * @param setA - The first set.\n * @param setB - The second iterable.\n * @returns A new set containing the elements that are in both `setA` and `setB`.\n */\nexport function intersection<T>(setA: Set<T>, setB: Iterable<T>): Set<T> {\n\tconst result = new Set<T>();\n\tfor (const elem of setB) {\n\t\tif (setA.has(elem)) {\n\t\t\tresult.add(elem);\n\t\t}\n\t}\n\treturn result;\n}\n\nexport class SetWithKey<T> implements Set<T> {\n\tprivate _map = new Map<any, T>();\n\n\tconstructor(values: T[], private toKey: (t: T) => any) {\n\t\tfor (const value of values) {\n\t\t\tthis.add(value);\n\t\t}\n\t}\n\n\tget size(): number {\n\t\treturn this._map.size;\n\t}\n\n\tadd(value: T): this {\n\t\tconst key = this.toKey(value);\n\t\tthis._map.set(key, value);\n\t\treturn this;\n\t}\n\n\tdelete(value: T): boolean {\n\t\treturn this._map.delete(this.toKey(value));\n\t}\n\n\thas(value: T): boolean {\n\t\treturn this._map.has(this.toKey(value));\n\t}\n\n\t*entries(): IterableIterator<[T, T]> {\n\t\tfor (const entry of this._map.values()) {\n\t\t\tyield [entry, entry];\n\t\t}\n\t}\n\n\tkeys(): IterableIterator<T> {\n\t\treturn this.values();\n\t}\n\n\t*values(): IterableIterator<T> {\n\t\tfor (const entry of this._map.values()) {\n\t\t\tyield entry;\n\t\t}\n\t}\n\n\tclear(): void {\n\t\tthis._map.clear();\n\t}\n\n\tforEach(callbackfn: (value: T, value2: T, set: Set<T>) => void, thisArg?: any): void {\n\t\tthis._map.forEach(entry => callbackfn.call(thisArg, entry, entry, this));\n\t}\n\n\t[Symbol.iterator](): IterableIterator<T> {\n\t\treturn this.values();\n\t}\n\n\t[Symbol.toStringTag]: string = 'SetWithKey';\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport function getOrSet<K, V>(map: Map<K, V>, key: K, value: V): V {\n\tlet result = map.get(key);\n\tif (result === undefined) {\n\t\tresult = value;\n\t\tmap.set(key, result);\n\t}\n\n\treturn result;\n}\n\nexport function mapToString<K, V>(map: Map<K, V>): string {\n\tconst entries: string[] = [];\n\tmap.forEach((value, key) => {\n\t\tentries.push(`${key} => ${value}`);\n\t});\n\n\treturn `Map(${map.size}) {${entries.join(', ')}}`;\n}\n\nexport function setToString<K>(set: Set<K>): string {\n\tconst entries: K[] = [];\n\tset.forEach(value => {\n\t\tentries.push(value);\n\t});\n\n\treturn `Set(${set.size}) {${entries.join(', ')}}`;\n}\n\nexport const enum Touch {\n\tNone = 0,\n\tAsOld = 1,\n\tAsNew = 2\n}\n\nexport class CounterSet<T> {\n\n\tprivate map = new Map<T, number>();\n\n\tadd(value: T): CounterSet<T> {\n\t\tthis.map.set(value, (this.map.get(value) || 0) + 1);\n\t\treturn this;\n\t}\n\n\tdelete(value: T): boolean {\n\t\tlet counter = this.map.get(value) || 0;\n\n\t\tif (counter === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tcounter--;\n\n\t\tif (counter === 0) {\n\t\t\tthis.map.delete(value);\n\t\t} else {\n\t\t\tthis.map.set(value, counter);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\thas(value: T): boolean {\n\t\treturn this.map.has(value);\n\t}\n}\n\n/**\n * A map that allows access both by keys and values.\n * **NOTE**: values need to be unique.\n */\nexport class BidirectionalMap<K, V> {\n\n\tprivate readonly _m1 = new Map<K, V>();\n\tprivate readonly _m2 = new Map<V, K>();\n\n\tconstructor(entries?: readonly (readonly [K, V])[]) {\n\t\tif (entries) {\n\t\t\tfor (const [key, value] of entries) {\n\t\t\t\tthis.set(key, value);\n\t\t\t}\n\t\t}\n\t}\n\n\tclear(): void {\n\t\tthis._m1.clear();\n\t\tthis._m2.clear();\n\t}\n\n\tset(key: K, value: V): void {\n\t\tthis._m1.set(key, value);\n\t\tthis._m2.set(value, key);\n\t}\n\n\tget(key: K): V | undefined {\n\t\treturn this._m1.get(key);\n\t}\n\n\tgetKey(value: V): K | undefined {\n\t\treturn this._m2.get(value);\n\t}\n\n\tdelete(key: K): boolean {\n\t\tconst value = this._m1.get(key);\n\t\tif (value === undefined) {\n\t\t\treturn false;\n\t\t}\n\t\tthis._m1.delete(key);\n\t\tthis._m2.delete(value);\n\t\treturn true;\n\t}\n\n\tforEach(callbackfn: (value: V, key: K, map: BidirectionalMap<K, V>) => void, thisArg?: any): void {\n\t\tthis._m1.forEach((value, key) => {\n\t\t\tcallbackfn.call(thisArg, value, key, this);\n\t\t});\n\t}\n\n\tkeys(): IterableIterator<K> {\n\t\treturn this._m1.keys();\n\t}\n\n\tvalues(): IterableIterator<V> {\n\t\treturn this._m1.values();\n\t}\n}\n\nexport class SetMap<K, V> {\n\n\tprivate map = new Map<K, Set<V>>();\n\n\tadd(key: K, value: V): void {\n\t\tlet values = this.map.get(key);\n\n\t\tif (!values) {\n\t\t\tvalues = new Set<V>();\n\t\t\tthis.map.set(key, values);\n\t\t}\n\n\t\tvalues.add(value);\n\t}\n\n\tdelete(key: K, value: V): void {\n\t\tconst values = this.map.get(key);\n\n\t\tif (!values) {\n\t\t\treturn;\n\t\t}\n\n\t\tvalues.delete(value);\n\n\t\tif (values.size === 0) {\n\t\t\tthis.map.delete(key);\n\t\t}\n\t}\n\n\tforEach(key: K, fn: (value: V) => void): void {\n\t\tconst values = this.map.get(key);\n\n\t\tif (!values) {\n\t\t\treturn;\n\t\t}\n\n\t\tvalues.forEach(fn);\n\t}\n\n\tget(key: K): ReadonlySet<V> {\n\t\tconst values = this.map.get(key);\n\t\tif (!values) {\n\t\t\treturn new Set<V>();\n\t\t}\n\t\treturn values;\n\t}\n}\n\nexport function mapsStrictEqualIgnoreOrder(a: Map<unknown, unknown>, b: Map<unknown, unknown>): boolean {\n\tif (a === b) {\n\t\treturn true;\n\t}\n\n\tif (a.size !== b.size) {\n\t\treturn false;\n\t}\n\n\tfor (const [key, value] of a) {\n\t\tif (!b.has(key) || b.get(key) !== value) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfor (const [key] of b) {\n\t\tif (!a.has(key)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Given a function, returns a function that is only calling that function once.\n */\nexport function createSingleCallFunction<T extends Function>(this: unknown, fn: T, fnDidRunCallback?: () => void): T {\n\tconst _this = this;\n\tlet didCall = false;\n\tlet result: unknown;\n\n\treturn function () {\n\t\tif (didCall) {\n\t\t\treturn result;\n\t\t}\n\n\t\tdidCall = true;\n\t\tif (fnDidRunCallback) {\n\t\t\ttry {\n\t\t\t\tresult = fn.apply(_this, arguments);\n\t\t\t} finally {\n\t\t\t\tfnDidRunCallback();\n\t\t\t}\n\t\t} else {\n\t\t\tresult = fn.apply(_this, arguments);\n\t\t}\n\n\t\treturn result;\n\t} as unknown as T;\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport namespace Iterable {\n\n\texport function is<T = any>(thing: any): thing is Iterable<T> {\n\t\treturn thing && typeof thing === 'object' && typeof thing[Symbol.iterator] === 'function';\n\t}\n\n\tconst _empty: Iterable<any> = Object.freeze([]);\n\texport function empty<T = any>(): Iterable<T> {\n\t\treturn _empty;\n\t}\n\n\texport function* single<T>(element: T): Iterable<T> {\n\t\tyield element;\n\t}\n\n\texport function wrap<T>(iterableOrElement: Iterable<T> | T): Iterable<T> {\n\t\tif (is(iterableOrElement)) {\n\t\t\treturn iterableOrElement;\n\t\t} else {\n\t\t\treturn single(iterableOrElement);\n\t\t}\n\t}\n\n\texport function from<T>(iterable: Iterable<T> | undefined | null): Iterable<T> {\n\t\treturn iterable || _empty;\n\t}\n\n\texport function* reverse<T>(array: Array<T>): Iterable<T> {\n\t\tfor (let i = array.length - 1; i >= 0; i--) {\n\t\t\tyield array[i];\n\t\t}\n\t}\n\n\texport function isEmpty<T>(iterable: Iterable<T> | undefined | null): boolean {\n\t\treturn !iterable || iterable[Symbol.iterator]().next().done === true;\n\t}\n\n\texport function first<T>(iterable: Iterable<T>): T | undefined {\n\t\treturn iterable[Symbol.iterator]().next().value;\n\t}\n\n\texport function some<T>(iterable: Iterable<T>, predicate: (t: T, i: number) => unknown): boolean {\n\t\tlet i = 0;\n\t\tfor (const element of iterable) {\n\t\t\tif (predicate(element, i++)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\texport function find<T, R extends T>(iterable: Iterable<T>, predicate: (t: T) => t is R): R | undefined;\n\texport function find<T>(iterable: Iterable<T>, predicate: (t: T) => boolean): T | undefined;\n\texport function find<T>(iterable: Iterable<T>, predicate: (t: T) => boolean): T | undefined {\n\t\tfor (const element of iterable) {\n\t\t\tif (predicate(element)) {\n\t\t\t\treturn element;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\texport function filter<T, R extends T>(iterable: Iterable<T>, predicate: (t: T) => t is R): Iterable<R>;\n\texport function filter<T>(iterable: Iterable<T>, predicate: (t: T) => boolean): Iterable<T>;\n\texport function* filter<T>(iterable: Iterable<T>, predicate: (t: T) => boolean): Iterable<T> {\n\t\tfor (const element of iterable) {\n\t\t\tif (predicate(element)) {\n\t\t\t\tyield element;\n\t\t\t}\n\t\t}\n\t}\n\n\texport function* map<T, R>(iterable: Iterable<T>, fn: (t: T, index: number) => R): Iterable<R> {\n\t\tlet index = 0;\n\t\tfor (const element of iterable) {\n\t\t\tyield fn(element, index++);\n\t\t}\n\t}\n\n\texport function* flatMap<T, R>(iterable: Iterable<T>, fn: (t: T, index: number) => Iterable<R>): Iterable<R> {\n\t\tlet index = 0;\n\t\tfor (const element of iterable) {\n\t\t\tyield* fn(element, index++);\n\t\t}\n\t}\n\n\texport function* concat<T>(...iterables: Iterable<T>[]): Iterable<T> {\n\t\tfor (const iterable of iterables) {\n\t\t\tyield* iterable;\n\t\t}\n\t}\n\n\texport function reduce<T, R>(iterable: Iterable<T>, reducer: (previousValue: R, currentValue: T) => R, initialValue: R): R {\n\t\tlet value = initialValue;\n\t\tfor (const element of iterable) {\n\t\t\tvalue = reducer(value, element);\n\t\t}\n\t\treturn value;\n\t}\n\n\t/**\n\t * Returns an iterable slice of the array, with the same semantics as `array.slice()`.\n\t */\n\texport function* slice<T>(arr: ReadonlyArray<T>, from: number, to = arr.length): Iterable<T> {\n\t\tif (from < 0) {\n\t\t\tfrom += arr.length;\n\t\t}\n\n\t\tif (to < 0) {\n\t\t\tto += arr.length;\n\t\t} else if (to > arr.length) {\n\t\t\tto = arr.length;\n\t\t}\n\n\t\tfor (; from < to; from++) {\n\t\t\tyield arr[from];\n\t\t}\n\t}\n\n\t/**\n\t * Consumes `atMost` elements from iterable and returns the consumed elements,\n\t * and an iterable for the rest of the elements.\n\t */\n\texport function consume<T>(iterable: Iterable<T>, atMost: number = Number.POSITIVE_INFINITY): [T[], Iterable<T>] {\n\t\tconst consumed: T[] = [];\n\n\t\tif (atMost === 0) {\n\t\t\treturn [consumed, iterable];\n\t\t}\n\n\t\tconst iterator = iterable[Symbol.iterator]();\n\n\t\tfor (let i = 0; i < atMost; i++) {\n\t\t\tconst next = iterator.next();\n\n\t\t\tif (next.done) {\n\t\t\t\treturn [consumed, Iterable.empty()];\n\t\t\t}\n\n\t\t\tconsumed.push(next.value);\n\t\t}\n\n\t\treturn [consumed, { [Symbol.iterator]() { return iterator; } }];\n\t}\n\n\texport async function asyncToArray<T>(iterable: AsyncIterable<T>): Promise<T[]> {\n\t\tconst result: T[] = [];\n\t\tfor await (const item of iterable) {\n\t\t\tresult.push(item);\n\t\t}\n\t\treturn Promise.resolve(result);\n\t}\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { compareBy, numberComparator } from 'vs/base/common/arrays';\nimport { groupBy } from 'vs/base/common/collections';\nimport { SetMap } from './map';\nimport { createSingleCallFunction } from 'vs/base/common/functional';\nimport { Iterable } from 'vs/base/common/iterator';\n\n// #region Disposable Tracking\n\n/**\n * Enables logging of potentially leaked disposables.\n *\n * A disposable is considered leaked if it is not disposed or not registered as the child of\n * another disposable. This tracking is very simple an only works for classes that either\n * extend Disposable or use a DisposableStore. This means there are a lot of false positives.\n */\nconst TRACK_DISPOSABLES = false;\nlet disposableTracker: IDisposableTracker | null = null;\n\nexport interface IDisposableTracker {\n\t/**\n\t * Is called on construction of a disposable.\n\t*/\n\ttrackDisposable(disposable: IDisposable): void;\n\n\t/**\n\t * Is called when a disposable is registered as child of another disposable (e.g. {@link DisposableStore}).\n\t * If parent is `null`, the disposable is removed from its former parent.\n\t*/\n\tsetParent(child: IDisposable, parent: IDisposable | null): void;\n\n\t/**\n\t * Is called after a disposable is disposed.\n\t*/\n\tmarkAsDisposed(disposable: IDisposable): void;\n\n\t/**\n\t * Indicates that the given object is a singleton which does not need to be disposed.\n\t*/\n\tmarkAsSingleton(disposable: IDisposable): void;\n}\n\nexport interface DisposableInfo {\n\tvalue: IDisposable;\n\tsource: string | null;\n\tparent: IDisposable | null;\n\tisSingleton: boolean;\n\tidx: number;\n}\n\nexport class DisposableTracker implements IDisposableTracker {\n\tprivate static idx = 0;\n\n\tprivate readonly livingDisposables = new Map<IDisposable, DisposableInfo>();\n\n\tprivate getDisposableData(d: IDisposable): DisposableInfo {\n\t\tlet val = this.livingDisposables.get(d);\n\t\tif (!val) {\n\t\t\tval = { parent: null, source: null, isSingleton: false, value: d, idx: DisposableTracker.idx++ };\n\t\t\tthis.livingDisposables.set(d, val);\n\t\t}\n\t\treturn val;\n\t}\n\n\ttrackDisposable(d: IDisposable): void {\n\t\tconst data = this.getDisposableData(d);\n\t\tif (!data.source) {\n\t\t\tdata.source =\n\t\t\t\tnew Error().stack!;\n\t\t}\n\t}\n\n\tsetParent(child: IDisposable, parent: IDisposable | null): void {\n\t\tconst data = this.getDisposableData(child);\n\t\tdata.parent = parent;\n\t}\n\n\tmarkAsDisposed(x: IDisposable): void {\n\t\tthis.livingDisposables.delete(x);\n\t}\n\n\tmarkAsSingleton(disposable: IDisposable): void {\n\t\tthis.getDisposableData(disposable).isSingleton = true;\n\t}\n\n\tprivate getRootParent(data: DisposableInfo, cache: Map<DisposableInfo, DisposableInfo>): DisposableInfo {\n\t\tconst cacheValue = cache.get(data);\n\t\tif (cacheValue) {\n\t\t\treturn cacheValue;\n\t\t}\n\n\t\tconst result = data.parent ? this.getRootParent(this.getDisposableData(data.parent), cache) : data;\n\t\tcache.set(data, result);\n\t\treturn result;\n\t}\n\n\tgetTrackedDisposables(): IDisposable[] {\n\t\tconst rootParentCache = new Map<DisposableInfo, DisposableInfo>();\n\n\t\tconst leaking = [...this.livingDisposables.entries()]\n\t\t\t.filter(([, v]) => v.source !== null && !this.getRootParent(v, rootParentCache).isSingleton)\n\t\t\t.flatMap(([k]) => k);\n\n\t\treturn leaking;\n\t}\n\n\tcomputeLeakingDisposables(maxReported = 10, preComputedLeaks?: DisposableInfo[]): { leaks: DisposableInfo[]; details: string } | undefined {\n\t\tlet uncoveredLeakingObjs: DisposableInfo[] | undefined;\n\t\tif (preComputedLeaks) {\n\t\t\tuncoveredLeakingObjs = preComputedLeaks;\n\t\t} else {\n\t\t\tconst rootParentCache = new Map<DisposableInfo, DisposableInfo>();\n\n\t\t\tconst leakingObjects = [...this.livingDisposables.values()]\n\t\t\t\t.filter((info) => info.source !== null && !this.getRootParent(info, rootParentCache).isSingleton);\n\n\t\t\tif (leakingObjects.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst leakingObjsSet = new Set(leakingObjects.map(o => o.value));\n\n\t\t\t// Remove all objects that are a child of other leaking objects. Assumes there are no cycles.\n\t\t\tuncoveredLeakingObjs = leakingObjects.filter(l => {\n\t\t\t\treturn !(l.parent && leakingObjsSet.has(l.parent));\n\t\t\t});\n\n\t\t\tif (uncoveredLeakingObjs.length === 0) {\n\t\t\t\tthrow new Error('There are cyclic diposable chains!');\n\t\t\t}\n\t\t}\n\n\t\tif (!uncoveredLeakingObjs) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tfunction getStackTracePath(leaking: DisposableInfo): string[] {\n\t\t\tfunction removePrefix(array: string[], linesToRemove: (string | RegExp)[]) {\n\t\t\t\twhile (array.length > 0 && linesToRemove.some(regexp => typeof regexp === 'string' ? regexp === array[0] : array[0].match(regexp))) {\n\t\t\t\t\tarray.shift();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst lines = leaking.source!.split('\\n').map(p => p.trim().replace('at ', '')).filter(l => l !== '');\n\t\t\tremovePrefix(lines, ['Error', /^trackDisposable \\(.*\\)$/, /^DisposableTracker.trackDisposable \\(.*\\)$/]);\n\t\t\treturn lines.reverse();\n\t\t}\n\n\t\tconst stackTraceStarts = new SetMap<string, DisposableInfo>();\n\t\tfor (const leaking of uncoveredLeakingObjs) {\n\t\t\tconst stackTracePath = getStackTracePath(leaking);\n\t\t\tfor (let i = 0; i <= stackTracePath.length; i++) {\n\t\t\t\tstackTraceStarts.add(stackTracePath.slice(0, i).join('\\n'), leaking);\n\t\t\t}\n\t\t}\n\n\t\t// Put earlier leaks first\n\t\tuncoveredLeakingObjs.sort(compareBy(l => l.idx, numberComparator));\n\n\t\tlet message = '';\n\n\t\tlet i = 0;\n\t\tfor (const leaking of uncoveredLeakingObjs.slice(0, maxReported)) {\n\t\t\ti++;\n\t\t\tconst stackTracePath = getStackTracePath(leaking);\n\t\t\tconst stackTraceFormattedLines = [];\n\n\t\t\tfor (let i = 0; i < stackTracePath.length; i++) {\n\t\t\t\tlet line = stackTracePath[i];\n\t\t\t\tconst starts = stackTraceStarts.get(stackTracePath.slice(0, i + 1).join('\\n'));\n\t\t\t\tline = `(shared with ${starts.size}/${uncoveredLeakingObjs.length} leaks) at ${line}`;\n\n\t\t\t\tconst prevStarts = stackTraceStarts.get(stackTracePath.slice(0, i).join('\\n'));\n\t\t\t\tconst continuations = groupBy([...prevStarts].map(d => getStackTracePath(d)[i]), v => v);\n\t\t\t\tdelete continuations[stackTracePath[i]];\n\t\t\t\tfor (const [cont, set] of Object.entries(continuations)) {\n\t\t\t\t\tstackTraceFormattedLines.unshift(`    - stacktraces of ${set.length} other leaks continue with ${cont}`);\n\t\t\t\t}\n\n\t\t\t\tstackTraceFormattedLines.unshift(line);\n\t\t\t}\n\n\t\t\tmessage += `\\n\\n\\n==================== Leaking disposable ${i}/${uncoveredLeakingObjs.length}: ${leaking.value.constructor.name} ====================\\n${stackTraceFormattedLines.join('\\n')}\\n============================================================\\n\\n`;\n\t\t}\n\n\t\tif (uncoveredLeakingObjs.length > maxReported) {\n\t\t\tmessage += `\\n\\n\\n... and ${uncoveredLeakingObjs.length - maxReported} more leaking disposables\\n\\n`;\n\t\t}\n\n\t\treturn { leaks: uncoveredLeakingObjs, details: message };\n\t}\n}\n\nexport function setDisposableTracker(tracker: IDisposableTracker | null): void {\n\tdisposableTracker = tracker;\n}\n\nif (TRACK_DISPOSABLES) {\n\tconst __is_disposable_tracked__ = '__is_disposable_tracked__';\n\tsetDisposableTracker(new class implements IDisposableTracker {\n\t\ttrackDisposable(x: IDisposable): void {\n\t\t\tconst stack = new Error('Potentially leaked disposable').stack!;\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (!(x as any)[__is_disposable_tracked__]) {\n\t\t\t\t\tconsole.log(stack);\n\t\t\t\t}\n\t\t\t}, 3000);\n\t\t}\n\n\t\tsetParent(child: IDisposable, parent: IDisposable | null): void {\n\t\t\tif (child && child !== Disposable.None) {\n\t\t\t\ttry {\n\t\t\t\t\t(child as any)[__is_disposable_tracked__] = true;\n\t\t\t\t} catch {\n\t\t\t\t\t// noop\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmarkAsDisposed(disposable: IDisposable): void {\n\t\t\tif (disposable && disposable !== Disposable.None) {\n\t\t\t\ttry {\n\t\t\t\t\t(disposable as any)[__is_disposable_tracked__] = true;\n\t\t\t\t} catch {\n\t\t\t\t\t// noop\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmarkAsSingleton(disposable: IDisposable): void { }\n\t});\n}\n\nexport function trackDisposable<T extends IDisposable>(x: T): T {\n\tdisposableTracker?.trackDisposable(x);\n\treturn x;\n}\n\nexport function markAsDisposed(disposable: IDisposable): void {\n\tdisposableTracker?.markAsDisposed(disposable);\n}\n\nfunction setParentOfDisposable(child: IDisposable, parent: IDisposable | null): void {\n\tdisposableTracker?.setParent(child, parent);\n}\n\nfunction setParentOfDisposables(children: IDisposable[], parent: IDisposable | null): void {\n\tif (!disposableTracker) {\n\t\treturn;\n\t}\n\tfor (const child of children) {\n\t\tdisposableTracker.setParent(child, parent);\n\t}\n}\n\n/**\n * Indicates that the given object is a singleton which does not need to be disposed.\n*/\nexport function markAsSingleton<T extends IDisposable>(singleton: T): T {\n\tdisposableTracker?.markAsSingleton(singleton);\n\treturn singleton;\n}\n\n// #endregion\n\n/**\n * An object that performs a cleanup operation when `.dispose()` is called.\n *\n * Some examples of how disposables are used:\n *\n * - An event listener that removes itself when `.dispose()` is called.\n * - A resource such as a file system watcher that cleans up the resource when `.dispose()` is called.\n * - The return value from registering a provider. When `.dispose()` is called, the provider is unregistered.\n */\nexport interface IDisposable {\n\tdispose(): void;\n}\n\n/**\n * Check if `thing` is {@link IDisposable disposable}.\n */\nexport function isDisposable<E extends any>(thing: E): thing is E & IDisposable {\n\treturn typeof thing === 'object' && thing !== null && typeof (<IDisposable><any>thing).dispose === 'function' && (<IDisposable><any>thing).dispose.length === 0;\n}\n\n/**\n * Disposes of the value(s) passed in.\n */\nexport function dispose<T extends IDisposable>(disposable: T): T;\nexport function dispose<T extends IDisposable>(disposable: T | undefined): T | undefined;\nexport function dispose<T extends IDisposable, A extends Iterable<T> = Iterable<T>>(disposables: A): A;\nexport function dispose<T extends IDisposable>(disposables: Array<T>): Array<T>;\nexport function dispose<T extends IDisposable>(disposables: ReadonlyArray<T>): ReadonlyArray<T>;\nexport function dispose<T extends IDisposable>(arg: T | Iterable<T> | undefined): any {\n\tif (Iterable.is(arg)) {\n\t\tconst errors: any[] = [];\n\n\t\tfor (const d of arg) {\n\t\t\tif (d) {\n\t\t\t\ttry {\n\t\t\t\t\td.dispose();\n\t\t\t\t} catch (e) {\n\t\t\t\t\terrors.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (errors.length === 1) {\n\t\t\tthrow errors[0];\n\t\t} else if (errors.length > 1) {\n\t\t\tthrow new AggregateError(errors, 'Encountered errors while disposing of store');\n\t\t}\n\n\t\treturn Array.isArray(arg) ? [] : arg;\n\t} else if (arg) {\n\t\targ.dispose();\n\t\treturn arg;\n\t}\n}\n\nexport function disposeIfDisposable<T extends IDisposable | object>(disposables: Array<T>): Array<T> {\n\tfor (const d of disposables) {\n\t\tif (isDisposable(d)) {\n\t\t\td.dispose();\n\t\t}\n\t}\n\treturn [];\n}\n\n/**\n * Combine multiple disposable values into a single {@link IDisposable}.\n */\nexport function combinedDisposable(...disposables: IDisposable[]): IDisposable {\n\tconst parent = toDisposable(() => dispose(disposables));\n\tsetParentOfDisposables(disposables, parent);\n\treturn parent;\n}\n\n/**\n * Turn a function that implements dispose into an {@link IDisposable}.\n *\n * @param fn Clean up function, guaranteed to be called only **once**.\n */\nexport function toDisposable(fn: () => void): IDisposable {\n\tconst self = trackDisposable({\n\t\tdispose: createSingleCallFunction(() => {\n\t\t\tmarkAsDisposed(self);\n\t\t\tfn();\n\t\t})\n\t});\n\treturn self;\n}\n\n/**\n * Manages a collection of disposable values.\n *\n * This is the preferred way to manage multiple disposables. A `DisposableStore` is safer to work with than an\n * `IDisposable[]` as it considers edge cases, such as registering the same value multiple times or adding an item to a\n * store that has already been disposed of.\n */\nexport class DisposableStore implements IDisposable {\n\n\tstatic DISABLE_DISPOSED_WARNING = false;\n\n\tprivate readonly _toDispose = new Set<IDisposable>();\n\tprivate _isDisposed = false;\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t}\n\n\t/**\n\t * Dispose of all registered disposables and mark this object as disposed.\n\t *\n\t * Any future disposables added to this object will be disposed of on `add`.\n\t */\n\tpublic dispose(): void {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\n\t\tmarkAsDisposed(this);\n\t\tthis._isDisposed = true;\n\t\tthis.clear();\n\t}\n\n\t/**\n\t * @return `true` if this object has been disposed of.\n\t */\n\tpublic get isDisposed(): boolean {\n\t\treturn this._isDisposed;\n\t}\n\n\t/**\n\t * Dispose of all registered disposables but do not mark this object as disposed.\n\t */\n\tpublic clear(): void {\n\t\tif (this._toDispose.size === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tdispose(this._toDispose);\n\t\t} finally {\n\t\t\tthis._toDispose.clear();\n\t\t}\n\t}\n\n\t/**\n\t * Add a new {@link IDisposable disposable} to the collection.\n\t */\n\tpublic add<T extends IDisposable>(o: T): T {\n\t\tif (!o) {\n\t\t\treturn o;\n\t\t}\n\t\tif ((o as unknown as DisposableStore) === this) {\n\t\t\tthrow new Error('Cannot register a disposable on itself!');\n\t\t}\n\n\t\tsetParentOfDisposable(o, this);\n\t\tif (this._isDisposed) {\n\t\t\tif (!DisposableStore.DISABLE_DISPOSED_WARNING) {\n\t\t\t\tconsole.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._toDispose.add(o);\n\t\t}\n\n\t\treturn o;\n\t}\n\n\t/**\n\t * Deletes a disposable from store and disposes of it. This will not throw or warn and proceed to dispose the\n\t * disposable even when the disposable is not part in the store.\n\t */\n\tpublic delete<T extends IDisposable>(o: T): void {\n\t\tif (!o) {\n\t\t\treturn;\n\t\t}\n\t\tif ((o as unknown as DisposableStore) === this) {\n\t\t\tthrow new Error('Cannot dispose a disposable on itself!');\n\t\t}\n\t\tthis._toDispose.delete(o);\n\t\to.dispose();\n\t}\n\n\t/**\n\t * Deletes the value from the store, but does not dispose it.\n\t */\n\tpublic deleteAndLeak<T extends IDisposable>(o: T): void {\n\t\tif (!o) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._toDispose.has(o)) {\n\t\t\tthis._toDispose.delete(o);\n\t\t\tsetParentOfDisposable(o, null);\n\t\t}\n\t}\n}\n\n/**\n * Abstract base class for a {@link IDisposable disposable} object.\n *\n * Subclasses can {@linkcode _register} disposables that will be automatically cleaned up when this object is disposed of.\n */\nexport abstract class Disposable implements IDisposable {\n\n\t/**\n\t * A disposable that does nothing when it is disposed of.\n\t *\n\t * TODO: This should not be a static property.\n\t */\n\tstatic readonly None = Object.freeze<IDisposable>({ dispose() { } });\n\n\tprotected readonly _store = new DisposableStore();\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t\tsetParentOfDisposable(this._store, this);\n\t}\n\n\tpublic dispose(): void {\n\t\tmarkAsDisposed(this);\n\n\t\tthis._store.dispose();\n\t}\n\n\t/**\n\t * Adds `o` to the collection of disposables managed by this object.\n\t */\n\tprotected _register<T extends IDisposable>(o: T): T {\n\t\tif ((o as unknown as Disposable) === this) {\n\t\t\tthrow new Error('Cannot register a disposable on itself!');\n\t\t}\n\t\treturn this._store.add(o);\n\t}\n}\n\n/**\n * Manages the lifecycle of a disposable value that may be changed.\n *\n * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can\n * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.\n */\nexport class MutableDisposable<T extends IDisposable> implements IDisposable {\n\tprivate _value?: T;\n\tprivate _isDisposed = false;\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t}\n\n\tget value(): T | undefined {\n\t\treturn this._isDisposed ? undefined : this._value;\n\t}\n\n\tset value(value: T | undefined) {\n\t\tif (this._isDisposed || value === this._value) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._value?.dispose();\n\t\tif (value) {\n\t\t\tsetParentOfDisposable(value, this);\n\t\t}\n\t\tthis._value = value;\n\t}\n\n\t/**\n\t * Resets the stored value and disposed of the previously stored value.\n\t */\n\tclear(): void {\n\t\tthis.value = undefined;\n\t}\n\n\tdispose(): void {\n\t\tthis._isDisposed = true;\n\t\tmarkAsDisposed(this);\n\t\tthis._value?.dispose();\n\t\tthis._value = undefined;\n\t}\n\n\t/**\n\t * Clears the value, but does not dispose it.\n\t * The old value is returned.\n\t*/\n\tclearAndLeak(): T | undefined {\n\t\tconst oldValue = this._value;\n\t\tthis._value = undefined;\n\t\tif (oldValue) {\n\t\t\tsetParentOfDisposable(oldValue, null);\n\t\t}\n\t\treturn oldValue;\n\t}\n}\n\n/**\n * Manages the lifecycle of a disposable value that may be changed like {@link MutableDisposable}, but the value must\n * exist and cannot be undefined.\n */\nexport class MandatoryMutableDisposable<T extends IDisposable> implements IDisposable {\n\tprivate readonly _disposable = new MutableDisposable<T>();\n\tprivate _isDisposed = false;\n\n\tconstructor(initialValue: T) {\n\t\tthis._disposable.value = initialValue;\n\t}\n\n\tget value(): T {\n\t\treturn this._disposable.value!;\n\t}\n\n\tset value(value: T) {\n\t\tif (this._isDisposed || value === this._disposable.value) {\n\t\t\treturn;\n\t\t}\n\t\tthis._disposable.value = value;\n\t}\n\n\tdispose() {\n\t\tthis._isDisposed = true;\n\t\tthis._disposable.dispose();\n\t}\n}\n\nexport class RefCountedDisposable {\n\n\tprivate _counter: number = 1;\n\n\tconstructor(\n\t\tprivate readonly _disposable: IDisposable,\n\t) { }\n\n\tacquire() {\n\t\tthis._counter++;\n\t\treturn this;\n\t}\n\n\trelease() {\n\t\tif (--this._counter === 0) {\n\t\t\tthis._disposable.dispose();\n\t\t}\n\t\treturn this;\n\t}\n}\n\n/**\n * A safe disposable can be `unset` so that a leaked reference (listener)\n * can be cut-off.\n */\nexport class SafeDisposable implements IDisposable {\n\n\tdispose: () => void = () => { };\n\tunset: () => void = () => { };\n\tisset: () => boolean = () => false;\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t}\n\n\tset(fn: Function) {\n\t\tlet callback: Function | undefined = fn;\n\t\tthis.unset = () => callback = undefined;\n\t\tthis.isset = () => callback !== undefined;\n\t\tthis.dispose = () => {\n\t\t\tif (callback) {\n\t\t\t\tcallback();\n\t\t\t\tcallback = undefined;\n\t\t\t\tmarkAsDisposed(this);\n\t\t\t}\n\t\t};\n\t\treturn this;\n\t}\n}\n\nexport interface IReference<T> extends IDisposable {\n\treadonly object: T;\n}\n\nexport abstract class ReferenceCollection<T> {\n\n\tprivate readonly references: Map<string, { readonly object: T; counter: number }> = new Map();\n\n\tacquire(key: string, ...args: any[]): IReference<T> {\n\t\tlet reference = this.references.get(key);\n\n\t\tif (!reference) {\n\t\t\treference = { counter: 0, object: this.createReferencedObject(key, ...args) };\n\t\t\tthis.references.set(key, reference);\n\t\t}\n\n\t\tconst { object } = reference;\n\t\tconst dispose = createSingleCallFunction(() => {\n\t\t\tif (--reference.counter === 0) {\n\t\t\t\tthis.destroyReferencedObject(key, reference.object);\n\t\t\t\tthis.references.delete(key);\n\t\t\t}\n\t\t});\n\n\t\treference.counter++;\n\n\t\treturn { object, dispose };\n\t}\n\n\tprotected abstract createReferencedObject(key: string, ...args: any[]): T;\n\tprotected abstract destroyReferencedObject(key: string, object: T): void;\n}\n\n/**\n * Unwraps a reference collection of promised values. Makes sure\n * references are disposed whenever promises get rejected.\n */\nexport class AsyncReferenceCollection<T> {\n\n\tconstructor(private referenceCollection: ReferenceCollection<Promise<T>>) { }\n\n\tasync acquire(key: string, ...args: any[]): Promise<IReference<T>> {\n\t\tconst ref = this.referenceCollection.acquire(key, ...args);\n\n\t\ttry {\n\t\t\tconst object = await ref.object;\n\n\t\t\treturn {\n\t\t\t\tobject,\n\t\t\t\tdispose: () => ref.dispose()\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tref.dispose();\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nexport class ImmortalReference<T> implements IReference<T> {\n\tconstructor(public object: T) { }\n\tdispose(): void { /* noop */ }\n}\n\nexport function disposeOnReturn(fn: (store: DisposableStore) => void): void {\n\tconst store = new DisposableStore();\n\ttry {\n\t\tfn(store);\n\t} finally {\n\t\tstore.dispose();\n\t}\n}\n\n/**\n * A map the manages the lifecycle of the values that it stores.\n */\nexport class DisposableMap<K, V extends IDisposable = IDisposable> implements IDisposable {\n\n\tprivate readonly _store = new Map<K, V>();\n\tprivate _isDisposed = false;\n\n\tconstructor() {\n\t\ttrackDisposable(this);\n\t}\n\n\t/**\n\t * Disposes of all stored values and mark this object as disposed.\n\t *\n\t * Trying to use this object after it has been disposed of is an error.\n\t */\n\tdispose(): void {\n\t\tmarkAsDisposed(this);\n\t\tthis._isDisposed = true;\n\t\tthis.clearAndDisposeAll();\n\t}\n\n\t/**\n\t * Disposes of all stored values and clear the map, but DO NOT mark this object as disposed.\n\t */\n\tclearAndDisposeAll(): void {\n\t\tif (!this._store.size) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tdispose(this._store.values());\n\t\t} finally {\n\t\t\tthis._store.clear();\n\t\t}\n\t}\n\n\thas(key: K): boolean {\n\t\treturn this._store.has(key);\n\t}\n\n\tget size(): number {\n\t\treturn this._store.size;\n\t}\n\n\tget(key: K): V | undefined {\n\t\treturn this._store.get(key);\n\t}\n\n\tset(key: K, value: V, skipDisposeOnOverwrite = false): void {\n\t\tif (this._isDisposed) {\n\t\t\tconsole.warn(new Error('Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!').stack);\n\t\t}\n\n\t\tif (!skipDisposeOnOverwrite) {\n\t\t\tthis._store.get(key)?.dispose();\n\t\t}\n\n\t\tthis._store.set(key, value);\n\t}\n\n\t/**\n\t * Delete the value stored for `key` from this map and also dispose of it.\n\t */\n\tdeleteAndDispose(key: K): void {\n\t\tthis._store.get(key)?.dispose();\n\t\tthis._store.delete(key);\n\t}\n\n\t/**\n\t * Delete the value stored for `key` from this map but return it. The caller is\n\t * responsible for disposing of the value.\n\t */\n\tdeleteAndLeak(key: K): V | undefined {\n\t\tconst value = this._store.get(key);\n\t\tthis._store.delete(key);\n\t\treturn value;\n\t}\n\n\tkeys(): IterableIterator<K> {\n\t\treturn this._store.keys();\n\t}\n\n\tvalues(): IterableIterator<V> {\n\t\treturn this._store.values();\n\t}\n\n\t[Symbol.iterator](): IterableIterator<[K, V]> {\n\t\treturn this._store[Symbol.iterator]();\n\t}\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport type CodeWindow = Window & typeof globalThis & {\n\treadonly vscodeWindowId: number;\n};\n\nexport function ensureCodeWindow(targetWindow: Window, fallbackWindowId: number): asserts targetWindow is CodeWindow {\n}\n\n// eslint-disable-next-line no-restricted-globals\nexport const mainWindow = (typeof window === 'object' ? window : globalThis) as CodeWindow;\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nclass Node<E> {\n\n\tstatic readonly Undefined = new Node<any>(undefined);\n\n\telement: E;\n\tnext: Node<E>;\n\tprev: Node<E>;\n\n\tconstructor(element: E) {\n\t\tthis.element = element;\n\t\tthis.next = Node.Undefined;\n\t\tthis.prev = Node.Undefined;\n\t}\n}\n\nexport class LinkedList<E> {\n\n\tprivate _first: Node<E> = Node.Undefined;\n\tprivate _last: Node<E> = Node.Undefined;\n\tprivate _size: number = 0;\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tisEmpty(): boolean {\n\t\treturn this._first === Node.Undefined;\n\t}\n\n\tclear(): void {\n\t\tlet node = this._first;\n\t\twhile (node !== Node.Undefined) {\n\t\t\tconst next = node.next;\n\t\t\tnode.prev = Node.Undefined;\n\t\t\tnode.next = Node.Undefined;\n\t\t\tnode = next;\n\t\t}\n\n\t\tthis._first = Node.Undefined;\n\t\tthis._last = Node.Undefined;\n\t\tthis._size = 0;\n\t}\n\n\tunshift(element: E): () => void {\n\t\treturn this._insert(element, false);\n\t}\n\n\tpush(element: E): () => void {\n\t\treturn this._insert(element, true);\n\t}\n\n\tprivate _insert(element: E, atTheEnd: boolean): () => void {\n\t\tconst newNode = new Node(element);\n\t\tif (this._first === Node.Undefined) {\n\t\t\tthis._first = newNode;\n\t\t\tthis._last = newNode;\n\n\t\t} else if (atTheEnd) {\n\t\t\t// push\n\t\t\tconst oldLast = this._last;\n\t\t\tthis._last = newNode;\n\t\t\tnewNode.prev = oldLast;\n\t\t\toldLast.next = newNode;\n\n\t\t} else {\n\t\t\t// unshift\n\t\t\tconst oldFirst = this._first;\n\t\t\tthis._first = newNode;\n\t\t\tnewNode.next = oldFirst;\n\t\t\toldFirst.prev = newNode;\n\t\t}\n\t\tthis._size += 1;\n\n\t\tlet didRemove = false;\n\t\treturn () => {\n\t\t\tif (!didRemove) {\n\t\t\t\tdidRemove = true;\n\t\t\t\tthis._remove(newNode);\n\t\t\t}\n\t\t};\n\t}\n\n\tshift(): E | undefined {\n\t\tif (this._first === Node.Undefined) {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tconst res = this._first.element;\n\t\t\tthis._remove(this._first);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tpop(): E | undefined {\n\t\tif (this._last === Node.Undefined) {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tconst res = this._last.element;\n\t\t\tthis._remove(this._last);\n\t\t\treturn res;\n\t\t}\n\t}\n\n\tprivate _remove(node: Node<E>): void {\n\t\tif (node.prev !== Node.Undefined && node.next !== Node.Undefined) {\n\t\t\t// middle\n\t\t\tconst anchor = node.prev;\n\t\t\tanchor.next = node.next;\n\t\t\tnode.next.prev = anchor;\n\n\t\t} else if (node.prev === Node.Undefined && node.next === Node.Undefined) {\n\t\t\t// only node\n\t\t\tthis._first = Node.Undefined;\n\t\t\tthis._last = Node.Undefined;\n\n\t\t} else if (node.next === Node.Undefined) {\n\t\t\t// last\n\t\t\tthis._last = this._last.prev!;\n\t\t\tthis._last.next = Node.Undefined;\n\n\t\t} else if (node.prev === Node.Undefined) {\n\t\t\t// first\n\t\t\tthis._first = this._first.next!;\n\t\t\tthis._first.prev = Node.Undefined;\n\t\t}\n\n\t\t// done\n\t\tthis._size -= 1;\n\t}\n\n\t*[Symbol.iterator](): Iterator<E> {\n\t\tlet node = this._first;\n\t\twhile (node !== Node.Undefined) {\n\t\t\tyield node.element;\n\t\t\tnode = node.next;\n\t\t}\n\t}\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// fake definition so that the valid layers check won't trip on this\ndeclare const globalThis: { performance?: { now(): number } };\n\nconst hasPerformanceNow = (globalThis.performance && typeof globalThis.performance.now === 'function');\n\nexport class StopWatch {\n\n\tprivate _startTime: number;\n\tprivate _stopTime: number;\n\n\tprivate readonly _now: () => number;\n\n\tpublic static create(highResolution?: boolean): StopWatch {\n\t\treturn new StopWatch(highResolution);\n\t}\n\n\tconstructor(highResolution?: boolean) {\n\t\tthis._now = hasPerformanceNow && highResolution === false ? Date.now : globalThis.performance!.now.bind(globalThis.performance);\n\t\tthis._startTime = this._now();\n\t\tthis._stopTime = -1;\n\t}\n\n\tpublic stop(): void {\n\t\tthis._stopTime = this._now();\n\t}\n\n\tpublic reset(): void {\n\t\tthis._startTime = this._now();\n\t\tthis._stopTime = -1;\n\t}\n\n\tpublic elapsed(): number {\n\t\tif (this._stopTime !== -1) {\n\t\t\treturn this._stopTime - this._startTime;\n\t\t}\n\t\treturn this._now() - this._startTime;\n\t}\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { onUnexpectedError } from 'vs/base/common/errors';\nimport { createSingleCallFunction } from 'vs/base/common/functional';\nimport { combinedDisposable, Disposable, DisposableMap, DisposableStore, IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { LinkedList } from 'vs/base/common/linkedList';\nimport { IObservable, IObserver } from 'vs/base/common/observable';\nimport { StopWatch } from 'vs/base/common/stopwatch';\nimport { MicrotaskDelay } from 'vs/base/common/symbols';\n\n\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a listener is GC'ed without having been disposed. This is a LEAK.\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableListenerGCedWarning = false\n\t// || Boolean(\"TRUE\") // causes a linter warning so that it cannot be pushed\n\t;\n\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever an emitter with listeners is disposed. That is a sign of code smell.\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableDisposeWithListenerWarning = false\n\t// || Boolean(\"TRUE\") // causes a linter warning so that it cannot be pushed\n\t;\n\n\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a snapshotted event is used repeatedly without cleanup.\n// See https://github.com/microsoft/vscode/issues/142851\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableSnapshotPotentialLeakWarning = false\n\t// || Boolean(\"TRUE\") // causes a linter warning so that it cannot be pushed\n\t;\n\n/**\n * An event with zero or one parameters that can be subscribed to. The event is a function itself.\n */\nexport interface Event<T> {\n\t(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore): IDisposable;\n}\n\nexport namespace Event {\n\texport const None: Event<any> = () => Disposable.None;\n\n\tfunction _addLeakageTraceLogic(options: EmitterOptions) {\n\t\tif (_enableSnapshotPotentialLeakWarning) {\n\t\t\tconst { onDidAddListener: origListenerDidAdd } = options;\n\t\t\tconst stack = Stacktrace.create();\n\t\t\tlet count = 0;\n\t\t\toptions.onDidAddListener = () => {\n\t\t\t\tif (++count === 2) {\n\t\t\t\t\tconsole.warn('snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here');\n\t\t\t\t\tstack.print();\n\t\t\t\t}\n\t\t\t\torigListenerDidAdd?.();\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Given an event, returns another event which debounces calls and defers the listeners to a later task via a shared\n\t * `setTimeout`. The event is converted into a signal (`Event<void>`) to avoid additional object creation as a\n\t * result of merging events and to try prevent race conditions that could arise when using related deferred and\n\t * non-deferred events.\n\t *\n\t * This is useful for deferring non-critical work (eg. general UI updates) to ensure it does not block critical work\n\t * (eg. latency of keypress to text rendered).\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function defer(event: Event<unknown>, disposable?: DisposableStore): Event<void> {\n\t\treturn debounce<unknown, void>(event, () => void 0, 0, undefined, true, undefined, disposable);\n\t}\n\n\t/**\n\t * Given an event, returns another event which only fires once.\n\t *\n\t * @param event The event source for the new event.\n\t */\n\texport function once<T>(event: Event<T>): Event<T> {\n\t\treturn (listener, thisArgs = null, disposables?) => {\n\t\t\t// we need this, in case the event fires during the listener call\n\t\t\tlet didFire = false;\n\t\t\tlet result: IDisposable | undefined = undefined;\n\t\t\tresult = event(e => {\n\t\t\t\tif (didFire) {\n\t\t\t\t\treturn;\n\t\t\t\t} else if (result) {\n\t\t\t\t\tresult.dispose();\n\t\t\t\t} else {\n\t\t\t\t\tdidFire = true;\n\t\t\t\t}\n\n\t\t\t\treturn listener.call(thisArgs, e);\n\t\t\t}, null, disposables);\n\n\t\t\tif (didFire) {\n\t\t\t\tresult.dispose();\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\t}\n\n\t/**\n\t * Maps an event of one type into an event of another type using a mapping function, similar to how\n\t * `Array.prototype.map` works.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param map The mapping function.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function map<I, O>(event: Event<I>, map: (i: I) => O, disposable?: DisposableStore): Event<O> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(i => listener.call(thisArgs, map(i)), null, disposables), disposable);\n\t}\n\n\t/**\n\t * Wraps an event in another event that performs some function on the event object before firing.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param each The function to perform on the event object.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function forEach<I>(event: Event<I>, each: (i: I) => void, disposable?: DisposableStore): Event<I> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables), disposable);\n\t}\n\n\t/**\n\t * Wraps an event in another event that fires only when some condition is met.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param filter The filter function that defines the condition. The event will fire for the object if this function\n\t * returns true.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function filter<T, U>(event: Event<T | U>, filter: (e: T | U) => e is T, disposable?: DisposableStore): Event<T>;\n\texport function filter<T>(event: Event<T>, filter: (e: T) => boolean, disposable?: DisposableStore): Event<T>;\n\texport function filter<T, R>(event: Event<T | R>, filter: (e: T | R) => e is R, disposable?: DisposableStore): Event<R>;\n\texport function filter<T>(event: Event<T>, filter: (e: T) => boolean, disposable?: DisposableStore): Event<T> {\n\t\treturn snapshot((listener, thisArgs = null, disposables?) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables), disposable);\n\t}\n\n\t/**\n\t * Given an event, returns the same event but typed as `Event<void>`.\n\t */\n\texport function signal<T>(event: Event<T>): Event<void> {\n\t\treturn event as Event<any> as Event<void>;\n\t}\n\n\t/**\n\t * Given a collection of events, returns a single event which emits whenever any of the provided events emit.\n\t */\n\texport function any<T>(...events: Event<T>[]): Event<T>;\n\texport function any(...events: Event<any>[]): Event<void>;\n\texport function any<T>(...events: Event<T>[]): Event<T> {\n\t\treturn (listener, thisArgs = null, disposables?) => {\n\t\t\tconst disposable = combinedDisposable(...events.map(event => event(e => listener.call(thisArgs, e))));\n\t\t\treturn addAndReturnDisposable(disposable, disposables);\n\t\t};\n\t}\n\n\t/**\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t */\n\texport function reduce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, initial?: O, disposable?: DisposableStore): Event<O> {\n\t\tlet output: O | undefined = initial;\n\n\t\treturn map<I, O>(event, e => {\n\t\t\toutput = merge(output, e);\n\t\t\treturn output;\n\t\t}, disposable);\n\t}\n\n\tfunction snapshot<T>(event: Event<T>, disposable: DisposableStore | undefined): Event<T> {\n\t\tlet listener: IDisposable | undefined;\n\n\t\tconst options: EmitterOptions | undefined = {\n\t\t\tonWillAddFirstListener() {\n\t\t\t\tlistener = event(emitter.fire, emitter);\n\t\t\t},\n\t\t\tonDidRemoveLastListener() {\n\t\t\t\tlistener?.dispose();\n\t\t\t}\n\t\t};\n\n\t\tif (!disposable) {\n\t\t\t_addLeakageTraceLogic(options);\n\t\t}\n\n\t\tconst emitter = new Emitter<T>(options);\n\n\t\tdisposable?.add(emitter);\n\n\t\treturn emitter.event;\n\t}\n\n\t/**\n\t * Adds the IDisposable to the store if it's set, and returns it. Useful to\n\t * Event function implementation.\n\t */\n\tfunction addAndReturnDisposable<T extends IDisposable>(d: T, store: DisposableStore | IDisposable[] | undefined): T {\n\t\tif (store instanceof Array) {\n\t\t\tstore.push(d);\n\t\t} else if (store) {\n\t\t\tstore.add(d);\n\t\t}\n\t\treturn d;\n\t}\n\n\t/**\n\t * Given an event, creates a new emitter that event that will debounce events based on {@link delay} and give an\n\t * array event object of all events that fired.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The original event to debounce.\n\t * @param merge A function that reduces all events into a single event.\n\t * @param delay The number of milliseconds to debounce.\n\t * @param leading Whether to fire a leading event without debouncing.\n\t * @param flushOnListenerRemove Whether to fire all debounced events when a listener is removed. If this is not\n\t * specified, some events could go missing. Use this if it's important that all events are processed, even if the\n\t * listener gets disposed before the debounced event fires.\n\t * @param leakWarningThreshold See {@link EmitterOptions.leakWarningThreshold}.\n\t * @param disposable A disposable store to register the debounce emitter to.\n\t */\n\texport function debounce<T>(event: Event<T>, merge: (last: T | undefined, event: T) => T, delay?: number | typeof MicrotaskDelay, leading?: boolean, flushOnListenerRemove?: boolean, leakWarningThreshold?: number, disposable?: DisposableStore): Event<T>;\n\texport function debounce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, delay?: number | typeof MicrotaskDelay, leading?: boolean, flushOnListenerRemove?: boolean, leakWarningThreshold?: number, disposable?: DisposableStore): Event<O>;\n\texport function debounce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, delay: number | typeof MicrotaskDelay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold?: number, disposable?: DisposableStore): Event<O> {\n\t\tlet subscription: IDisposable;\n\t\tlet output: O | undefined = undefined;\n\t\tlet handle: any = undefined;\n\t\tlet numDebouncedCalls = 0;\n\t\tlet doFire: (() => void) | undefined;\n\n\t\tconst options: EmitterOptions | undefined = {\n\t\t\tleakWarningThreshold,\n\t\t\tonWillAddFirstListener() {\n\t\t\t\tsubscription = event(cur => {\n\t\t\t\t\tnumDebouncedCalls++;\n\t\t\t\t\toutput = merge(output, cur);\n\n\t\t\t\t\tif (leading && !handle) {\n\t\t\t\t\t\temitter.fire(output);\n\t\t\t\t\t\toutput = undefined;\n\t\t\t\t\t}\n\n\t\t\t\t\tdoFire = () => {\n\t\t\t\t\t\tconst _output = output;\n\t\t\t\t\t\toutput = undefined;\n\t\t\t\t\t\thandle = undefined;\n\t\t\t\t\t\tif (!leading || numDebouncedCalls > 1) {\n\t\t\t\t\t\t\temitter.fire(_output!);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnumDebouncedCalls = 0;\n\t\t\t\t\t};\n\n\t\t\t\t\tif (typeof delay === 'number') {\n\t\t\t\t\t\tclearTimeout(handle);\n\t\t\t\t\t\thandle = setTimeout(doFire, delay);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (handle === undefined) {\n\t\t\t\t\t\t\thandle = 0;\n\t\t\t\t\t\t\tqueueMicrotask(doFire);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\tonWillRemoveListener() {\n\t\t\t\tif (flushOnListenerRemove && numDebouncedCalls > 0) {\n\t\t\t\t\tdoFire?.();\n\t\t\t\t}\n\t\t\t},\n\t\t\tonDidRemoveLastListener() {\n\t\t\t\tdoFire = undefined;\n\t\t\t\tsubscription.dispose();\n\t\t\t}\n\t\t};\n\n\t\tif (!disposable) {\n\t\t\t_addLeakageTraceLogic(options);\n\t\t}\n\n\t\tconst emitter = new Emitter<O>(options);\n\n\t\tdisposable?.add(emitter);\n\n\t\treturn emitter.event;\n\t}\n\n\t/**\n\t * Debounces an event, firing after some delay (default=0) with an array of all event original objects.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t */\n\texport function accumulate<T>(event: Event<T>, delay: number = 0, disposable?: DisposableStore): Event<T[]> {\n\t\treturn Event.debounce<T, T[]>(event, (last, e) => {\n\t\t\tif (!last) {\n\t\t\t\treturn [e];\n\t\t\t}\n\t\t\tlast.push(e);\n\t\t\treturn last;\n\t\t}, delay, undefined, true, undefined, disposable);\n\t}\n\n\t/**\n\t * Filters an event such that some condition is _not_ met more than once in a row, effectively ensuring duplicate\n\t * event objects from different sources do not fire the same event object.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param equals The equality condition.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t *\n\t * @example\n\t * ```\n\t * // Fire only one time when a single window is opened or focused\n\t * Event.latch(Event.any(onDidOpenWindow, onDidFocusWindow))\n\t * ```\n\t */\n\texport function latch<T>(event: Event<T>, equals: (a: T, b: T) => boolean = (a, b) => a === b, disposable?: DisposableStore): Event<T> {\n\t\tlet firstCall = true;\n\t\tlet cache: T;\n\n\t\treturn filter(event, value => {\n\t\t\tconst shouldEmit = firstCall || !equals(value, cache);\n\t\t\tfirstCall = false;\n\t\t\tcache = value;\n\t\t\treturn shouldEmit;\n\t\t}, disposable);\n\t}\n\n\t/**\n\t * Splits an event whose parameter is a union type into 2 separate events for each type in the union.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @example\n\t * ```\n\t * const event = new EventEmitter<number | undefined>().event;\n\t * const [numberEvent, undefinedEvent] = Event.split(event, isUndefined);\n\t * ```\n\t *\n\t * @param event The event source for the new event.\n\t * @param isT A function that determines what event is of the first type.\n\t * @param disposable A disposable store to add the new EventEmitter to.\n\t */\n\texport function split<T, U>(event: Event<T | U>, isT: (e: T | U) => e is T, disposable?: DisposableStore): [Event<T>, Event<U>] {\n\t\treturn [\n\t\t\tEvent.filter(event, isT, disposable),\n\t\t\tEvent.filter(event, e => !isT(e), disposable) as Event<U>,\n\t\t];\n\t}\n\n\t/**\n\t * Buffers an event until it has a listener attached.\n\t *\n\t * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n\t * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n\t * returned event causes this utility to leak a listener on the original event.\n\t *\n\t * @param event The event source for the new event.\n\t * @param flushAfterTimeout Determines whether to flush the buffer after a timeout immediately or after a\n\t * `setTimeout` when the first event listener is added.\n\t * @param _buffer Internal: A source event array used for tests.\n\t *\n\t * @example\n\t * ```\n\t * // Start accumulating events, when the first listener is attached, flush\n\t * // the event after a timeout such that multiple listeners attached before\n\t * // the timeout would receive the event\n\t * this.onInstallExtension = Event.buffer(service.onInstallExtension, true);\n\t * ```\n\t */\n\texport function buffer<T>(event: Event<T>, flushAfterTimeout = false, _buffer: T[] = [], disposable?: DisposableStore): Event<T> {\n\t\tlet buffer: T[] | null = _buffer.slice();\n\n\t\tlet listener: IDisposable | null = event(e => {\n\t\t\tif (buffer) {\n\t\t\t\tbuffer.push(e);\n\t\t\t} else {\n\t\t\t\temitter.fire(e);\n\t\t\t}\n\t\t});\n\n\t\tif (disposable) {\n\t\t\tdisposable.add(listener);\n\t\t}\n\n\t\tconst flush = () => {\n\t\t\tbuffer?.forEach(e => emitter.fire(e));\n\t\t\tbuffer = null;\n\t\t};\n\n\t\tconst emitter = new Emitter<T>({\n\t\t\tonWillAddFirstListener() {\n\t\t\t\tif (!listener) {\n\t\t\t\t\tlistener = event(e => emitter.fire(e));\n\t\t\t\t\tif (disposable) {\n\t\t\t\t\t\tdisposable.add(listener);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonDidAddFirstListener() {\n\t\t\t\tif (buffer) {\n\t\t\t\t\tif (flushAfterTimeout) {\n\t\t\t\t\t\tsetTimeout(flush);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflush();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonDidRemoveLastListener() {\n\t\t\t\tif (listener) {\n\t\t\t\t\tlistener.dispose();\n\t\t\t\t}\n\t\t\t\tlistener = null;\n\t\t\t}\n\t\t});\n\n\t\tif (disposable) {\n\t\t\tdisposable.add(emitter);\n\t\t}\n\n\t\treturn emitter.event;\n\t}\n\t/**\n\t * Wraps the event in an {@link IChainableEvent}, allowing a more functional programming style.\n\t *\n\t * @example\n\t * ```\n\t * // Normal\n\t * const onEnterPressNormal = Event.filter(\n\t *   Event.map(onKeyPress.event, e => new StandardKeyboardEvent(e)),\n\t *   e.keyCode === KeyCode.Enter\n\t * ).event;\n\t *\n\t * // Using chain\n\t * const onEnterPressChain = Event.chain(onKeyPress.event, $ => $\n\t *   .map(e => new StandardKeyboardEvent(e))\n\t *   .filter(e => e.keyCode === KeyCode.Enter)\n\t * );\n\t * ```\n\t */\n\texport function chain<T, R>(event: Event<T>, sythensize: ($: IChainableSythensis<T>) => IChainableSythensis<R>): Event<R> {\n\t\tconst fn: Event<R> = (listener, thisArgs, disposables) => {\n\t\t\tconst cs = sythensize(new ChainableSynthesis()) as ChainableSynthesis;\n\t\t\treturn event(function (value) {\n\t\t\t\tconst result = cs.evaluate(value);\n\t\t\t\tif (result !== HaltChainable) {\n\t\t\t\t\tlistener.call(thisArgs, result);\n\t\t\t\t}\n\t\t\t}, undefined, disposables);\n\t\t};\n\n\t\treturn fn;\n\t}\n\n\tconst HaltChainable = Symbol('HaltChainable');\n\n\tclass ChainableSynthesis implements IChainableSythensis<any> {\n\t\tprivate readonly steps: ((input: any) => any)[] = [];\n\n\t\tmap<O>(fn: (i: any) => O): this {\n\t\t\tthis.steps.push(fn);\n\t\t\treturn this;\n\t\t}\n\n\t\tforEach(fn: (i: any) => void): this {\n\t\t\tthis.steps.push(v => {\n\t\t\t\tfn(v);\n\t\t\t\treturn v;\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\n\t\tfilter(fn: (e: any) => boolean): this {\n\t\t\tthis.steps.push(v => fn(v) ? v : HaltChainable);\n\t\t\treturn this;\n\t\t}\n\n\t\treduce<R>(merge: (last: R | undefined, event: any) => R, initial?: R | undefined): this {\n\t\t\tlet last = initial;\n\t\t\tthis.steps.push(v => {\n\t\t\t\tlast = merge(last, v);\n\t\t\t\treturn last;\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\n\t\tlatch(equals: (a: any, b: any) => boolean = (a, b) => a === b): ChainableSynthesis {\n\t\t\tlet firstCall = true;\n\t\t\tlet cache: any;\n\t\t\tthis.steps.push(value => {\n\t\t\t\tconst shouldEmit = firstCall || !equals(value, cache);\n\t\t\t\tfirstCall = false;\n\t\t\t\tcache = value;\n\t\t\t\treturn shouldEmit ? value : HaltChainable;\n\t\t\t});\n\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic evaluate(value: any) {\n\t\t\tfor (const step of this.steps) {\n\t\t\t\tvalue = step(value);\n\t\t\t\tif (value === HaltChainable) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\t}\n\n\texport interface IChainableSythensis<T> {\n\t\tmap<O>(fn: (i: T) => O): IChainableSythensis<O>;\n\t\tforEach(fn: (i: T) => void): IChainableSythensis<T>;\n\t\tfilter<R extends T>(fn: (e: T) => e is R): IChainableSythensis<R>;\n\t\tfilter(fn: (e: T) => boolean): IChainableSythensis<T>;\n\t\treduce<R>(merge: (last: R, event: T) => R, initial: R): IChainableSythensis<R>;\n\t\treduce<R>(merge: (last: R | undefined, event: T) => R): IChainableSythensis<R>;\n\t\tlatch(equals?: (a: T, b: T) => boolean): IChainableSythensis<T>;\n\t}\n\n\texport interface NodeEventEmitter {\n\t\ton(event: string | symbol, listener: Function): unknown;\n\t\tremoveListener(event: string | symbol, listener: Function): unknown;\n\t}\n\n\t/**\n\t * Creates an {@link Event} from a node event emitter.\n\t */\n\texport function fromNodeEventEmitter<T>(emitter: NodeEventEmitter, eventName: string, map: (...args: any[]) => T = id => id): Event<T> {\n\t\tconst fn = (...args: any[]) => result.fire(map(...args));\n\t\tconst onFirstListenerAdd = () => emitter.on(eventName, fn);\n\t\tconst onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n\t\tconst result = new Emitter<T>({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\n\n\t\treturn result.event;\n\t}\n\n\texport interface DOMEventEmitter {\n\t\taddEventListener(event: string | symbol, listener: Function): void;\n\t\tremoveEventListener(event: string | symbol, listener: Function): void;\n\t}\n\n\t/**\n\t * Creates an {@link Event} from a DOM event emitter.\n\t */\n\texport function fromDOMEventEmitter<T>(emitter: DOMEventEmitter, eventName: string, map: (...args: any[]) => T = id => id): Event<T> {\n\t\tconst fn = (...args: any[]) => result.fire(map(...args));\n\t\tconst onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\n\t\tconst onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\n\t\tconst result = new Emitter<T>({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\n\n\t\treturn result.event;\n\t}\n\n\t/**\n\t * Creates a promise out of an event, using the {@link Event.once} helper.\n\t */\n\texport function toPromise<T>(event: Event<T>): Promise<T> {\n\t\treturn new Promise(resolve => once(event)(resolve));\n\t}\n\n\t/**\n\t * Creates an event out of a promise that fires once when the promise is\n\t * resolved with the result of the promise or `undefined`.\n\t */\n\texport function fromPromise<T>(promise: Promise<T>): Event<T | undefined> {\n\t\tconst result = new Emitter<T | undefined>();\n\n\t\tpromise.then(res => {\n\t\t\tresult.fire(res);\n\t\t}, () => {\n\t\t\tresult.fire(undefined);\n\t\t}).finally(() => {\n\t\t\tresult.dispose();\n\t\t});\n\n\t\treturn result.event;\n\t}\n\n\t/**\n\t * A convenience function for forwarding an event to another emitter which\n\t * improves readability.allows Event.forward(event, emitter) instead of `event(e => emitter.fire(e))`.\n\t * @param from The event to forward.\n\t * @param to The emitter to forward the event to.\n\t * @example\n\t * Event.forward(event, emitter);\n\t * // equivalent to\n\t * event(e => emitter.fire(e));\n\t * // equivalent to\n\t * event(emitter.fire, emitter);\n\t */\n\texport function forward<T>(from: Event<T>, to: Emitter<T>): IDisposable {\n\t\treturn from(e => to.fire(e));\n\t}\n\n\t/**\n\t * Adds a listener to an event and calls the listener immediately with undefined as the event object.\n\t *\n\t * @example\n\t * ```\n\t * // Initialize the UI and update it when dataChangeEvent fires\n\t * runAndSubscribe(dataChangeEvent, () => this._updateUI());\n\t * ```\n\t */\n\texport function runAndSubscribe<T>(event: Event<T>, handler: (e: T) => any, initial: T): IDisposable;\n\texport function runAndSubscribe<T>(event: Event<T>, handler: (e: T | undefined) => any): IDisposable;\n\texport function runAndSubscribe<T>(event: Event<T>, handler: (e: T | undefined) => any, initial?: T): IDisposable {\n\t\thandler(initial);\n\t\treturn event(e => handler(e));\n\t}\n\n\tclass EmitterObserver<T> implements IObserver {\n\n\t\treadonly emitter: Emitter<T>;\n\n\t\tprivate _counter = 0;\n\t\tprivate _hasChanged = false;\n\n\t\tconstructor(readonly _observable: IObservable<T, any>, store: DisposableStore | undefined) {\n\t\t\tconst options: EmitterOptions = {\n\t\t\t\tonWillAddFirstListener: () => {\n\t\t\t\t\t_observable.addObserver(this);\n\t\t\t\t},\n\t\t\t\tonDidRemoveLastListener: () => {\n\t\t\t\t\t_observable.removeObserver(this);\n\t\t\t\t}\n\t\t\t};\n\t\t\tif (!store) {\n\t\t\t\t_addLeakageTraceLogic(options);\n\t\t\t}\n\t\t\tthis.emitter = new Emitter<T>(options);\n\t\t\tif (store) {\n\t\t\t\tstore.add(this.emitter);\n\t\t\t}\n\t\t}\n\n\t\tbeginUpdate<T>(_observable: IObservable<T, void>): void {\n\t\t\t// assert(_observable === this.obs);\n\t\t\tthis._counter++;\n\t\t}\n\n\t\thandlePossibleChange<T>(_observable: IObservable<T, unknown>): void {\n\t\t\t// assert(_observable === this.obs);\n\t\t}\n\n\t\thandleChange<T, TChange>(_observable: IObservable<T, TChange>, _change: TChange): void {\n\t\t\t// assert(_observable === this.obs);\n\t\t\tthis._hasChanged = true;\n\t\t}\n\n\t\tendUpdate<T>(_observable: IObservable<T, void>): void {\n\t\t\t// assert(_observable === this.obs);\n\t\t\tthis._counter--;\n\t\t\tif (this._counter === 0) {\n\t\t\t\tthis._observable.reportChanges();\n\t\t\t\tif (this._hasChanged) {\n\t\t\t\t\tthis._hasChanged = false;\n\t\t\t\t\tthis.emitter.fire(this._observable.get());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Creates an event emitter that is fired when the observable changes.\n\t * Each listeners subscribes to the emitter.\n\t */\n\texport function fromObservable<T>(obs: IObservable<T, any>, store?: DisposableStore): Event<T> {\n\t\tconst observer = new EmitterObserver(obs, store);\n\t\treturn observer.emitter.event;\n\t}\n\n\t/**\n\t * Each listener is attached to the observable directly.\n\t */\n\texport function fromObservableLight(observable: IObservable<any>): Event<void> {\n\t\treturn (listener, thisArgs, disposables) => {\n\t\t\tlet count = 0;\n\t\t\tlet didChange = false;\n\t\t\tconst observer: IObserver = {\n\t\t\t\tbeginUpdate() {\n\t\t\t\t\tcount++;\n\t\t\t\t},\n\t\t\t\tendUpdate() {\n\t\t\t\t\tcount--;\n\t\t\t\t\tif (count === 0) {\n\t\t\t\t\t\tobservable.reportChanges();\n\t\t\t\t\t\tif (didChange) {\n\t\t\t\t\t\t\tdidChange = false;\n\t\t\t\t\t\t\tlistener.call(thisArgs);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\thandlePossibleChange() {\n\t\t\t\t\t// noop\n\t\t\t\t},\n\t\t\t\thandleChange() {\n\t\t\t\t\tdidChange = true;\n\t\t\t\t}\n\t\t\t};\n\t\t\tobservable.addObserver(observer);\n\t\t\tobservable.reportChanges();\n\t\t\tconst disposable = {\n\t\t\t\tdispose() {\n\t\t\t\t\tobservable.removeObserver(observer);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (disposables instanceof DisposableStore) {\n\t\t\t\tdisposables.add(disposable);\n\t\t\t} else if (Array.isArray(disposables)) {\n\t\t\t\tdisposables.push(disposable);\n\t\t\t}\n\n\t\t\treturn disposable;\n\t\t};\n\t}\n}\n\nexport interface EmitterOptions {\n\t/**\n\t * Optional function that's called *before* the very first listener is added\n\t */\n\tonWillAddFirstListener?: Function;\n\t/**\n\t * Optional function that's called *after* the very first listener is added\n\t */\n\tonDidAddFirstListener?: Function;\n\t/**\n\t * Optional function that's called after a listener is added\n\t */\n\tonDidAddListener?: Function;\n\t/**\n\t * Optional function that's called *after* remove the very last listener\n\t */\n\tonDidRemoveLastListener?: Function;\n\t/**\n\t * Optional function that's called *before* a listener is removed\n\t */\n\tonWillRemoveListener?: Function;\n\t/**\n\t * Optional function that's called when a listener throws an error. Defaults to\n\t * {@link onUnexpectedError}\n\t */\n\tonListenerError?: (e: any) => void;\n\t/**\n\t * Number of listeners that are allowed before assuming a leak. Default to\n\t * a globally configured value\n\t *\n\t * @see setGlobalLeakWarningThreshold\n\t */\n\tleakWarningThreshold?: number;\n\t/**\n\t * Pass in a delivery queue, which is useful for ensuring\n\t * in order event delivery across multiple emitters.\n\t */\n\tdeliveryQueue?: EventDeliveryQueue;\n\n\t/** ONLY enable this during development */\n\t_profName?: string;\n}\n\n\nexport class EventProfiling {\n\n\tstatic readonly all = new Set<EventProfiling>();\n\n\tprivate static _idPool = 0;\n\n\treadonly name: string;\n\tpublic listenerCount: number = 0;\n\tpublic invocationCount = 0;\n\tpublic elapsedOverall = 0;\n\tpublic durations: number[] = [];\n\n\tprivate _stopWatch?: StopWatch;\n\n\tconstructor(name: string) {\n\t\tthis.name = `${name}_${EventProfiling._idPool++}`;\n\t\tEventProfiling.all.add(this);\n\t}\n\n\tstart(listenerCount: number): void {\n\t\tthis._stopWatch = new StopWatch();\n\t\tthis.listenerCount = listenerCount;\n\t}\n\n\tstop(): void {\n\t\tif (this._stopWatch) {\n\t\t\tconst elapsed = this._stopWatch.elapsed();\n\t\t\tthis.durations.push(elapsed);\n\t\t\tthis.elapsedOverall += elapsed;\n\t\t\tthis.invocationCount += 1;\n\t\t\tthis._stopWatch = undefined;\n\t\t}\n\t}\n}\n\nlet _globalLeakWarningThreshold = -1;\nexport function setGlobalLeakWarningThreshold(n: number): IDisposable {\n\tconst oldValue = _globalLeakWarningThreshold;\n\t_globalLeakWarningThreshold = n;\n\treturn {\n\t\tdispose() {\n\t\t\t_globalLeakWarningThreshold = oldValue;\n\t\t}\n\t};\n}\n\nclass LeakageMonitor {\n\n\tprivate static _idPool = 1;\n\n\tprivate _stacks: Map<string, number> | undefined;\n\tprivate _warnCountdown: number = 0;\n\n\tconstructor(\n\t\tprivate readonly _errorHandler: (err: Error) => void,\n\t\treadonly threshold: number,\n\t\treadonly name: string = (LeakageMonitor._idPool++).toString(16).padStart(3, '0')\n\t) { }\n\n\tdispose(): void {\n\t\tthis._stacks?.clear();\n\t}\n\n\tcheck(stack: Stacktrace, listenerCount: number): undefined | (() => void) {\n\n\t\tconst threshold = this.threshold;\n\t\tif (threshold <= 0 || listenerCount < threshold) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (!this._stacks) {\n\t\t\tthis._stacks = new Map();\n\t\t}\n\t\tconst count = (this._stacks.get(stack.value) || 0);\n\t\tthis._stacks.set(stack.value, count + 1);\n\t\tthis._warnCountdown -= 1;\n\n\t\tif (this._warnCountdown <= 0) {\n\t\t\t// only warn on first exceed and then every time the limit\n\t\t\t// is exceeded by 50% again\n\t\t\tthis._warnCountdown = threshold * 0.5;\n\n\t\t\tconst [topStack, topCount] = this.getMostFrequentStack()!;\n\t\t\tconst message = `[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`;\n\t\t\tconsole.warn(message);\n\t\t\tconsole.warn(topStack!);\n\n\t\t\tconst error = new ListenerLeakError(message, topStack);\n\t\t\tthis._errorHandler(error);\n\t\t}\n\n\t\treturn () => {\n\t\t\tconst count = (this._stacks!.get(stack.value) || 0);\n\t\t\tthis._stacks!.set(stack.value, count - 1);\n\t\t};\n\t}\n\n\tgetMostFrequentStack(): [string, number] | undefined {\n\t\tif (!this._stacks) {\n\t\t\treturn undefined;\n\t\t}\n\t\tlet topStack: [string, number] | undefined;\n\t\tlet topCount: number = 0;\n\t\tfor (const [stack, count] of this._stacks) {\n\t\t\tif (!topStack || topCount < count) {\n\t\t\t\ttopStack = [stack, count];\n\t\t\t\ttopCount = count;\n\t\t\t}\n\t\t}\n\t\treturn topStack;\n\t}\n}\n\nclass Stacktrace {\n\n\tstatic create() {\n\t\tconst err = new Error();\n\t\treturn new Stacktrace(err.stack ?? '');\n\t}\n\n\tprivate constructor(readonly value: string) { }\n\n\tprint() {\n\t\tconsole.warn(this.value.split('\\n').slice(2).join('\\n'));\n\t}\n}\n\n// error that is logged when going over the configured listener threshold\nexport class ListenerLeakError extends Error {\n\tconstructor(message: string, stack: string) {\n\t\tsuper(message);\n\t\tthis.name = 'ListenerLeakError';\n\t\tthis.stack = stack;\n\t}\n}\n\n// SEVERE error that is logged when having gone way over the configured listener\n// threshold so that the emitter refuses to accept more listeners\nexport class ListenerRefusalError extends Error {\n\tconstructor(message: string, stack: string) {\n\t\tsuper(message);\n\t\tthis.name = 'ListenerRefusalError';\n\t\tthis.stack = stack;\n\t}\n}\n\nlet id = 0;\nclass UniqueContainer<T> {\n\tstack?: Stacktrace;\n\tpublic id = id++;\n\tconstructor(public readonly value: T) { }\n}\nconst compactionThreshold = 2;\n\ntype ListenerContainer<T> = UniqueContainer<(data: T) => void>;\ntype ListenerOrListeners<T> = (ListenerContainer<T> | undefined)[] | ListenerContainer<T>;\n\nconst forEachListener = <T>(listeners: ListenerOrListeners<T>, fn: (c: ListenerContainer<T>) => void) => {\n\tif (listeners instanceof UniqueContainer) {\n\t\tfn(listeners);\n\t} else {\n\t\tfor (let i = 0; i < listeners.length; i++) {\n\t\t\tconst l = listeners[i];\n\t\t\tif (l) {\n\t\t\t\tfn(l);\n\t\t\t}\n\t\t}\n\t}\n};\n\n\nlet _listenerFinalizers: FinalizationRegistry<string> | undefined;\n\nif (_enableListenerGCedWarning) {\n\tconst leaks: string[] = [];\n\n\tsetInterval(() => {\n\t\tif (leaks.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tconsole.warn('[LEAKING LISTENERS] GC\\'ed these listeners that were NOT yet disposed:');\n\t\tconsole.warn(leaks.join('\\n'));\n\t\tleaks.length = 0;\n\t}, 3000);\n\n\t_listenerFinalizers = new FinalizationRegistry(heldValue => {\n\t\tif (typeof heldValue === 'string') {\n\t\t\tleaks.push(heldValue);\n\t\t}\n\t});\n}\n\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n\tclass Document {\n\n\t\tprivate readonly _onDidChange = new Emitter<(value:string)=>any>();\n\n\t\tpublic onDidChange = this._onDidChange.event;\n\n\t\t// getter-style\n\t\t// get onDidChange(): Event<(value:string)=>any> {\n\t\t// \treturn this._onDidChange.event;\n\t\t// }\n\n\t\tprivate _doIt() {\n\t\t\t//...\n\t\t\tthis._onDidChange.fire(value);\n\t\t}\n\t}\n */\nexport class Emitter<T> {\n\n\tprivate readonly _options?: EmitterOptions;\n\tprivate readonly _leakageMon?: LeakageMonitor;\n\tprivate readonly _perfMon?: EventProfiling;\n\tprivate _disposed?: true;\n\tprivate _event?: Event<T>;\n\n\t/**\n\t * A listener, or list of listeners. A single listener is the most common\n\t * for event emitters (#185789), so we optimize that special case to avoid\n\t * wrapping it in an array (just like Node.js itself.)\n\t *\n\t * A list of listeners never 'downgrades' back to a plain function if\n\t * listeners are removed, for two reasons:\n\t *\n\t *  1. That's complicated (especially with the deliveryQueue)\n\t *  2. A listener with >1 listener is likely to have >1 listener again at\n\t *     some point, and swapping between arrays and functions may[citation needed]\n\t *     introduce unnecessary work and garbage.\n\t *\n\t * The array listeners can be 'sparse', to avoid reallocating the array\n\t * whenever any listener is added or removed. If more than `1 / compactionThreshold`\n\t * of the array is empty, only then is it resized.\n\t */\n\tprotected _listeners?: ListenerOrListeners<T>;\n\n\t/**\n\t * Always to be defined if _listeners is an array. It's no longer a true\n\t * queue, but holds the dispatching 'state'. If `fire()` is called on an\n\t * emitter, any work left in the _deliveryQueue is finished first.\n\t */\n\tprivate _deliveryQueue?: EventDeliveryQueuePrivate;\n\tprotected _size = 0;\n\n\tconstructor(options?: EmitterOptions) {\n\t\tthis._options = options;\n\t\tthis._leakageMon = (_globalLeakWarningThreshold > 0 || this._options?.leakWarningThreshold)\n\t\t\t? new LeakageMonitor(options?.onListenerError ?? onUnexpectedError, this._options?.leakWarningThreshold ?? _globalLeakWarningThreshold) :\n\t\t\tundefined;\n\t\tthis._perfMon = this._options?._profName ? new EventProfiling(this._options._profName) : undefined;\n\t\tthis._deliveryQueue = this._options?.deliveryQueue as EventDeliveryQueuePrivate | undefined;\n\t}\n\n\tdispose() {\n\t\tif (!this._disposed) {\n\t\t\tthis._disposed = true;\n\n\t\t\t// It is bad to have listeners at the time of disposing an emitter, it is worst to have listeners keep the emitter\n\t\t\t// alive via the reference that's embedded in their disposables. Therefore we loop over all remaining listeners and\n\t\t\t// unset their subscriptions/disposables. Looping and blaming remaining listeners is done on next tick because the\n\t\t\t// the following programming pattern is very popular:\n\t\t\t//\n\t\t\t// const someModel = this._disposables.add(new ModelObject()); // (1) create and register model\n\t\t\t// this._disposables.add(someModel.onDidChange(() => { ... }); // (2) subscribe and register model-event listener\n\t\t\t// ...later...\n\t\t\t// this._disposables.dispose(); disposes (1) then (2): don't warn after (1) but after the \"overall dispose\" is done\n\n\t\t\tif (this._deliveryQueue?.current === this) {\n\t\t\t\tthis._deliveryQueue.reset();\n\t\t\t}\n\t\t\tif (this._listeners) {\n\t\t\t\tif (_enableDisposeWithListenerWarning) {\n\t\t\t\t\tconst listeners = this._listeners;\n\t\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\t\tforEachListener(listeners, l => l.stack?.print());\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tthis._listeners = undefined;\n\t\t\t\tthis._size = 0;\n\t\t\t}\n\t\t\tthis._options?.onDidRemoveLastListener?.();\n\t\t\tthis._leakageMon?.dispose();\n\t\t}\n\t}\n\n\t/**\n\t * For the public to allow to subscribe\n\t * to events from this Emitter\n\t */\n\tget event(): Event<T> {\n\t\tthis._event ??= (callback: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore) => {\n\t\t\tif (this._leakageMon && this._size > this._leakageMon.threshold ** 2) {\n\t\t\t\tconst message = `[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far (${this._size} vs ${this._leakageMon.threshold})`;\n\t\t\t\tconsole.warn(message);\n\n\t\t\t\tconst tuple = this._leakageMon.getMostFrequentStack() ?? ['UNKNOWN stack', -1];\n\t\t\t\tconst error = new ListenerRefusalError(`${message}. HINT: Stack shows most frequent listener (${tuple[1]}-times)`, tuple[0]);\n\t\t\t\tconst errorHandler = this._options?.onListenerError || onUnexpectedError;\n\t\t\t\terrorHandler(error);\n\n\t\t\t\treturn Disposable.None;\n\t\t\t}\n\n\t\t\tif (this._disposed) {\n\t\t\t\t// todo: should we warn if a listener is added to a disposed emitter? This happens often\n\t\t\t\treturn Disposable.None;\n\t\t\t}\n\n\t\t\tif (thisArgs) {\n\t\t\t\tcallback = callback.bind(thisArgs);\n\t\t\t}\n\n\t\t\tconst contained = new UniqueContainer(callback);\n\n\t\t\tlet removeMonitor: Function | undefined;\n\t\t\tlet stack: Stacktrace | undefined;\n\t\t\tif (this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2)) {\n\t\t\t\t// check and record this emitter for potential leakage\n\t\t\t\tcontained.stack = Stacktrace.create();\n\t\t\t\tremoveMonitor = this._leakageMon.check(contained.stack, this._size + 1);\n\t\t\t}\n\n\t\t\tif (_enableDisposeWithListenerWarning) {\n\t\t\t\tcontained.stack = stack ?? Stacktrace.create();\n\t\t\t}\n\n\t\t\tif (!this._listeners) {\n\t\t\t\tthis._options?.onWillAddFirstListener?.(this);\n\t\t\t\tthis._listeners = contained;\n\t\t\t\tthis._options?.onDidAddFirstListener?.(this);\n\t\t\t} else if (this._listeners instanceof UniqueContainer) {\n\t\t\t\tthis._deliveryQueue ??= new EventDeliveryQueuePrivate();\n\t\t\t\tthis._listeners = [this._listeners, contained];\n\t\t\t} else {\n\t\t\t\tthis._listeners.push(contained);\n\t\t\t}\n\n\t\t\tthis._size++;\n\n\n\t\t\tconst result = toDisposable(() => {\n\t\t\t\t_listenerFinalizers?.unregister(result);\n\t\t\t\tremoveMonitor?.();\n\t\t\t\tthis._removeListener(contained);\n\t\t\t});\n\t\t\tif (disposables instanceof DisposableStore) {\n\t\t\t\tdisposables.add(result);\n\t\t\t} else if (Array.isArray(disposables)) {\n\t\t\t\tdisposables.push(result);\n\t\t\t}\n\n\t\t\tif (_listenerFinalizers) {\n\t\t\t\tconst stack = new Error().stack!.split('\\n').slice(2, 3).join('\\n').trim();\n\t\t\t\tconst match = /(file:|vscode-file:\\/\\/vscode-app)?(\\/[^:]*:\\d+:\\d+)/.exec(stack);\n\t\t\t\t_listenerFinalizers.register(result, match?.[2] ?? stack, result);\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\n\t\treturn this._event;\n\t}\n\n\tprivate _removeListener(listener: ListenerContainer<T>) {\n\t\tthis._options?.onWillRemoveListener?.(this);\n\n\t\tif (!this._listeners) {\n\t\t\treturn; // expected if a listener gets disposed\n\t\t}\n\n\t\tif (this._size === 1) {\n\t\t\tthis._listeners = undefined;\n\t\t\tthis._options?.onDidRemoveLastListener?.(this);\n\t\t\tthis._size = 0;\n\t\t\treturn;\n\t\t}\n\n\t\t// size > 1 which requires that listeners be a list:\n\t\tconst listeners = this._listeners as (ListenerContainer<T> | undefined)[];\n\n\t\tconst index = listeners.indexOf(listener);\n\t\tif (index === -1) {\n\t\t\tconsole.log('disposed?', this._disposed);\n\t\t\tconsole.log('size?', this._size);\n\t\t\tconsole.log('arr?', JSON.stringify(this._listeners));\n\t\t\tthrow new Error('Attempted to dispose unknown listener');\n\t\t}\n\n\t\tthis._size--;\n\t\tlisteners[index] = undefined;\n\n\t\tconst adjustDeliveryQueue = this._deliveryQueue!.current === this;\n\t\tif (this._size * compactionThreshold <= listeners.length) {\n\t\t\tlet n = 0;\n\t\t\tfor (let i = 0; i < listeners.length; i++) {\n\t\t\t\tif (listeners[i]) {\n\t\t\t\t\tlisteners[n++] = listeners[i];\n\t\t\t\t} else if (adjustDeliveryQueue) {\n\t\t\t\t\tthis._deliveryQueue!.end--;\n\t\t\t\t\tif (n < this._deliveryQueue!.i) {\n\t\t\t\t\t\tthis._deliveryQueue!.i--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlisteners.length = n;\n\t\t}\n\t}\n\n\tprivate _deliver(listener: undefined | UniqueContainer<(value: T) => void>, value: T) {\n\t\tif (!listener) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst errorHandler = this._options?.onListenerError || onUnexpectedError;\n\t\tif (!errorHandler) {\n\t\t\tlistener.value(value);\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tlistener.value(value);\n\t\t} catch (e) {\n\t\t\terrorHandler(e);\n\t\t}\n\t}\n\n\t/** Delivers items in the queue. Assumes the queue is ready to go. */\n\tprivate _deliverQueue(dq: EventDeliveryQueuePrivate) {\n\t\tconst listeners = dq.current!._listeners! as (ListenerContainer<T> | undefined)[];\n\t\twhile (dq.i < dq.end) {\n\t\t\t// important: dq.i is incremented before calling deliver() because it might reenter deliverQueue()\n\t\t\tthis._deliver(listeners[dq.i++], dq.value as T);\n\t\t}\n\t\tdq.reset();\n\t}\n\n\t/**\n\t * To be kept private to fire an event to\n\t * subscribers\n\t */\n\tfire(event: T): void {\n\t\tif (this._deliveryQueue?.current) {\n\t\t\tthis._deliverQueue(this._deliveryQueue);\n\t\t\tthis._perfMon?.stop(); // last fire() will have starting perfmon, stop it before starting the next dispatch\n\t\t}\n\n\t\tthis._perfMon?.start(this._size);\n\n\t\tif (!this._listeners) {\n\t\t\t// no-op\n\t\t} else if (this._listeners instanceof UniqueContainer) {\n\t\t\tthis._deliver(this._listeners, event);\n\t\t} else {\n\t\t\tconst dq = this._deliveryQueue!;\n\t\t\tdq.enqueue(this, event, this._listeners.length);\n\t\t\tthis._deliverQueue(dq);\n\t\t}\n\n\t\tthis._perfMon?.stop();\n\t}\n\n\thasListeners(): boolean {\n\t\treturn this._size > 0;\n\t}\n}\n\nexport interface EventDeliveryQueue {\n\t_isEventDeliveryQueue: true;\n}\n\nexport const createEventDeliveryQueue = (): EventDeliveryQueue => new EventDeliveryQueuePrivate();\n\nclass EventDeliveryQueuePrivate implements EventDeliveryQueue {\n\tdeclare _isEventDeliveryQueue: true;\n\n\t/**\n\t * Index in current's listener list.\n\t */\n\tpublic i = -1;\n\n\t/**\n\t * The last index in the listener's list to deliver.\n\t */\n\tpublic end = 0;\n\n\t/**\n\t * Emitter currently being dispatched on. Emitter._listeners is always an array.\n\t */\n\tpublic current?: Emitter<any>;\n\t/**\n\t * Currently emitting value. Defined whenever `current` is.\n\t */\n\tpublic value?: unknown;\n\n\tpublic enqueue<T>(emitter: Emitter<T>, value: T, end: number) {\n\t\tthis.i = 0;\n\t\tthis.end = end;\n\t\tthis.current = emitter;\n\t\tthis.value = value;\n\t}\n\n\tpublic reset() {\n\t\tthis.i = this.end; // force any current emission loop to stop, mainly for during dispose\n\t\tthis.current = undefined;\n\t\tthis.value = undefined;\n\t}\n}\n\nexport interface IWaitUntil {\n\ttoken: CancellationToken;\n\twaitUntil(thenable: Promise<unknown>): void;\n}\n\nexport type IWaitUntilData<T> = Omit<Omit<T, 'waitUntil'>, 'token'>;\n\nexport class AsyncEmitter<T extends IWaitUntil> extends Emitter<T> {\n\n\tprivate _asyncDeliveryQueue?: LinkedList<[(ev: T) => void, IWaitUntilData<T>]>;\n\n\tasync fireAsync(data: IWaitUntilData<T>, token: CancellationToken, promiseJoin?: (p: Promise<unknown>, listener: Function) => Promise<unknown>): Promise<void> {\n\t\tif (!this._listeners) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this._asyncDeliveryQueue) {\n\t\t\tthis._asyncDeliveryQueue = new LinkedList();\n\t\t}\n\n\t\tforEachListener(this._listeners, listener => this._asyncDeliveryQueue!.push([listener.value, data]));\n\n\t\twhile (this._asyncDeliveryQueue.size > 0 && !token.isCancellationRequested) {\n\n\t\t\tconst [listener, data] = this._asyncDeliveryQueue.shift()!;\n\t\t\tconst thenables: Promise<unknown>[] = [];\n\n\t\t\tconst event = <T>{\n\t\t\t\t...data,\n\t\t\t\ttoken,\n\t\t\t\twaitUntil: (p: Promise<unknown>): void => {\n\t\t\t\t\tif (Object.isFrozen(thenables)) {\n\t\t\t\t\t\tthrow new Error('waitUntil can NOT be called asynchronous');\n\t\t\t\t\t}\n\t\t\t\t\tif (promiseJoin) {\n\t\t\t\t\t\tp = promiseJoin(p, listener);\n\t\t\t\t\t}\n\t\t\t\t\tthenables.push(p);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttry {\n\t\t\t\tlistener(event);\n\t\t\t} catch (e) {\n\t\t\t\tonUnexpectedError(e);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// freeze thenables-collection to enforce sync-calls to\n\t\t\t// wait until and then wait for all thenables to resolve\n\t\t\tObject.freeze(thenables);\n\n\t\t\tawait Promise.allSettled(thenables).then(values => {\n\t\t\t\tfor (const value of values) {\n\t\t\t\t\tif (value.status === 'rejected') {\n\t\t\t\t\t\tonUnexpectedError(value.reason);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n}\n\n\nexport class PauseableEmitter<T> extends Emitter<T> {\n\n\tprivate _isPaused = 0;\n\tprotected _eventQueue = new LinkedList<T>();\n\tprivate _mergeFn?: (input: T[]) => T;\n\n\tpublic get isPaused(): boolean {\n\t\treturn this._isPaused !== 0;\n\t}\n\n\tconstructor(options?: EmitterOptions & { merge?: (input: T[]) => T }) {\n\t\tsuper(options);\n\t\tthis._mergeFn = options?.merge;\n\t}\n\n\tpause(): void {\n\t\tthis._isPaused++;\n\t}\n\n\tresume(): void {\n\t\tif (this._isPaused !== 0 && --this._isPaused === 0) {\n\t\t\tif (this._mergeFn) {\n\t\t\t\t// use the merge function to create a single composite\n\t\t\t\t// event. make a copy in case firing pauses this emitter\n\t\t\t\tif (this._eventQueue.size > 0) {\n\t\t\t\t\tconst events = Array.from(this._eventQueue);\n\t\t\t\t\tthis._eventQueue.clear();\n\t\t\t\t\tsuper.fire(this._mergeFn(events));\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t// no merging, fire each event individually and test\n\t\t\t\t// that this emitter isn't paused halfway through\n\t\t\t\twhile (!this._isPaused && this._eventQueue.size !== 0) {\n\t\t\t\t\tsuper.fire(this._eventQueue.shift()!);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\toverride fire(event: T): void {\n\t\tif (this._size) {\n\t\t\tif (this._isPaused !== 0) {\n\t\t\t\tthis._eventQueue.push(event);\n\t\t\t} else {\n\t\t\t\tsuper.fire(event);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport class DebounceEmitter<T> extends PauseableEmitter<T> {\n\n\tprivate readonly _delay: number;\n\tprivate _handle: any | undefined;\n\n\tconstructor(options: EmitterOptions & { merge: (input: T[]) => T; delay?: number }) {\n\t\tsuper(options);\n\t\tthis._delay = options.delay ?? 100;\n\t}\n\n\toverride fire(event: T): void {\n\t\tif (!this._handle) {\n\t\t\tthis.pause();\n\t\t\tthis._handle = setTimeout(() => {\n\t\t\t\tthis._handle = undefined;\n\t\t\t\tthis.resume();\n\t\t\t}, this._delay);\n\t\t}\n\t\tsuper.fire(event);\n\t}\n}\n\n/**\n * An emitter which queue all events and then process them at the\n * end of the event loop.\n */\nexport class MicrotaskEmitter<T> extends Emitter<T> {\n\tprivate _queuedEvents: T[] = [];\n\tprivate _mergeFn?: (input: T[]) => T;\n\n\tconstructor(options?: EmitterOptions & { merge?: (input: T[]) => T }) {\n\t\tsuper(options);\n\t\tthis._mergeFn = options?.merge;\n\t}\n\toverride fire(event: T): void {\n\n\t\tif (!this.hasListeners()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._queuedEvents.push(event);\n\t\tif (this._queuedEvents.length === 1) {\n\t\t\tqueueMicrotask(() => {\n\t\t\t\tif (this._mergeFn) {\n\t\t\t\t\tsuper.fire(this._mergeFn(this._queuedEvents));\n\t\t\t\t} else {\n\t\t\t\t\tthis._queuedEvents.forEach(e => super.fire(e));\n\t\t\t\t}\n\t\t\t\tthis._queuedEvents = [];\n\t\t\t});\n\t\t}\n\t}\n}\n\n/**\n * An event emitter that multiplexes many events into a single event.\n *\n * @example Listen to the `onData` event of all `Thing`s, dynamically adding and removing `Thing`s\n * to the multiplexer as needed.\n *\n * ```typescript\n * const anythingDataMultiplexer = new EventMultiplexer<{ data: string }>();\n *\n * const thingListeners = DisposableMap<Thing, IDisposable>();\n *\n * thingService.onDidAddThing(thing => {\n *   thingListeners.set(thing, anythingDataMultiplexer.add(thing.onData);\n * });\n * thingService.onDidRemoveThing(thing => {\n *   thingListeners.deleteAndDispose(thing);\n * });\n *\n * anythingDataMultiplexer.event(e => {\n *   console.log('Something fired data ' + e.data)\n * });\n * ```\n */\nexport class EventMultiplexer<T> implements IDisposable {\n\n\tprivate readonly emitter: Emitter<T>;\n\tprivate hasListeners = false;\n\tprivate events: { event: Event<T>; listener: IDisposable | null }[] = [];\n\n\tconstructor() {\n\t\tthis.emitter = new Emitter<T>({\n\t\t\tonWillAddFirstListener: () => this.onFirstListenerAdd(),\n\t\t\tonDidRemoveLastListener: () => this.onLastListenerRemove()\n\t\t});\n\t}\n\n\tget event(): Event<T> {\n\t\treturn this.emitter.event;\n\t}\n\n\tadd(event: Event<T>): IDisposable {\n\t\tconst e = { event: event, listener: null };\n\t\tthis.events.push(e);\n\n\t\tif (this.hasListeners) {\n\t\t\tthis.hook(e);\n\t\t}\n\n\t\tconst dispose = () => {\n\t\t\tif (this.hasListeners) {\n\t\t\t\tthis.unhook(e);\n\t\t\t}\n\n\t\t\tconst idx = this.events.indexOf(e);\n\t\t\tthis.events.splice(idx, 1);\n\t\t};\n\n\t\treturn toDisposable(createSingleCallFunction(dispose));\n\t}\n\n\tprivate onFirstListenerAdd(): void {\n\t\tthis.hasListeners = true;\n\t\tthis.events.forEach(e => this.hook(e));\n\t}\n\n\tprivate onLastListenerRemove(): void {\n\t\tthis.hasListeners = false;\n\t\tthis.events.forEach(e => this.unhook(e));\n\t}\n\n\tprivate hook(e: { event: Event<T>; listener: IDisposable | null }): void {\n\t\te.listener = e.event(r => this.emitter.fire(r));\n\t}\n\n\tprivate unhook(e: { event: Event<T>; listener: IDisposable | null }): void {\n\t\te.listener?.dispose();\n\t\te.listener = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.emitter.dispose();\n\n\t\tfor (const e of this.events) {\n\t\t\te.listener?.dispose();\n\t\t}\n\t\tthis.events = [];\n\t}\n}\n\nexport interface IDynamicListEventMultiplexer<TEventType> extends IDisposable {\n\treadonly event: Event<TEventType>;\n}\nexport class DynamicListEventMultiplexer<TItem, TEventType> implements IDynamicListEventMultiplexer<TEventType> {\n\tprivate readonly _store = new DisposableStore();\n\n\treadonly event: Event<TEventType>;\n\n\tconstructor(\n\t\titems: TItem[],\n\t\tonAddItem: Event<TItem>,\n\t\tonRemoveItem: Event<TItem>,\n\t\tgetEvent: (item: TItem) => Event<TEventType>\n\t) {\n\t\tconst multiplexer = this._store.add(new EventMultiplexer<TEventType>());\n\t\tconst itemListeners = this._store.add(new DisposableMap<TItem, IDisposable>());\n\n\t\tfunction addItem(instance: TItem) {\n\t\t\titemListeners.set(instance, multiplexer.add(getEvent(instance)));\n\t\t}\n\n\t\t// Existing items\n\t\tfor (const instance of items) {\n\t\t\taddItem(instance);\n\t\t}\n\n\t\t// Added items\n\t\tthis._store.add(onAddItem(instance => {\n\t\t\taddItem(instance);\n\t\t}));\n\n\t\t// Removed items\n\t\tthis._store.add(onRemoveItem(instance => {\n\t\t\titemListeners.deleteAndDispose(instance);\n\t\t}));\n\n\t\tthis.event = multiplexer.event;\n\t}\n\n\tdispose() {\n\t\tthis._store.dispose();\n\t}\n}\n\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nexport class EventBufferer {\n\n\tprivate data: { buffers: Function[] }[] = [];\n\n\twrapEvent<T>(event: Event<T>): Event<T>;\n\twrapEvent<T>(event: Event<T>, reduce: (last: T | undefined, event: T) => T): Event<T>;\n\twrapEvent<T, O>(event: Event<T>, reduce: (last: O | undefined, event: T) => O, initial: O): Event<O>;\n\twrapEvent<T, O>(event: Event<T>, reduce?: (last: T | O | undefined, event: T) => T | O, initial?: O): Event<O | T> {\n\t\treturn (listener, thisArgs?, disposables?) => {\n\t\t\treturn event(i => {\n\t\t\t\tconst data = this.data[this.data.length - 1];\n\n\t\t\t\t// Non-reduce scenario\n\t\t\t\tif (!reduce) {\n\t\t\t\t\t// Buffering case\n\t\t\t\t\tif (data) {\n\t\t\t\t\t\tdata.buffers.push(() => listener.call(thisArgs, i));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Not buffering case\n\t\t\t\t\t\tlistener.call(thisArgs, i);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Reduce scenario\n\t\t\t\tconst reduceData = data as typeof data & {\n\t\t\t\t\t/**\n\t\t\t\t\t * The accumulated items that will be reduced.\n\t\t\t\t\t */\n\t\t\t\t\titems?: T[];\n\t\t\t\t\t/**\n\t\t\t\t\t * The reduced result cached to be shared with other listeners.\n\t\t\t\t\t */\n\t\t\t\t\treducedResult?: T | O;\n\t\t\t\t};\n\n\t\t\t\t// Not buffering case\n\t\t\t\tif (!reduceData) {\n\t\t\t\t\t// TODO: Is there a way to cache this reduce call for all listeners?\n\t\t\t\t\tlistener.call(thisArgs, reduce(initial, i));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Buffering case\n\t\t\t\treduceData.items ??= [];\n\t\t\t\treduceData.items.push(i);\n\t\t\t\tif (reduceData.buffers.length === 0) {\n\t\t\t\t\t// Include a single buffered function that will reduce all events when we're done buffering events\n\t\t\t\t\tdata.buffers.push(() => {\n\t\t\t\t\t\t// cache the reduced result so that the value can be shared across all listeners\n\t\t\t\t\t\treduceData.reducedResult ??= initial\n\t\t\t\t\t\t\t? reduceData.items!.reduce(reduce as (last: O | undefined, event: T) => O, initial)\n\t\t\t\t\t\t\t: reduceData.items!.reduce(reduce as (last: T | undefined, event: T) => T);\n\t\t\t\t\t\tlistener.call(thisArgs, reduceData.reducedResult);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}, undefined, disposables);\n\t\t};\n\t}\n\n\tbufferEvents<R = void>(fn: () => R): R {\n\t\tconst data = { buffers: new Array<Function>() };\n\t\tthis.data.push(data);\n\t\tconst r = fn();\n\t\tthis.data.pop();\n\t\tdata.buffers.forEach(flush => flush());\n\t\treturn r;\n\t}\n}\n\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nexport class Relay<T> implements IDisposable {\n\n\tprivate listening = false;\n\tprivate inputEvent: Event<T> = Event.None;\n\tprivate inputEventListener: IDisposable = Disposable.None;\n\n\tprivate readonly emitter = new Emitter<T>({\n\t\tonDidAddFirstListener: () => {\n\t\t\tthis.listening = true;\n\t\t\tthis.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n\t\t},\n\t\tonDidRemoveLastListener: () => {\n\t\t\tthis.listening = false;\n\t\t\tthis.inputEventListener.dispose();\n\t\t}\n\t});\n\n\treadonly event: Event<T> = this.emitter.event;\n\n\tset input(event: Event<T>) {\n\t\tthis.inputEvent = event;\n\n\t\tif (this.listening) {\n\t\t\tthis.inputEventListener.dispose();\n\t\t\tthis.inputEventListener = event(this.emitter.fire, this.emitter);\n\t\t}\n\t}\n\n\tdispose() {\n\t\tthis.inputEventListener.dispose();\n\t\tthis.emitter.dispose();\n\t}\n}\n\nexport interface IValueWithChangeEvent<T> {\n\treadonly onDidChange: Event<void>;\n\tget value(): T;\n}\n\nexport class ValueWithChangeEvent<T> implements IValueWithChangeEvent<T> {\n\tpublic static const<T>(value: T): IValueWithChangeEvent<T> {\n\t\treturn new ConstValueWithChangeEvent(value);\n\t}\n\n\tprivate readonly _onDidChange = new Emitter<void>();\n\treadonly onDidChange: Event<void> = this._onDidChange.event;\n\n\tconstructor(private _value: T) { }\n\n\tget value(): T {\n\t\treturn this._value;\n\t}\n\n\tset value(value: T) {\n\t\tif (value !== this._value) {\n\t\t\tthis._value = value;\n\t\t\tthis._onDidChange.fire(undefined);\n\t\t}\n\t}\n}\n\nclass ConstValueWithChangeEvent<T> implements IValueWithChangeEvent<T> {\n\tpublic readonly onDidChange: Event<void> = Event.None;\n\n\tconstructor(readonly value: T) { }\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CodeWindow, mainWindow } from 'vs/base/browser/window';\nimport { Emitter } from 'vs/base/common/event';\n\nclass WindowManager {\n\n\tstatic readonly INSTANCE = new WindowManager();\n\n\t// --- Zoom Level\n\n\tprivate readonly mapWindowIdToZoomLevel = new Map<number, number>();\n\n\tprivate readonly _onDidChangeZoomLevel = new Emitter<number>();\n\treadonly onDidChangeZoomLevel = this._onDidChangeZoomLevel.event;\n\n\tgetZoomLevel(targetWindow: Window): number {\n\t\treturn this.mapWindowIdToZoomLevel.get(this.getWindowId(targetWindow)) ?? 0;\n\t}\n\tsetZoomLevel(zoomLevel: number, targetWindow: Window): void {\n\t\tif (this.getZoomLevel(targetWindow) === zoomLevel) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst targetWindowId = this.getWindowId(targetWindow);\n\t\tthis.mapWindowIdToZoomLevel.set(targetWindowId, zoomLevel);\n\t\tthis._onDidChangeZoomLevel.fire(targetWindowId);\n\t}\n\n\t// --- Zoom Factor\n\n\tprivate readonly mapWindowIdToZoomFactor = new Map<number, number>();\n\n\tgetZoomFactor(targetWindow: Window): number {\n\t\treturn this.mapWindowIdToZoomFactor.get(this.getWindowId(targetWindow)) ?? 1;\n\t}\n\tsetZoomFactor(zoomFactor: number, targetWindow: Window): void {\n\t\tthis.mapWindowIdToZoomFactor.set(this.getWindowId(targetWindow), zoomFactor);\n\t}\n\n\t// --- Fullscreen\n\n\tprivate readonly _onDidChangeFullscreen = new Emitter<number>();\n\treadonly onDidChangeFullscreen = this._onDidChangeFullscreen.event;\n\n\tprivate readonly mapWindowIdToFullScreen = new Map<number, boolean>();\n\n\tsetFullscreen(fullscreen: boolean, targetWindow: Window): void {\n\t\tif (this.isFullscreen(targetWindow) === fullscreen) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst windowId = this.getWindowId(targetWindow);\n\t\tthis.mapWindowIdToFullScreen.set(windowId, fullscreen);\n\t\tthis._onDidChangeFullscreen.fire(windowId);\n\t}\n\tisFullscreen(targetWindow: Window): boolean {\n\t\treturn !!this.mapWindowIdToFullScreen.get(this.getWindowId(targetWindow));\n\t}\n\n\tprivate getWindowId(targetWindow: Window): number {\n\t\treturn (targetWindow as CodeWindow).vscodeWindowId;\n\t}\n}\n\nexport function addMatchMediaChangeListener(targetWindow: Window, query: string | MediaQueryList, callback: (this: MediaQueryList, ev: MediaQueryListEvent) => any): void {\n\tif (typeof query === 'string') {\n\t\tquery = targetWindow.matchMedia(query);\n\t}\n\tquery.addEventListener('change', callback);\n}\n\n/** A zoom index, e.g. 1, 2, 3 */\nexport function setZoomLevel(zoomLevel: number, targetWindow: Window): void {\n\tWindowManager.INSTANCE.setZoomLevel(zoomLevel, targetWindow);\n}\nexport function getZoomLevel(targetWindow: Window): number {\n\treturn WindowManager.INSTANCE.getZoomLevel(targetWindow);\n}\nexport const onDidChangeZoomLevel = WindowManager.INSTANCE.onDidChangeZoomLevel;\n\n/** The zoom scale for an index, e.g. 1, 1.2, 1.4 */\nexport function getZoomFactor(targetWindow: Window): number {\n\treturn WindowManager.INSTANCE.getZoomFactor(targetWindow);\n}\nexport function setZoomFactor(zoomFactor: number, targetWindow: Window): void {\n\tWindowManager.INSTANCE.setZoomFactor(zoomFactor, targetWindow);\n}\n\nexport function setFullscreen(fullscreen: boolean, targetWindow: Window): void {\n\tWindowManager.INSTANCE.setFullscreen(fullscreen, targetWindow);\n}\nexport function isFullscreen(targetWindow: Window): boolean {\n\treturn WindowManager.INSTANCE.isFullscreen(targetWindow);\n}\nexport const onDidChangeFullscreen = WindowManager.INSTANCE.onDidChangeFullscreen;\n\nconst userAgent = typeof navigator === 'object' ? navigator.userAgent : '';\n\nexport const isFirefox = (userAgent.indexOf('Firefox') >= 0);\nexport const isWebKit = (userAgent.indexOf('AppleWebKit') >= 0);\nexport const isChrome = (userAgent.indexOf('Chrome') >= 0);\nexport const isSafari = (!isChrome && (userAgent.indexOf('Safari') >= 0));\nexport const isWebkitWebView = (!isChrome && !isSafari && isWebKit);\nexport const isElectron = (userAgent.indexOf('Electron/') >= 0);\nexport const isAndroid = (userAgent.indexOf('Android') >= 0);\n\nlet standalone = false;\nif (typeof mainWindow.matchMedia === 'function') {\n\tconst standaloneMatchMedia = mainWindow.matchMedia('(display-mode: standalone) or (display-mode: window-controls-overlay)');\n\tconst fullScreenMatchMedia = mainWindow.matchMedia('(display-mode: fullscreen)');\n\tstandalone = standaloneMatchMedia.matches;\n\taddMatchMediaChangeListener(mainWindow, standaloneMatchMedia, ({ matches }) => {\n\t\t// entering fullscreen would change standaloneMatchMedia.matches to false\n\t\t// if standalone is true (running as PWA) and entering fullscreen, skip this change\n\t\tif (standalone && fullScreenMatchMedia.matches) {\n\t\t\treturn;\n\t\t}\n\t\t// otherwise update standalone (browser to PWA or PWA to browser)\n\t\tstandalone = matches;\n\t});\n}\nexport function isStandalone(): boolean {\n\treturn standalone;\n}\n\n// Visible means that the feature is enabled, not necessarily being rendered\n// e.g. visible is true even in fullscreen mode where the controls are hidden\n// See docs at https://developer.mozilla.org/en-US/docs/Web/API/WindowControlsOverlay/visible\nexport function isWCOEnabled(): boolean {\n\treturn (navigator as any)?.windowControlsOverlay?.visible;\n}\n\n// Returns the bounding rect of the titlebar area if it is supported and defined\n// See docs at https://developer.mozilla.org/en-US/docs/Web/API/WindowControlsOverlay/getTitlebarAreaRect\nexport function getWCOBoundingRect(): DOMRect | undefined {\n\treturn (navigator as any)?.windowControlsOverlay?.getTitlebarAreaRect();\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as nls from 'vs/nls';\n\nexport const LANGUAGE_DEFAULT = 'en';\n\nlet _isWindows = false;\nlet _isMacintosh = false;\nlet _isLinux = false;\nlet _isLinuxSnap = false;\nlet _isNative = false;\nlet _isWeb = false;\nlet _isElectron = false;\nlet _isIOS = false;\nlet _isCI = false;\nlet _isMobile = false;\nlet _locale: string | undefined = undefined;\nlet _language: string = LANGUAGE_DEFAULT;\nlet _platformLocale: string = LANGUAGE_DEFAULT;\nlet _translationsConfigFile: string | undefined = undefined;\nlet _userAgent: string | undefined = undefined;\n\nexport interface IProcessEnvironment {\n\t[key: string]: string | undefined;\n}\n\n/**\n * This interface is intentionally not identical to node.js\n * process because it also works in sandboxed environments\n * where the process object is implemented differently. We\n * define the properties here that we need for `platform`\n * to work and nothing else.\n */\nexport interface INodeProcess {\n\tplatform: string;\n\tarch: string;\n\tenv: IProcessEnvironment;\n\tversions?: {\n\t\tnode?: string;\n\t\telectron?: string;\n\t\tchrome?: string;\n\t};\n\ttype?: string;\n\tcwd: () => string;\n}\n\ndeclare const process: INodeProcess;\n\nconst $globalThis: any = globalThis;\n\nlet nodeProcess: INodeProcess | undefined = undefined;\nif (typeof $globalThis.vscode !== 'undefined' && typeof $globalThis.vscode.process !== 'undefined') {\n\t// Native environment (sandboxed)\n\tnodeProcess = $globalThis.vscode.process;\n} else if (typeof process !== 'undefined' && typeof process?.versions?.node === 'string') {\n\t// Native environment (non-sandboxed)\n\tnodeProcess = process;\n}\n\nconst isElectronProcess = typeof nodeProcess?.versions?.electron === 'string';\nconst isElectronRenderer = isElectronProcess && nodeProcess?.type === 'renderer';\n\ninterface INavigator {\n\tuserAgent: string;\n\tmaxTouchPoints?: number;\n\tlanguage: string;\n}\ndeclare const navigator: INavigator;\n\n// Native environment\nif (typeof nodeProcess === 'object') {\n\t_isWindows = (nodeProcess.platform === 'win32');\n\t_isMacintosh = (nodeProcess.platform === 'darwin');\n\t_isLinux = (nodeProcess.platform === 'linux');\n\t_isLinuxSnap = _isLinux && !!nodeProcess.env['SNAP'] && !!nodeProcess.env['SNAP_REVISION'];\n\t_isElectron = isElectronProcess;\n\t_isCI = !!nodeProcess.env['CI'] || !!nodeProcess.env['BUILD_ARTIFACTSTAGINGDIRECTORY'];\n\t_locale = LANGUAGE_DEFAULT;\n\t_language = LANGUAGE_DEFAULT;\n\tconst rawNlsConfig = nodeProcess.env['VSCODE_NLS_CONFIG'];\n\tif (rawNlsConfig) {\n\t\ttry {\n\t\t\tconst nlsConfig: nls.INLSConfiguration = JSON.parse(rawNlsConfig);\n\t\t\t_locale = nlsConfig.userLocale;\n\t\t\t_platformLocale = nlsConfig.osLocale;\n\t\t\t_language = nlsConfig.resolvedLanguage || LANGUAGE_DEFAULT;\n\t\t\t_translationsConfigFile = nlsConfig.languagePack?.translationsConfigFile;\n\t\t} catch (e) {\n\t\t}\n\t}\n\t_isNative = true;\n}\n\n// Web environment\nelse if (typeof navigator === 'object' && !isElectronRenderer) {\n\t_userAgent = navigator.userAgent;\n\t_isWindows = _userAgent.indexOf('Windows') >= 0;\n\t_isMacintosh = _userAgent.indexOf('Macintosh') >= 0;\n\t_isIOS = (_userAgent.indexOf('Macintosh') >= 0 || _userAgent.indexOf('iPad') >= 0 || _userAgent.indexOf('iPhone') >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;\n\t_isLinux = _userAgent.indexOf('Linux') >= 0;\n\t_isMobile = _userAgent?.indexOf('Mobi') >= 0;\n\t_isWeb = true;\n\t// VSCODE_GLOBALS: NLS\n\t_language = globalThis._VSCODE_NLS_LANGUAGE || LANGUAGE_DEFAULT;\n\t_locale = navigator.language.toLowerCase();\n\t_platformLocale = _locale;\n}\n\n// Unknown environment\nelse {\n\tconsole.error('Unable to resolve platform.');\n}\n\nexport const enum Platform {\n\tWeb,\n\tMac,\n\tLinux,\n\tWindows\n}\nexport type PlatformName = 'Web' | 'Windows' | 'Mac' | 'Linux';\n\nexport function PlatformToString(platform: Platform): PlatformName {\n\tswitch (platform) {\n\t\tcase Platform.Web: return 'Web';\n\t\tcase Platform.Mac: return 'Mac';\n\t\tcase Platform.Linux: return 'Linux';\n\t\tcase Platform.Windows: return 'Windows';\n\t}\n}\n\nlet _platform: Platform = Platform.Web;\nif (_isMacintosh) {\n\t_platform = Platform.Mac;\n} else if (_isWindows) {\n\t_platform = Platform.Windows;\n} else if (_isLinux) {\n\t_platform = Platform.Linux;\n}\n\nexport const isWindows = _isWindows;\nexport const isMacintosh = _isMacintosh;\nexport const isLinux = _isLinux;\nexport const isLinuxSnap = _isLinuxSnap;\nexport const isNative = _isNative;\nexport const isElectron = _isElectron;\nexport const isWeb = _isWeb;\nexport const isWebWorker = (_isWeb && typeof $globalThis.importScripts === 'function');\nexport const webWorkerOrigin = isWebWorker ? $globalThis.origin : undefined;\nexport const isIOS = _isIOS;\nexport const isMobile = _isMobile;\n/**\n * Whether we run inside a CI environment, such as\n * GH actions or Azure Pipelines.\n */\nexport const isCI = _isCI;\nexport const platform = _platform;\nexport const userAgent = _userAgent;\n\n/**\n * The language used for the user interface. The format of\n * the string is all lower case (e.g. zh-tw for Traditional\n * Chinese or de for German)\n */\nexport const language = _language;\n\nexport namespace Language {\n\n\texport function value(): string {\n\t\treturn language;\n\t}\n\n\texport function isDefaultVariant(): boolean {\n\t\tif (language.length === 2) {\n\t\t\treturn language === 'en';\n\t\t} else if (language.length >= 3) {\n\t\t\treturn language[0] === 'e' && language[1] === 'n' && language[2] === '-';\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\texport function isDefault(): boolean {\n\t\treturn language === 'en';\n\t}\n}\n\n/**\n * Desktop: The OS locale or the locale specified by --locale or `argv.json`.\n * Web: matches `platformLocale`.\n *\n * The UI is not necessarily shown in the provided locale.\n */\nexport const locale = _locale;\n\n/**\n * This will always be set to the OS/browser's locale regardless of\n * what was specified otherwise. The format of the string is all\n * lower case (e.g. zh-tw for Traditional Chinese). The UI is not\n * necessarily shown in the provided locale.\n */\nexport const platformLocale = _platformLocale;\n\n/**\n * The translations that are available through language packs.\n */\nexport const translationsConfigFile = _translationsConfigFile;\n\nexport const setTimeout0IsFaster = (typeof $globalThis.postMessage === 'function' && !$globalThis.importScripts);\n\n/**\n * See https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#:~:text=than%204%2C%20then-,set%20timeout%20to%204,-.\n *\n * Works similarly to `setTimeout(0)` but doesn't suffer from the 4ms artificial delay\n * that browsers set when the nesting level is > 5.\n */\nexport const setTimeout0 = (() => {\n\tif (setTimeout0IsFaster) {\n\t\tinterface IQueueElement {\n\t\t\tid: number;\n\t\t\tcallback: () => void;\n\t\t}\n\t\tconst pending: IQueueElement[] = [];\n\n\t\t$globalThis.addEventListener('message', (e: any) => {\n\t\t\tif (e.data && e.data.vscodeScheduleAsyncWork) {\n\t\t\t\tfor (let i = 0, len = pending.length; i < len; i++) {\n\t\t\t\t\tconst candidate = pending[i];\n\t\t\t\t\tif (candidate.id === e.data.vscodeScheduleAsyncWork) {\n\t\t\t\t\t\tpending.splice(i, 1);\n\t\t\t\t\t\tcandidate.callback();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tlet lastId = 0;\n\t\treturn (callback: () => void) => {\n\t\t\tconst myId = ++lastId;\n\t\t\tpending.push({\n\t\t\t\tid: myId,\n\t\t\t\tcallback: callback\n\t\t\t});\n\t\t\t$globalThis.postMessage({ vscodeScheduleAsyncWork: myId }, '*');\n\t\t};\n\t}\n\treturn (callback: () => void) => setTimeout(callback);\n})();\n\nexport const enum OperatingSystem {\n\tWindows = 1,\n\tMacintosh = 2,\n\tLinux = 3\n}\nexport const OS = (_isMacintosh || _isIOS ? OperatingSystem.Macintosh : (_isWindows ? OperatingSystem.Windows : OperatingSystem.Linux));\n\nlet _isLittleEndian = true;\nlet _isLittleEndianComputed = false;\nexport function isLittleEndian(): boolean {\n\tif (!_isLittleEndianComputed) {\n\t\t_isLittleEndianComputed = true;\n\t\tconst test = new Uint8Array(2);\n\t\ttest[0] = 1;\n\t\ttest[1] = 2;\n\t\tconst view = new Uint16Array(test.buffer);\n\t\t_isLittleEndian = (view[0] === (2 << 8) + 1);\n\t}\n\treturn _isLittleEndian;\n}\n\nexport const isChrome = !!(userAgent && userAgent.indexOf('Chrome') >= 0);\nexport const isFirefox = !!(userAgent && userAgent.indexOf('Firefox') >= 0);\nexport const isSafari = !!(!isChrome && (userAgent && userAgent.indexOf('Safari') >= 0));\nexport const isEdge = !!(userAgent && userAgent.indexOf('Edg/') >= 0);\nexport const isAndroid = !!(userAgent && userAgent.indexOf('Android') >= 0);\n\nexport function isBigSurOrNewer(osVersion: string): boolean {\n\treturn parseFloat(osVersion) >= 20;\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as browser from 'vs/base/browser/browser';\nimport { mainWindow } from 'vs/base/browser/window';\nimport * as platform from 'vs/base/common/platform';\n\nexport const enum KeyboardSupport {\n\tAlways,\n\tFullScreen,\n\tNone\n}\n\nconst safeNavigator = typeof navigator === 'object' ? navigator : {} as { [key: string]: any };\n\n/**\n * Browser feature we can support in current platform, browser and environment.\n */\nexport const BrowserFeatures = {\n\tclipboard: {\n\t\twriteText: (\n\t\t\tplatform.isNative\n\t\t\t|| (document.queryCommandSupported && document.queryCommandSupported('copy'))\n\t\t\t|| !!(safeNavigator && safeNavigator.clipboard && safeNavigator.clipboard.writeText)\n\t\t),\n\t\treadText: (\n\t\t\tplatform.isNative\n\t\t\t|| !!(safeNavigator && safeNavigator.clipboard && safeNavigator.clipboard.readText)\n\t\t)\n\t},\n\tkeyboard: (() => {\n\t\tif (platform.isNative || browser.isStandalone()) {\n\t\t\treturn KeyboardSupport.Always;\n\t\t}\n\n\t\tif ((<any>safeNavigator).keyboard || browser.isSafari) {\n\t\t\treturn KeyboardSupport.FullScreen;\n\t\t}\n\n\t\treturn KeyboardSupport.None;\n\t})(),\n\n\t// 'ontouchstart' in window always evaluates to true with typescript's modern typings. This causes `window` to be\n\t// `never` later in `window.navigator`. That's why we need the explicit `window as Window` cast\n\ttouch: 'ontouchstart' in mainWindow || safeNavigator.maxTouchPoints > 0,\n\tpointerEvents: mainWindow.PointerEvent && ('ontouchstart' in mainWindow || navigator.maxTouchPoints > 0)\n};\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Virtual Key Codes, the value does not hold any inherent meaning.\n * Inspired somewhat from https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx\n * But these are \"more general\", as they should work across browsers & OS`s.\n */\nexport const enum KeyCode {\n\tDependsOnKbLayout = -1,\n\n\t/**\n\t * Placed first to cover the 0 value of the enum.\n\t */\n\tUnknown = 0,\n\n\tBackspace,\n\tTab,\n\tEnter,\n\tShift,\n\tCtrl,\n\tAlt,\n\tPauseBreak,\n\tCapsLock,\n\tEscape,\n\tSpace,\n\tPageUp,\n\tPageDown,\n\tEnd,\n\tHome,\n\tLeftArrow,\n\tUpArrow,\n\tRightArrow,\n\tDownArrow,\n\tInsert,\n\tDelete,\n\n\tDigit0,\n\tDigit1,\n\tDigit2,\n\tDigit3,\n\tDigit4,\n\tDigit5,\n\tDigit6,\n\tDigit7,\n\tDigit8,\n\tDigit9,\n\n\tKeyA,\n\tKeyB,\n\tKeyC,\n\tKeyD,\n\tKeyE,\n\tKeyF,\n\tKeyG,\n\tKeyH,\n\tKeyI,\n\tKeyJ,\n\tKeyK,\n\tKeyL,\n\tKeyM,\n\tKeyN,\n\tKeyO,\n\tKeyP,\n\tKeyQ,\n\tKeyR,\n\tKeyS,\n\tKeyT,\n\tKeyU,\n\tKeyV,\n\tKeyW,\n\tKeyX,\n\tKeyY,\n\tKeyZ,\n\n\tMeta,\n\tContextMenu,\n\n\tF1,\n\tF2,\n\tF3,\n\tF4,\n\tF5,\n\tF6,\n\tF7,\n\tF8,\n\tF9,\n\tF10,\n\tF11,\n\tF12,\n\tF13,\n\tF14,\n\tF15,\n\tF16,\n\tF17,\n\tF18,\n\tF19,\n\tF20,\n\tF21,\n\tF22,\n\tF23,\n\tF24,\n\n\tNumLock,\n\tScrollLock,\n\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t * For the US standard keyboard, the ';:' key\n\t */\n\tSemicolon,\n\t/**\n\t * For any country/region, the '+' key\n\t * For the US standard keyboard, the '=+' key\n\t */\n\tEqual,\n\t/**\n\t * For any country/region, the ',' key\n\t * For the US standard keyboard, the ',<' key\n\t */\n\tComma,\n\t/**\n\t * For any country/region, the '-' key\n\t * For the US standard keyboard, the '-_' key\n\t */\n\tMinus,\n\t/**\n\t * For any country/region, the '.' key\n\t * For the US standard keyboard, the '.>' key\n\t */\n\tPeriod,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t * For the US standard keyboard, the '/?' key\n\t */\n\tSlash,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t * For the US standard keyboard, the '`~' key\n\t */\n\tBackquote,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t * For the US standard keyboard, the '[{' key\n\t */\n\tBracketLeft,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t * For the US standard keyboard, the '\\|' key\n\t */\n\tBackslash,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t * For the US standard keyboard, the ']}' key\n\t */\n\tBracketRight,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t * For the US standard keyboard, the ''\"' key\n\t */\n\tQuote,\n\t/**\n\t * Used for miscellaneous characters; it can vary by keyboard.\n\t */\n\tOEM_8,\n\t/**\n\t * Either the angle bracket key or the backslash key on the RT 102-key keyboard.\n\t */\n\tIntlBackslash,\n\n\tNumpad0, // VK_NUMPAD0, 0x60, Numeric keypad 0 key\n\tNumpad1, // VK_NUMPAD1, 0x61, Numeric keypad 1 key\n\tNumpad2, // VK_NUMPAD2, 0x62, Numeric keypad 2 key\n\tNumpad3, // VK_NUMPAD3, 0x63, Numeric keypad 3 key\n\tNumpad4, // VK_NUMPAD4, 0x64, Numeric keypad 4 key\n\tNumpad5, // VK_NUMPAD5, 0x65, Numeric keypad 5 key\n\tNumpad6, // VK_NUMPAD6, 0x66, Numeric keypad 6 key\n\tNumpad7, // VK_NUMPAD7, 0x67, Numeric keypad 7 key\n\tNumpad8, // VK_NUMPAD8, 0x68, Numeric keypad 8 key\n\tNumpad9, // VK_NUMPAD9, 0x69, Numeric keypad 9 key\n\n\tNumpadMultiply,\t// VK_MULTIPLY, 0x6A, Multiply key\n\tNumpadAdd,\t\t// VK_ADD, 0x6B, Add key\n\tNUMPAD_SEPARATOR,\t// VK_SEPARATOR, 0x6C, Separator key\n\tNumpadSubtract,\t// VK_SUBTRACT, 0x6D, Subtract key\n\tNumpadDecimal,\t// VK_DECIMAL, 0x6E, Decimal key\n\tNumpadDivide,\t// VK_DIVIDE, 0x6F,\n\n\t/**\n\t * Cover all key codes when IME is processing input.\n\t */\n\tKEY_IN_COMPOSITION,\n\n\tABNT_C1, // Brazilian (ABNT) Keyboard\n\tABNT_C2, // Brazilian (ABNT) Keyboard\n\n\tAudioVolumeMute,\n\tAudioVolumeUp,\n\tAudioVolumeDown,\n\n\tBrowserSearch,\n\tBrowserHome,\n\tBrowserBack,\n\tBrowserForward,\n\n\tMediaTrackNext,\n\tMediaTrackPrevious,\n\tMediaStop,\n\tMediaPlayPause,\n\tLaunchMediaPlayer,\n\tLaunchMail,\n\tLaunchApp2,\n\n\t/**\n\t * VK_CLEAR, 0x0C, CLEAR key\n\t */\n\tClear,\n\n\t/**\n\t * Placed last to cover the length of the enum.\n\t * Please do not depend on this value!\n\t */\n\tMAX_VALUE\n}\n\n/**\n * keyboardEvent.code\n */\nexport const enum ScanCode {\n\tDependsOnKbLayout = -1,\n\tNone,\n\tHyper,\n\tSuper,\n\tFn,\n\tFnLock,\n\tSuspend,\n\tResume,\n\tTurbo,\n\tSleep,\n\tWakeUp,\n\tKeyA,\n\tKeyB,\n\tKeyC,\n\tKeyD,\n\tKeyE,\n\tKeyF,\n\tKeyG,\n\tKeyH,\n\tKeyI,\n\tKeyJ,\n\tKeyK,\n\tKeyL,\n\tKeyM,\n\tKeyN,\n\tKeyO,\n\tKeyP,\n\tKeyQ,\n\tKeyR,\n\tKeyS,\n\tKeyT,\n\tKeyU,\n\tKeyV,\n\tKeyW,\n\tKeyX,\n\tKeyY,\n\tKeyZ,\n\tDigit1,\n\tDigit2,\n\tDigit3,\n\tDigit4,\n\tDigit5,\n\tDigit6,\n\tDigit7,\n\tDigit8,\n\tDigit9,\n\tDigit0,\n\tEnter,\n\tEscape,\n\tBackspace,\n\tTab,\n\tSpace,\n\tMinus,\n\tEqual,\n\tBracketLeft,\n\tBracketRight,\n\tBackslash,\n\tIntlHash,\n\tSemicolon,\n\tQuote,\n\tBackquote,\n\tComma,\n\tPeriod,\n\tSlash,\n\tCapsLock,\n\tF1,\n\tF2,\n\tF3,\n\tF4,\n\tF5,\n\tF6,\n\tF7,\n\tF8,\n\tF9,\n\tF10,\n\tF11,\n\tF12,\n\tPrintScreen,\n\tScrollLock,\n\tPause,\n\tInsert,\n\tHome,\n\tPageUp,\n\tDelete,\n\tEnd,\n\tPageDown,\n\tArrowRight,\n\tArrowLeft,\n\tArrowDown,\n\tArrowUp,\n\tNumLock,\n\tNumpadDivide,\n\tNumpadMultiply,\n\tNumpadSubtract,\n\tNumpadAdd,\n\tNumpadEnter,\n\tNumpad1,\n\tNumpad2,\n\tNumpad3,\n\tNumpad4,\n\tNumpad5,\n\tNumpad6,\n\tNumpad7,\n\tNumpad8,\n\tNumpad9,\n\tNumpad0,\n\tNumpadDecimal,\n\tIntlBackslash,\n\tContextMenu,\n\tPower,\n\tNumpadEqual,\n\tF13,\n\tF14,\n\tF15,\n\tF16,\n\tF17,\n\tF18,\n\tF19,\n\tF20,\n\tF21,\n\tF22,\n\tF23,\n\tF24,\n\tOpen,\n\tHelp,\n\tSelect,\n\tAgain,\n\tUndo,\n\tCut,\n\tCopy,\n\tPaste,\n\tFind,\n\tAudioVolumeMute,\n\tAudioVolumeUp,\n\tAudioVolumeDown,\n\tNumpadComma,\n\tIntlRo,\n\tKanaMode,\n\tIntlYen,\n\tConvert,\n\tNonConvert,\n\tLang1,\n\tLang2,\n\tLang3,\n\tLang4,\n\tLang5,\n\tAbort,\n\tProps,\n\tNumpadParenLeft,\n\tNumpadParenRight,\n\tNumpadBackspace,\n\tNumpadMemoryStore,\n\tNumpadMemoryRecall,\n\tNumpadMemoryClear,\n\tNumpadMemoryAdd,\n\tNumpadMemorySubtract,\n\tNumpadClear,\n\tNumpadClearEntry,\n\tControlLeft,\n\tShiftLeft,\n\tAltLeft,\n\tMetaLeft,\n\tControlRight,\n\tShiftRight,\n\tAltRight,\n\tMetaRight,\n\tBrightnessUp,\n\tBrightnessDown,\n\tMediaPlay,\n\tMediaRecord,\n\tMediaFastForward,\n\tMediaRewind,\n\tMediaTrackNext,\n\tMediaTrackPrevious,\n\tMediaStop,\n\tEject,\n\tMediaPlayPause,\n\tMediaSelect,\n\tLaunchMail,\n\tLaunchApp2,\n\tLaunchApp1,\n\tSelectTask,\n\tLaunchScreenSaver,\n\tBrowserSearch,\n\tBrowserHome,\n\tBrowserBack,\n\tBrowserForward,\n\tBrowserStop,\n\tBrowserRefresh,\n\tBrowserFavorites,\n\tZoomToggle,\n\tMailReply,\n\tMailForward,\n\tMailSend,\n\n\tMAX_VALUE\n}\n\nclass KeyCodeStrMap {\n\n\tpublic _keyCodeToStr: string[];\n\tpublic _strToKeyCode: { [str: string]: KeyCode };\n\n\tconstructor() {\n\t\tthis._keyCodeToStr = [];\n\t\tthis._strToKeyCode = Object.create(null);\n\t}\n\n\tdefine(keyCode: KeyCode, str: string): void {\n\t\tthis._keyCodeToStr[keyCode] = str;\n\t\tthis._strToKeyCode[str.toLowerCase()] = keyCode;\n\t}\n\n\tkeyCodeToStr(keyCode: KeyCode): string {\n\t\treturn this._keyCodeToStr[keyCode];\n\t}\n\n\tstrToKeyCode(str: string): KeyCode {\n\t\treturn this._strToKeyCode[str.toLowerCase()] || KeyCode.Unknown;\n\t}\n}\n\nconst uiMap = new KeyCodeStrMap();\nconst userSettingsUSMap = new KeyCodeStrMap();\nconst userSettingsGeneralMap = new KeyCodeStrMap();\nexport const EVENT_KEY_CODE_MAP: { [keyCode: number]: KeyCode } = new Array(230);\nexport const NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE: { [nativeKeyCode: string]: KeyCode } = {};\nconst scanCodeIntToStr: string[] = [];\nconst scanCodeStrToInt: { [code: string]: number } = Object.create(null);\nconst scanCodeLowerCaseStrToInt: { [code: string]: number } = Object.create(null);\n\nexport const ScanCodeUtils = {\n\tlowerCaseToEnum: (scanCode: string) => scanCodeLowerCaseStrToInt[scanCode] || ScanCode.None,\n\ttoEnum: (scanCode: string) => scanCodeStrToInt[scanCode] || ScanCode.None,\n\ttoString: (scanCode: ScanCode) => scanCodeIntToStr[scanCode] || 'None'\n};\n\n\nexport namespace KeyCodeUtils {\n\texport function toString(keyCode: KeyCode): string {\n\t\treturn uiMap.keyCodeToStr(keyCode);\n\t}\n\texport function fromString(key: string): KeyCode {\n\t\treturn uiMap.strToKeyCode(key);\n\t}\n\n\texport function toUserSettingsUS(keyCode: KeyCode): string {\n\t\treturn userSettingsUSMap.keyCodeToStr(keyCode);\n\t}\n\texport function toUserSettingsGeneral(keyCode: KeyCode): string {\n\t\treturn userSettingsGeneralMap.keyCodeToStr(keyCode);\n\t}\n\texport function fromUserSettings(key: string): KeyCode {\n\t\treturn userSettingsUSMap.strToKeyCode(key) || userSettingsGeneralMap.strToKeyCode(key);\n\t}\n\n\texport function toElectronAccelerator(keyCode: KeyCode): string | null {\n\t\tif (keyCode >= KeyCode.Numpad0 && keyCode <= KeyCode.NumpadDivide) {\n\t\t\t// [Electron Accelerators] Electron is able to parse numpad keys, but unfortunately it\n\t\t\t// renders them just as regular keys in menus. For example, num0 is rendered as \"0\",\n\t\t\t// numdiv is rendered as \"/\", numsub is rendered as \"-\".\n\t\t\t//\n\t\t\t// This can lead to incredible confusion, as it makes numpad based keybindings indistinguishable\n\t\t\t// from keybindings based on regular keys.\n\t\t\t//\n\t\t\t// We therefore need to fall back to custom rendering for numpad keys.\n\t\t\treturn null;\n\t\t}\n\n\t\tswitch (keyCode) {\n\t\t\tcase KeyCode.UpArrow:\n\t\t\t\treturn 'Up';\n\t\t\tcase KeyCode.DownArrow:\n\t\t\t\treturn 'Down';\n\t\t\tcase KeyCode.LeftArrow:\n\t\t\t\treturn 'Left';\n\t\t\tcase KeyCode.RightArrow:\n\t\t\t\treturn 'Right';\n\t\t}\n\n\t\treturn uiMap.keyCodeToStr(keyCode);\n\t}\n}\n\nexport const enum KeyMod {\n\tCtrlCmd = (1 << 11) >>> 0,\n\tShift = (1 << 10) >>> 0,\n\tAlt = (1 << 9) >>> 0,\n\tWinCtrl = (1 << 8) >>> 0,\n}\n\nexport function KeyChord(firstPart: number, secondPart: number): number {\n\tconst chordPart = ((secondPart & 0x0000FFFF) << 16) >>> 0;\n\treturn (firstPart | chordPart) >>> 0;\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { illegalArgument } from 'vs/base/common/errors';\nimport { KeyCode, ScanCode } from 'vs/base/common/keyCodes';\nimport { OperatingSystem } from 'vs/base/common/platform';\n\n/**\n * Binary encoding strategy:\n * ```\n *    1111 11\n *    5432 1098 7654 3210\n *    ---- CSAW KKKK KKKK\n *  C = bit 11 = ctrlCmd flag\n *  S = bit 10 = shift flag\n *  A = bit 9 = alt flag\n *  W = bit 8 = winCtrl flag\n *  K = bits 0-7 = key code\n * ```\n */\nconst enum BinaryKeybindingsMask {\n\tCtrlCmd = (1 << 11) >>> 0,\n\tShift = (1 << 10) >>> 0,\n\tAlt = (1 << 9) >>> 0,\n\tWinCtrl = (1 << 8) >>> 0,\n\tKeyCode = 0x000000FF\n}\n\nexport function decodeKeybinding(keybinding: number | number[], OS: OperatingSystem): Keybinding | null {\n\tif (typeof keybinding === 'number') {\n\t\tif (keybinding === 0) {\n\t\t\treturn null;\n\t\t}\n\t\tconst firstChord = (keybinding & 0x0000FFFF) >>> 0;\n\t\tconst secondChord = (keybinding & 0xFFFF0000) >>> 16;\n\t\tif (secondChord !== 0) {\n\t\t\treturn new Keybinding([\n\t\t\t\tcreateSimpleKeybinding(firstChord, OS),\n\t\t\t\tcreateSimpleKeybinding(secondChord, OS)\n\t\t\t]);\n\t\t}\n\t\treturn new Keybinding([createSimpleKeybinding(firstChord, OS)]);\n\t} else {\n\t\tconst chords = [];\n\t\tfor (let i = 0; i < keybinding.length; i++) {\n\t\t\tchords.push(createSimpleKeybinding(keybinding[i], OS));\n\t\t}\n\t\treturn new Keybinding(chords);\n\t}\n}\n\nexport function createSimpleKeybinding(keybinding: number, OS: OperatingSystem): KeyCodeChord {\n\n\tconst ctrlCmd = (keybinding & BinaryKeybindingsMask.CtrlCmd ? true : false);\n\tconst winCtrl = (keybinding & BinaryKeybindingsMask.WinCtrl ? true : false);\n\n\tconst ctrlKey = (OS === OperatingSystem.Macintosh ? winCtrl : ctrlCmd);\n\tconst shiftKey = (keybinding & BinaryKeybindingsMask.Shift ? true : false);\n\tconst altKey = (keybinding & BinaryKeybindingsMask.Alt ? true : false);\n\tconst metaKey = (OS === OperatingSystem.Macintosh ? ctrlCmd : winCtrl);\n\tconst keyCode = (keybinding & BinaryKeybindingsMask.KeyCode);\n\n\treturn new KeyCodeChord(ctrlKey, shiftKey, altKey, metaKey, keyCode);\n}\n\nexport interface Modifiers {\n\treadonly ctrlKey: boolean;\n\treadonly shiftKey: boolean;\n\treadonly altKey: boolean;\n\treadonly metaKey: boolean;\n}\n\n/**\n * Represents a chord which uses the `keyCode` field of keyboard events.\n * A chord is a combination of keys pressed simultaneously.\n */\nexport class KeyCodeChord implements Modifiers {\n\n\tconstructor(\n\t\tpublic readonly ctrlKey: boolean,\n\t\tpublic readonly shiftKey: boolean,\n\t\tpublic readonly altKey: boolean,\n\t\tpublic readonly metaKey: boolean,\n\t\tpublic readonly keyCode: KeyCode\n\t) { }\n\n\tpublic equals(other: Chord): boolean {\n\t\treturn (\n\t\t\tother instanceof KeyCodeChord\n\t\t\t&& this.ctrlKey === other.ctrlKey\n\t\t\t&& this.shiftKey === other.shiftKey\n\t\t\t&& this.altKey === other.altKey\n\t\t\t&& this.metaKey === other.metaKey\n\t\t\t&& this.keyCode === other.keyCode\n\t\t);\n\t}\n\n\tpublic getHashCode(): string {\n\t\tconst ctrl = this.ctrlKey ? '1' : '0';\n\t\tconst shift = this.shiftKey ? '1' : '0';\n\t\tconst alt = this.altKey ? '1' : '0';\n\t\tconst meta = this.metaKey ? '1' : '0';\n\t\treturn `K${ctrl}${shift}${alt}${meta}${this.keyCode}`;\n\t}\n\n\tpublic isModifierKey(): boolean {\n\t\treturn (\n\t\t\tthis.keyCode === KeyCode.Unknown\n\t\t\t|| this.keyCode === KeyCode.Ctrl\n\t\t\t|| this.keyCode === KeyCode.Meta\n\t\t\t|| this.keyCode === KeyCode.Alt\n\t\t\t|| this.keyCode === KeyCode.Shift\n\t\t);\n\t}\n\n\tpublic toKeybinding(): Keybinding {\n\t\treturn new Keybinding([this]);\n\t}\n\n\t/**\n\t * Does this keybinding refer to the key code of a modifier and it also has the modifier flag?\n\t */\n\tpublic isDuplicateModifierCase(): boolean {\n\t\treturn (\n\t\t\t(this.ctrlKey && this.keyCode === KeyCode.Ctrl)\n\t\t\t|| (this.shiftKey && this.keyCode === KeyCode.Shift)\n\t\t\t|| (this.altKey && this.keyCode === KeyCode.Alt)\n\t\t\t|| (this.metaKey && this.keyCode === KeyCode.Meta)\n\t\t);\n\t}\n}\n\n/**\n * Represents a chord which uses the `code` field of keyboard events.\n * A chord is a combination of keys pressed simultaneously.\n */\nexport class ScanCodeChord implements Modifiers {\n\n\tconstructor(\n\t\tpublic readonly ctrlKey: boolean,\n\t\tpublic readonly shiftKey: boolean,\n\t\tpublic readonly altKey: boolean,\n\t\tpublic readonly metaKey: boolean,\n\t\tpublic readonly scanCode: ScanCode\n\t) { }\n\n\tpublic equals(other: Chord): boolean {\n\t\treturn (\n\t\t\tother instanceof ScanCodeChord\n\t\t\t&& this.ctrlKey === other.ctrlKey\n\t\t\t&& this.shiftKey === other.shiftKey\n\t\t\t&& this.altKey === other.altKey\n\t\t\t&& this.metaKey === other.metaKey\n\t\t\t&& this.scanCode === other.scanCode\n\t\t);\n\t}\n\n\tpublic getHashCode(): string {\n\t\tconst ctrl = this.ctrlKey ? '1' : '0';\n\t\tconst shift = this.shiftKey ? '1' : '0';\n\t\tconst alt = this.altKey ? '1' : '0';\n\t\tconst meta = this.metaKey ? '1' : '0';\n\t\treturn `S${ctrl}${shift}${alt}${meta}${this.scanCode}`;\n\t}\n\n\t/**\n\t * Does this keybinding refer to the key code of a modifier and it also has the modifier flag?\n\t */\n\tpublic isDuplicateModifierCase(): boolean {\n\t\treturn (\n\t\t\t(this.ctrlKey && (this.scanCode === ScanCode.ControlLeft || this.scanCode === ScanCode.ControlRight))\n\t\t\t|| (this.shiftKey && (this.scanCode === ScanCode.ShiftLeft || this.scanCode === ScanCode.ShiftRight))\n\t\t\t|| (this.altKey && (this.scanCode === ScanCode.AltLeft || this.scanCode === ScanCode.AltRight))\n\t\t\t|| (this.metaKey && (this.scanCode === ScanCode.MetaLeft || this.scanCode === ScanCode.MetaRight))\n\t\t);\n\t}\n}\n\nexport type Chord = KeyCodeChord | ScanCodeChord;\n\n/**\n * A keybinding is a sequence of chords.\n */\nexport class Keybinding {\n\n\tpublic readonly chords: Chord[];\n\n\tconstructor(chords: Chord[]) {\n\t\tif (chords.length === 0) {\n\t\t\tthrow illegalArgument(`chords`);\n\t\t}\n\t\tthis.chords = chords;\n\t}\n\n\tpublic getHashCode(): string {\n\t\tlet result = '';\n\t\tfor (let i = 0, len = this.chords.length; i < len; i++) {\n\t\t\tif (i !== 0) {\n\t\t\t\tresult += ';';\n\t\t\t}\n\t\t\tresult += this.chords[i].getHashCode();\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic equals(other: Keybinding | null): boolean {\n\t\tif (other === null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.chords.length !== other.chords.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0; i < this.chords.length; i++) {\n\t\t\tif (!this.chords[i].equals(other.chords[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n\nexport class ResolvedChord {\n\tconstructor(\n\t\tpublic readonly ctrlKey: boolean,\n\t\tpublic readonly shiftKey: boolean,\n\t\tpublic readonly altKey: boolean,\n\t\tpublic readonly metaKey: boolean,\n\t\tpublic readonly keyLabel: string | null,\n\t\tpublic readonly keyAriaLabel: string | null\n\t) { }\n}\n\nexport type SingleModifierChord = 'ctrl' | 'shift' | 'alt' | 'meta';\n\n/**\n * A resolved keybinding. Consists of one or multiple chords.\n */\nexport abstract class ResolvedKeybinding {\n\t/**\n\t * This prints the binding in a format suitable for displaying in the UI.\n\t */\n\tpublic abstract getLabel(): string | null;\n\t/**\n\t * This prints the binding in a format suitable for ARIA.\n\t */\n\tpublic abstract getAriaLabel(): string | null;\n\t/**\n\t * This prints the binding in a format suitable for electron's accelerators.\n\t * See https://github.com/electron/electron/blob/master/docs/api/accelerator.md\n\t */\n\tpublic abstract getElectronAccelerator(): string | null;\n\t/**\n\t * This prints the binding in a format suitable for user settings.\n\t */\n\tpublic abstract getUserSettingsLabel(): string | null;\n\t/**\n\t * Is the user settings label reflecting the label?\n\t */\n\tpublic abstract isWYSIWYG(): boolean;\n\t/**\n\t * Does the keybinding consist of more than one chord?\n\t */\n\tpublic abstract hasMultipleChords(): boolean;\n\t/**\n\t * Returns the chords that comprise of the keybinding.\n\t */\n\tpublic abstract getChords(): ResolvedChord[];\n\t/**\n\t * Returns the chords as strings useful for dispatching.\n\t * Returns null for modifier only chords.\n\t * @example keybinding \"Shift\" -> null\n\t * @example keybinding (\"D\" with shift == true) -> \"shift+D\"\n\t */\n\tpublic abstract getDispatchChords(): (string | null)[];\n\t/**\n\t * Returns the modifier only chords as strings useful for dispatching.\n\t * Returns null for chords that contain more than one modifier or a regular key.\n\t * @example keybinding \"Shift\" -> \"shift\"\n\t * @example keybinding (\"D\" with shift == true\") -> null\n\t */\n\tpublic abstract getSingleModifierDispatchChords(): (SingleModifierChord | null)[];\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as browser from 'vs/base/browser/browser';\nimport { EVENT_KEY_CODE_MAP, KeyCode, KeyCodeUtils, KeyMod } from 'vs/base/common/keyCodes';\nimport { KeyCodeChord } from 'vs/base/common/keybindings';\nimport * as platform from 'vs/base/common/platform';\n\n\n\nfunction extractKeyCode(e: KeyboardEvent): KeyCode {\n\tif (e.charCode) {\n\t\t// \"keypress\" events mostly\n\t\tconst char = String.fromCharCode(e.charCode).toUpperCase();\n\t\treturn KeyCodeUtils.fromString(char);\n\t}\n\n\tconst keyCode = e.keyCode;\n\n\t// browser quirks\n\tif (keyCode === 3) {\n\t\treturn KeyCode.PauseBreak;\n\t} else if (browser.isFirefox) {\n\t\tswitch (keyCode) {\n\t\t\tcase 59: return KeyCode.Semicolon;\n\t\t\tcase 60:\n\t\t\t\tif (platform.isLinux) { return KeyCode.IntlBackslash; }\n\t\t\t\tbreak;\n\t\t\tcase 61: return KeyCode.Equal;\n\t\t\t// based on: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode#numpad_keys\n\t\t\tcase 107: return KeyCode.NumpadAdd;\n\t\t\tcase 109: return KeyCode.NumpadSubtract;\n\t\t\tcase 173: return KeyCode.Minus;\n\t\t\tcase 224:\n\t\t\t\tif (platform.isMacintosh) { return KeyCode.Meta; }\n\t\t\t\tbreak;\n\t\t}\n\t} else if (browser.isWebKit) {\n\t\tif (platform.isMacintosh && keyCode === 93) {\n\t\t\t// the two meta keys in the Mac have different key codes (91 and 93)\n\t\t\treturn KeyCode.Meta;\n\t\t} else if (!platform.isMacintosh && keyCode === 92) {\n\t\t\treturn KeyCode.Meta;\n\t\t}\n\t}\n\n\t// cross browser keycodes:\n\treturn EVENT_KEY_CODE_MAP[keyCode] || KeyCode.Unknown;\n}\n\nexport interface IKeyboardEvent {\n\n\treadonly _standardKeyboardEventBrand: true;\n\n\treadonly browserEvent: KeyboardEvent;\n\treadonly target: HTMLElement;\n\n\treadonly ctrlKey: boolean;\n\treadonly shiftKey: boolean;\n\treadonly altKey: boolean;\n\treadonly metaKey: boolean;\n\treadonly altGraphKey: boolean;\n\treadonly keyCode: KeyCode;\n\treadonly code: string;\n\n\t/**\n\t * @internal\n\t */\n\ttoKeyCodeChord(): KeyCodeChord;\n\tequals(keybinding: number): boolean;\n\n\tpreventDefault(): void;\n\tstopPropagation(): void;\n}\n\nconst ctrlKeyMod = (platform.isMacintosh ? KeyMod.WinCtrl : KeyMod.CtrlCmd);\nconst altKeyMod = KeyMod.Alt;\nconst shiftKeyMod = KeyMod.Shift;\nconst metaKeyMod = (platform.isMacintosh ? KeyMod.CtrlCmd : KeyMod.WinCtrl);\n\nexport function printKeyboardEvent(e: KeyboardEvent): string {\n\tconst modifiers: string[] = [];\n\tif (e.ctrlKey) {\n\t\tmodifiers.push(`ctrl`);\n\t}\n\tif (e.shiftKey) {\n\t\tmodifiers.push(`shift`);\n\t}\n\tif (e.altKey) {\n\t\tmodifiers.push(`alt`);\n\t}\n\tif (e.metaKey) {\n\t\tmodifiers.push(`meta`);\n\t}\n\treturn `modifiers: [${modifiers.join(',')}], code: ${e.code}, keyCode: ${e.keyCode}, key: ${e.key}`;\n}\n\nexport function printStandardKeyboardEvent(e: StandardKeyboardEvent): string {\n\tconst modifiers: string[] = [];\n\tif (e.ctrlKey) {\n\t\tmodifiers.push(`ctrl`);\n\t}\n\tif (e.shiftKey) {\n\t\tmodifiers.push(`shift`);\n\t}\n\tif (e.altKey) {\n\t\tmodifiers.push(`alt`);\n\t}\n\tif (e.metaKey) {\n\t\tmodifiers.push(`meta`);\n\t}\n\treturn `modifiers: [${modifiers.join(',')}], code: ${e.code}, keyCode: ${e.keyCode} ('${KeyCodeUtils.toString(e.keyCode)}')`;\n}\n\nexport class StandardKeyboardEvent implements IKeyboardEvent {\n\n\treadonly _standardKeyboardEventBrand = true;\n\n\tpublic readonly browserEvent: KeyboardEvent;\n\tpublic readonly target: HTMLElement;\n\n\tpublic readonly ctrlKey: boolean;\n\tpublic readonly shiftKey: boolean;\n\tpublic readonly altKey: boolean;\n\tpublic readonly metaKey: boolean;\n\tpublic readonly altGraphKey: boolean;\n\tpublic readonly keyCode: KeyCode;\n\tpublic readonly code: string;\n\n\tprivate _asKeybinding: number;\n\tprivate _asKeyCodeChord: KeyCodeChord;\n\n\tconstructor(source: KeyboardEvent) {\n\t\tconst e = source;\n\n\t\tthis.browserEvent = e;\n\t\tthis.target = <HTMLElement>e.target;\n\n\t\tthis.ctrlKey = e.ctrlKey;\n\t\tthis.shiftKey = e.shiftKey;\n\t\tthis.altKey = e.altKey;\n\t\tthis.metaKey = e.metaKey;\n\t\tthis.altGraphKey = e.getModifierState?.('AltGraph');\n\t\tthis.keyCode = extractKeyCode(e);\n\t\tthis.code = e.code;\n\n\t\t// console.info(e.type + \": keyCode: \" + e.keyCode + \", which: \" + e.which + \", charCode: \" + e.charCode + \", detail: \" + e.detail + \" ====> \" + this.keyCode + ' -- ' + KeyCode[this.keyCode]);\n\n\t\tthis.ctrlKey = this.ctrlKey || this.keyCode === KeyCode.Ctrl;\n\t\tthis.altKey = this.altKey || this.keyCode === KeyCode.Alt;\n\t\tthis.shiftKey = this.shiftKey || this.keyCode === KeyCode.Shift;\n\t\tthis.metaKey = this.metaKey || this.keyCode === KeyCode.Meta;\n\n\t\tthis._asKeybinding = this._computeKeybinding();\n\t\tthis._asKeyCodeChord = this._computeKeyCodeChord();\n\n\t\t// console.log(`code: ${e.code}, keyCode: ${e.keyCode}, key: ${e.key}`);\n\t}\n\n\tpublic preventDefault(): void {\n\t\tif (this.browserEvent && this.browserEvent.preventDefault) {\n\t\t\tthis.browserEvent.preventDefault();\n\t\t}\n\t}\n\n\tpublic stopPropagation(): void {\n\t\tif (this.browserEvent && this.browserEvent.stopPropagation) {\n\t\t\tthis.browserEvent.stopPropagation();\n\t\t}\n\t}\n\n\tpublic toKeyCodeChord(): KeyCodeChord {\n\t\treturn this._asKeyCodeChord;\n\t}\n\n\tpublic equals(other: number): boolean {\n\t\treturn this._asKeybinding === other;\n\t}\n\n\tprivate _computeKeybinding(): number {\n\t\tlet key = KeyCode.Unknown;\n\t\tif (this.keyCode !== KeyCode.Ctrl && this.keyCode !== KeyCode.Shift && this.keyCode !== KeyCode.Alt && this.keyCode !== KeyCode.Meta) {\n\t\t\tkey = this.keyCode;\n\t\t}\n\n\t\tlet result = 0;\n\t\tif (this.ctrlKey) {\n\t\t\tresult |= ctrlKeyMod;\n\t\t}\n\t\tif (this.altKey) {\n\t\t\tresult |= altKeyMod;\n\t\t}\n\t\tif (this.shiftKey) {\n\t\t\tresult |= shiftKeyMod;\n\t\t}\n\t\tif (this.metaKey) {\n\t\t\tresult |= metaKeyMod;\n\t\t}\n\t\tresult |= key;\n\n\t\treturn result;\n\t}\n\n\tprivate _computeKeyCodeChord(): KeyCodeChord {\n\t\tlet key = KeyCode.Unknown;\n\t\tif (this.keyCode !== KeyCode.Ctrl && this.keyCode !== KeyCode.Shift && this.keyCode !== KeyCode.Alt && this.keyCode !== KeyCode.Meta) {\n\t\t\tkey = this.keyCode;\n\t\t}\n\t\treturn new KeyCodeChord(this.ctrlKey, this.shiftKey, this.altKey, this.metaKey, key);\n\t}\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Represents a window in a possible chain of iframes\n */\ninterface IWindowChainElement {\n\t/**\n\t * The window object for it\n\t */\n\treadonly window: WeakRef<Window>;\n\t/**\n\t * The iframe element inside the window.parent corresponding to window\n\t */\n\treadonly iframeElement: Element | null;\n}\n\nconst sameOriginWindowChainCache = new WeakMap<Window, IWindowChainElement[] | null>();\n\nfunction getParentWindowIfSameOrigin(w: Window): Window | null {\n\tif (!w.parent || w.parent === w) {\n\t\treturn null;\n\t}\n\n\t// Cannot really tell if we have access to the parent window unless we try to access something in it\n\ttry {\n\t\tconst location = w.location;\n\t\tconst parentLocation = w.parent.location;\n\t\tif (location.origin !== 'null' && parentLocation.origin !== 'null' && location.origin !== parentLocation.origin) {\n\t\t\treturn null;\n\t\t}\n\t} catch (e) {\n\t\treturn null;\n\t}\n\n\treturn w.parent;\n}\n\nexport class IframeUtils {\n\n\t/**\n\t * Returns a chain of embedded windows with the same origin (which can be accessed programmatically).\n\t * Having a chain of length 1 might mean that the current execution environment is running outside of an iframe or inside an iframe embedded in a window with a different origin.\n\t */\n\tprivate static getSameOriginWindowChain(targetWindow: Window): IWindowChainElement[] {\n\t\tlet windowChainCache = sameOriginWindowChainCache.get(targetWindow);\n\t\tif (!windowChainCache) {\n\t\t\twindowChainCache = [];\n\t\t\tsameOriginWindowChainCache.set(targetWindow, windowChainCache);\n\t\t\tlet w: Window | null = targetWindow;\n\t\t\tlet parent: Window | null;\n\t\t\tdo {\n\t\t\t\tparent = getParentWindowIfSameOrigin(w);\n\t\t\t\tif (parent) {\n\t\t\t\t\twindowChainCache.push({\n\t\t\t\t\t\twindow: new WeakRef(w),\n\t\t\t\t\t\tiframeElement: w.frameElement || null\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\twindowChainCache.push({\n\t\t\t\t\t\twindow: new WeakRef(w),\n\t\t\t\t\t\tiframeElement: null\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tw = parent;\n\t\t\t} while (w);\n\t\t}\n\t\treturn windowChainCache.slice(0);\n\t}\n\n\t/**\n\t * Returns the position of `childWindow` relative to `ancestorWindow`\n\t */\n\tpublic static getPositionOfChildWindowRelativeToAncestorWindow(childWindow: Window, ancestorWindow: Window | null) {\n\n\t\tif (!ancestorWindow || childWindow === ancestorWindow) {\n\t\t\treturn {\n\t\t\t\ttop: 0,\n\t\t\t\tleft: 0\n\t\t\t};\n\t\t}\n\n\t\tlet top = 0, left = 0;\n\n\t\tconst windowChain = this.getSameOriginWindowChain(childWindow);\n\n\t\tfor (const windowChainEl of windowChain) {\n\t\t\tconst windowInChain = windowChainEl.window.deref();\n\t\t\ttop += windowInChain?.scrollY ?? 0;\n\t\t\tleft += windowInChain?.scrollX ?? 0;\n\n\t\t\tif (windowInChain === ancestorWindow) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!windowChainEl.iframeElement) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst boundingRect = windowChainEl.iframeElement.getBoundingClientRect();\n\t\t\ttop += boundingRect.top;\n\t\t\tleft += boundingRect.left;\n\t\t}\n\n\t\treturn {\n\t\t\ttop: top,\n\t\t\tleft: left\n\t\t};\n\t}\n}\n\n/**\n * Returns a sha-256 composed of `parentOrigin` and `salt` converted to base 32\n */\nexport async function parentOriginHash(parentOrigin: string, salt: string): Promise<string> {\n\t// This same code is also inlined at `src/vs/workbench/services/extensions/worker/webWorkerExtensionHostIframe.html`\n\tif (!crypto.subtle) {\n\t\tthrow new Error(`'crypto.subtle' is not available so webviews will not work. This is likely because the editor is not running in a secure context (https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts).`);\n\t}\n\n\tconst strData = JSON.stringify({ parentOrigin, salt });\n\tconst encoder = new TextEncoder();\n\tconst arrData = encoder.encode(strData);\n\tconst hash = await crypto.subtle.digest('sha-256', arrData);\n\treturn sha256AsBase32(hash);\n}\n\nfunction sha256AsBase32(bytes: ArrayBuffer): string {\n\tconst array = Array.from(new Uint8Array(bytes));\n\tconst hexArray = array.map(b => b.toString(16).padStart(2, '0')).join('');\n\t// sha256 has 256 bits, so we need at most ceil(lg(2^256-1)/lg(32)) = 52 chars to represent it in base 32\n\treturn BigInt(`0x${hexArray}`).toString(32).padStart(52, '0');\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as browser from 'vs/base/browser/browser';\nimport { IframeUtils } from 'vs/base/browser/iframe';\nimport * as platform from 'vs/base/common/platform';\n\nexport interface IMouseEvent {\n\treadonly browserEvent: MouseEvent;\n\treadonly leftButton: boolean;\n\treadonly middleButton: boolean;\n\treadonly rightButton: boolean;\n\treadonly buttons: number;\n\treadonly target: HTMLElement;\n\treadonly detail: number;\n\treadonly posx: number;\n\treadonly posy: number;\n\treadonly ctrlKey: boolean;\n\treadonly shiftKey: boolean;\n\treadonly altKey: boolean;\n\treadonly metaKey: boolean;\n\treadonly timestamp: number;\n\n\tpreventDefault(): void;\n\tstopPropagation(): void;\n}\n\nexport class StandardMouseEvent implements IMouseEvent {\n\n\tpublic readonly browserEvent: MouseEvent;\n\n\tpublic readonly leftButton: boolean;\n\tpublic readonly middleButton: boolean;\n\tpublic readonly rightButton: boolean;\n\tpublic readonly buttons: number;\n\tpublic readonly target: HTMLElement;\n\tpublic detail: number;\n\tpublic readonly posx: number;\n\tpublic readonly posy: number;\n\tpublic readonly ctrlKey: boolean;\n\tpublic readonly shiftKey: boolean;\n\tpublic readonly altKey: boolean;\n\tpublic readonly metaKey: boolean;\n\tpublic readonly timestamp: number;\n\n\tconstructor(targetWindow: Window, e: MouseEvent) {\n\t\tthis.timestamp = Date.now();\n\t\tthis.browserEvent = e;\n\t\tthis.leftButton = e.button === 0;\n\t\tthis.middleButton = e.button === 1;\n\t\tthis.rightButton = e.button === 2;\n\t\tthis.buttons = e.buttons;\n\n\t\tthis.target = <HTMLElement>e.target;\n\n\t\tthis.detail = e.detail || 1;\n\t\tif (e.type === 'dblclick') {\n\t\t\tthis.detail = 2;\n\t\t}\n\t\tthis.ctrlKey = e.ctrlKey;\n\t\tthis.shiftKey = e.shiftKey;\n\t\tthis.altKey = e.altKey;\n\t\tthis.metaKey = e.metaKey;\n\n\t\tif (typeof e.pageX === 'number') {\n\t\t\tthis.posx = e.pageX;\n\t\t\tthis.posy = e.pageY;\n\t\t} else {\n\t\t\t// Probably hit by MSGestureEvent\n\t\t\tthis.posx = e.clientX + this.target.ownerDocument.body.scrollLeft + this.target.ownerDocument.documentElement.scrollLeft;\n\t\t\tthis.posy = e.clientY + this.target.ownerDocument.body.scrollTop + this.target.ownerDocument.documentElement.scrollTop;\n\t\t}\n\n\t\t// Find the position of the iframe this code is executing in relative to the iframe where the event was captured.\n\t\tconst iframeOffsets = IframeUtils.getPositionOfChildWindowRelativeToAncestorWindow(targetWindow, e.view);\n\t\tthis.posx -= iframeOffsets.left;\n\t\tthis.posy -= iframeOffsets.top;\n\t}\n\n\tpublic preventDefault(): void {\n\t\tthis.browserEvent.preventDefault();\n\t}\n\n\tpublic stopPropagation(): void {\n\t\tthis.browserEvent.stopPropagation();\n\t}\n}\n\nexport class DragMouseEvent extends StandardMouseEvent {\n\n\tpublic readonly dataTransfer: DataTransfer;\n\n\tconstructor(targetWindow: Window, e: MouseEvent) {\n\t\tsuper(targetWindow, e);\n\t\tthis.dataTransfer = (<any>e).dataTransfer;\n\t}\n}\n\nexport interface IMouseWheelEvent extends MouseEvent {\n\treadonly wheelDelta: number;\n\treadonly wheelDeltaX: number;\n\treadonly wheelDeltaY: number;\n\n\treadonly deltaX: number;\n\treadonly deltaY: number;\n\treadonly deltaZ: number;\n\treadonly deltaMode: number;\n}\n\ninterface IWebKitMouseWheelEvent {\n\twheelDeltaY: number;\n\twheelDeltaX: number;\n}\n\ninterface IGeckoMouseWheelEvent {\n\tHORIZONTAL_AXIS: number;\n\tVERTICAL_AXIS: number;\n\taxis: number;\n\tdetail: number;\n}\n\nexport class StandardWheelEvent {\n\n\tpublic readonly browserEvent: IMouseWheelEvent | null;\n\tpublic readonly deltaY: number;\n\tpublic readonly deltaX: number;\n\tpublic readonly target: Node;\n\n\tconstructor(e: IMouseWheelEvent | null, deltaX: number = 0, deltaY: number = 0) {\n\n\t\tthis.browserEvent = e || null;\n\t\tthis.target = e ? (e.target || (<any>e).targetNode || e.srcElement) : null;\n\n\t\tthis.deltaY = deltaY;\n\t\tthis.deltaX = deltaX;\n\n\t\tlet shouldFactorDPR: boolean = false;\n\t\tif (browser.isChrome) {\n\t\t\t// Chrome version >= 123 contains the fix to factor devicePixelRatio into the wheel event.\n\t\t\t// See https://chromium.googlesource.com/chromium/src.git/+/be51b448441ff0c9d1f17e0f25c4bf1ab3f11f61\n\t\t\tconst chromeVersionMatch = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n\t\t\tconst chromeMajorVersion = chromeVersionMatch ? parseInt(chromeVersionMatch[1]) : 123;\n\t\t\tshouldFactorDPR = chromeMajorVersion <= 122;\n\t\t}\n\n\t\tif (e) {\n\t\t\t// Old (deprecated) wheel events\n\t\t\tconst e1 = <IWebKitMouseWheelEvent><any>e;\n\t\t\tconst e2 = <IGeckoMouseWheelEvent><any>e;\n\t\t\tconst devicePixelRatio = e.view?.devicePixelRatio || 1;\n\n\t\t\t// vertical delta scroll\n\t\t\tif (typeof e1.wheelDeltaY !== 'undefined') {\n\t\t\t\tif (shouldFactorDPR) {\n\t\t\t\t\t// Refs https://github.com/microsoft/vscode/issues/146403#issuecomment-1854538928\n\t\t\t\t\tthis.deltaY = e1.wheelDeltaY / (120 * devicePixelRatio);\n\t\t\t\t} else {\n\t\t\t\t\tthis.deltaY = e1.wheelDeltaY / 120;\n\t\t\t\t}\n\t\t\t} else if (typeof e2.VERTICAL_AXIS !== 'undefined' && e2.axis === e2.VERTICAL_AXIS) {\n\t\t\t\tthis.deltaY = -e2.detail / 3;\n\t\t\t} else if (e.type === 'wheel') {\n\t\t\t\t// Modern wheel event\n\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent\n\t\t\t\tconst ev = <WheelEvent><unknown>e;\n\n\t\t\t\tif (ev.deltaMode === ev.DOM_DELTA_LINE) {\n\t\t\t\t\t// the deltas are expressed in lines\n\t\t\t\t\tif (browser.isFirefox && !platform.isMacintosh) {\n\t\t\t\t\t\tthis.deltaY = -e.deltaY / 3;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.deltaY = -e.deltaY;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.deltaY = -e.deltaY / 40;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// horizontal delta scroll\n\t\t\tif (typeof e1.wheelDeltaX !== 'undefined') {\n\t\t\t\tif (browser.isSafari && platform.isWindows) {\n\t\t\t\t\tthis.deltaX = - (e1.wheelDeltaX / 120);\n\t\t\t\t} else if (shouldFactorDPR) {\n\t\t\t\t\t// Refs https://github.com/microsoft/vscode/issues/146403#issuecomment-1854538928\n\t\t\t\t\tthis.deltaX = e1.wheelDeltaX / (120 * devicePixelRatio);\n\t\t\t\t} else {\n\t\t\t\t\tthis.deltaX = e1.wheelDeltaX / 120;\n\t\t\t\t}\n\t\t\t} else if (typeof e2.HORIZONTAL_AXIS !== 'undefined' && e2.axis === e2.HORIZONTAL_AXIS) {\n\t\t\t\tthis.deltaX = -e.detail / 3;\n\t\t\t} else if (e.type === 'wheel') {\n\t\t\t\t// Modern wheel event\n\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent\n\t\t\t\tconst ev = <WheelEvent><unknown>e;\n\n\t\t\t\tif (ev.deltaMode === ev.DOM_DELTA_LINE) {\n\t\t\t\t\t// the deltas are expressed in lines\n\t\t\t\t\tif (browser.isFirefox && !platform.isMacintosh) {\n\t\t\t\t\t\tthis.deltaX = -e.deltaX / 3;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.deltaX = -e.deltaX;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.deltaX = -e.deltaX / 40;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Assume a vertical scroll if nothing else worked\n\t\t\tif (this.deltaY === 0 && this.deltaX === 0 && e.wheelDelta) {\n\t\t\t\tif (shouldFactorDPR) {\n\t\t\t\t\t// Refs https://github.com/microsoft/vscode/issues/146403#issuecomment-1854538928\n\t\t\t\t\tthis.deltaY = e.wheelDelta / (120 * devicePixelRatio);\n\t\t\t\t} else {\n\t\t\t\t\tthis.deltaY = e.wheelDelta / 120;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic preventDefault(): void {\n\t\tthis.browserEvent?.preventDefault();\n\t}\n\n\tpublic stopPropagation(): void {\n\t\tthis.browserEvent?.stopPropagation();\n\t}\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { DisposableStore, IDisposable } from 'vs/base/common/lifecycle';\n\nexport interface CancellationToken {\n\n\t/**\n\t * A flag signalling is cancellation has been requested.\n\t */\n\treadonly isCancellationRequested: boolean;\n\n\t/**\n\t * An event which fires when cancellation is requested. This event\n\t * only ever fires `once` as cancellation can only happen once. Listeners\n\t * that are registered after cancellation will be called (next event loop run),\n\t * but also only once.\n\t *\n\t * @event\n\t */\n\treadonly onCancellationRequested: (listener: (e: any) => any, thisArgs?: any, disposables?: IDisposable[]) => IDisposable;\n}\n\nconst shortcutEvent: Event<any> = Object.freeze(function (callback, context?): IDisposable {\n\tconst handle = setTimeout(callback.bind(context), 0);\n\treturn { dispose() { clearTimeout(handle); } };\n});\n\nexport namespace CancellationToken {\n\n\texport function isCancellationToken(thing: unknown): thing is CancellationToken {\n\t\tif (thing === CancellationToken.None || thing === CancellationToken.Cancelled) {\n\t\t\treturn true;\n\t\t}\n\t\tif (thing instanceof MutableToken) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!thing || typeof thing !== 'object') {\n\t\t\treturn false;\n\t\t}\n\t\treturn typeof (thing as CancellationToken).isCancellationRequested === 'boolean'\n\t\t\t&& typeof (thing as CancellationToken).onCancellationRequested === 'function';\n\t}\n\n\n\texport const None = Object.freeze<CancellationToken>({\n\t\tisCancellationRequested: false,\n\t\tonCancellationRequested: Event.None\n\t});\n\n\texport const Cancelled = Object.freeze<CancellationToken>({\n\t\tisCancellationRequested: true,\n\t\tonCancellationRequested: shortcutEvent\n\t});\n}\n\nclass MutableToken implements CancellationToken {\n\n\tprivate _isCancelled: boolean = false;\n\tprivate _emitter: Emitter<any> | null = null;\n\n\tpublic cancel() {\n\t\tif (!this._isCancelled) {\n\t\t\tthis._isCancelled = true;\n\t\t\tif (this._emitter) {\n\t\t\t\tthis._emitter.fire(undefined);\n\t\t\t\tthis.dispose();\n\t\t\t}\n\t\t}\n\t}\n\n\tget isCancellationRequested(): boolean {\n\t\treturn this._isCancelled;\n\t}\n\n\tget onCancellationRequested(): Event<any> {\n\t\tif (this._isCancelled) {\n\t\t\treturn shortcutEvent;\n\t\t}\n\t\tif (!this._emitter) {\n\t\t\tthis._emitter = new Emitter<any>();\n\t\t}\n\t\treturn this._emitter.event;\n\t}\n\n\tpublic dispose(): void {\n\t\tif (this._emitter) {\n\t\t\tthis._emitter.dispose();\n\t\t\tthis._emitter = null;\n\t\t}\n\t}\n}\n\nexport class CancellationTokenSource {\n\n\tprivate _token?: CancellationToken = undefined;\n\tprivate _parentListener?: IDisposable = undefined;\n\n\tconstructor(parent?: CancellationToken) {\n\t\tthis._parentListener = parent && parent.onCancellationRequested(this.cancel, this);\n\t}\n\n\tget token(): CancellationToken {\n\t\tif (!this._token) {\n\t\t\t// be lazy and create the token only when\n\t\t\t// actually needed\n\t\t\tthis._token = new MutableToken();\n\t\t}\n\t\treturn this._token;\n\t}\n\n\tcancel(): void {\n\t\tif (!this._token) {\n\t\t\t// save an object by returning the default\n\t\t\t// cancelled token when cancellation happens\n\t\t\t// before someone asks for the token\n\t\t\tthis._token = CancellationToken.Cancelled;\n\n\t\t} else if (this._token instanceof MutableToken) {\n\t\t\t// actually cancel\n\t\t\tthis._token.cancel();\n\t\t}\n\t}\n\n\tdispose(cancel: boolean = false): void {\n\t\tif (cancel) {\n\t\t\tthis.cancel();\n\t\t}\n\t\tthis._parentListener?.dispose();\n\t\tif (!this._token) {\n\t\t\t// ensure to initialize with an empty token if we had none\n\t\t\tthis._token = CancellationToken.None;\n\n\t\t} else if (this._token instanceof MutableToken) {\n\t\t\t// actually dispose\n\t\t\tthis._token.dispose();\n\t\t}\n\t}\n}\n\nexport function cancelOnDispose(store: DisposableStore): CancellationToken {\n\tconst source = new CancellationTokenSource();\n\tstore.add({ dispose() { source.cancel(); } });\n\treturn source.token;\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Can be passed into the Delayed to defer using a microtask\n * */\nexport const MicrotaskDelay = Symbol('MicrotaskDelay');\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport { BugIndicatingError, CancellationError } from 'vs/base/common/errors';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { Disposable, DisposableStore, IDisposable, MutableDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { setTimeout0 } from 'vs/base/common/platform';\nimport { MicrotaskDelay } from './symbols';\nimport { Lazy } from 'vs/base/common/lazy';\n\nexport function isThenable<T>(obj: unknown): obj is Promise<T> {\n\treturn !!obj && typeof (obj as unknown as Promise<T>).then === 'function';\n}\n\nexport interface CancelablePromise<T> extends Promise<T> {\n\tcancel(): void;\n}\n\nexport function createCancelablePromise<T>(callback: (token: CancellationToken) => Promise<T>): CancelablePromise<T> {\n\tconst source = new CancellationTokenSource();\n\n\tconst thenable = callback(source.token);\n\tconst promise = new Promise<T>((resolve, reject) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tsubscription.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tPromise.resolve(thenable).then(value => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\tresolve(value);\n\t\t}, err => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\treject(err);\n\t\t});\n\t});\n\n\treturn <CancelablePromise<T>>new class {\n\t\tcancel() {\n\t\t\tsource.cancel();\n\t\t\tsource.dispose();\n\t\t}\n\t\tthen<TResult1 = T, TResult2 = never>(resolve?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, reject?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2> {\n\t\t\treturn promise.then(resolve, reject);\n\t\t}\n\t\tcatch<TResult = never>(reject?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult> {\n\t\t\treturn this.then(undefined, reject);\n\t\t}\n\t\tfinally(onfinally?: (() => void) | undefined | null): Promise<T> {\n\t\t\treturn promise.finally(onfinally);\n\t\t}\n\t};\n}\n\n/**\n * Returns a promise that resolves with `undefined` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken): Promise<T | undefined>;\n\n/**\n * Returns a promise that resolves with `defaultValue` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue: T): Promise<T>;\n\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue?: T): Promise<T | undefined> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\tresolve(defaultValue);\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Returns a promise that rejects with an {@CancellationError} as soon as the passed token is cancelled.\n * @see {@link raceCancellation}\n */\nexport function raceCancellationError<T>(promise: Promise<T>, token: CancellationToken): Promise<T> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Returns as soon as one of the promises resolves or rejects and cancels remaining promises\n */\nexport async function raceCancellablePromises<T>(cancellablePromises: CancelablePromise<T>[]): Promise<T> {\n\tlet resolvedPromiseIndex = -1;\n\tconst promises = cancellablePromises.map((promise, index) => promise.then(result => { resolvedPromiseIndex = index; return result; }));\n\ttry {\n\t\tconst result = await Promise.race(promises);\n\t\treturn result;\n\t} finally {\n\t\tcancellablePromises.forEach((cancellablePromise, index) => {\n\t\t\tif (index !== resolvedPromiseIndex) {\n\t\t\t\tcancellablePromise.cancel();\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport function raceTimeout<T>(promise: Promise<T>, timeout: number, onTimeout?: () => void): Promise<T | undefined> {\n\tlet promiseResolve: ((value: T | undefined) => void) | undefined = undefined;\n\n\tconst timer = setTimeout(() => {\n\t\tpromiseResolve?.(undefined);\n\t\tonTimeout?.();\n\t}, timeout);\n\n\treturn Promise.race([\n\t\tpromise.finally(() => clearTimeout(timer)),\n\t\tnew Promise<T | undefined>(resolve => promiseResolve = resolve)\n\t]);\n}\n\nexport function asPromise<T>(callback: () => T | Thenable<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tconst item = callback();\n\t\tif (isThenable<T>(item)) {\n\t\t\titem.then(resolve, reject);\n\t\t} else {\n\t\t\tresolve(item);\n\t\t}\n\t});\n}\n\n/**\n * Creates and returns a new promise, plus its `resolve` and `reject` callbacks.\n *\n * Replace with standardized [`Promise.withResolvers`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers) once it is supported\n */\nexport function promiseWithResolvers<T>(): { promise: Promise<T>; resolve: (value: T | PromiseLike<T>) => void; reject: (err?: any) => void } {\n\tlet resolve: (value: T | PromiseLike<T>) => void;\n\tlet reject: (reason?: any) => void;\n\tconst promise = new Promise<T>((res, rej) => {\n\t\tresolve = res;\n\t\treject = rej;\n\t});\n\treturn { promise, resolve: resolve!, reject: reject! };\n}\n\nexport interface ITask<T> {\n\t(): T;\n}\n\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler implements IDisposable {\n\n\tprivate activePromise: Promise<any> | null;\n\tprivate queuedPromise: Promise<any> | null;\n\tprivate queuedPromiseFactory: ITask<Promise<any>> | null;\n\n\tprivate isDisposed = false;\n\n\tconstructor() {\n\t\tthis.activePromise = null;\n\t\tthis.queuedPromise = null;\n\t\tthis.queuedPromiseFactory = null;\n\t}\n\n\tqueue<T>(promiseFactory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this.isDisposed) {\n\t\t\treturn Promise.reject(new Error('Throttler is disposed'));\n\t\t}\n\n\t\tif (this.activePromise) {\n\t\t\tthis.queuedPromiseFactory = promiseFactory;\n\n\t\t\tif (!this.queuedPromise) {\n\t\t\t\tconst onComplete = () => {\n\t\t\t\t\tthis.queuedPromise = null;\n\n\t\t\t\t\tif (this.isDisposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = this.queue(this.queuedPromiseFactory!);\n\t\t\t\t\tthis.queuedPromiseFactory = null;\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\tthis.queuedPromise = new Promise(resolve => {\n\t\t\t\t\tthis.activePromise!.then(onComplete, onComplete).then(resolve);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tthis.queuedPromise!.then(resolve, reject);\n\t\t\t});\n\t\t}\n\n\t\tthis.activePromise = promiseFactory();\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.activePromise!.then((result: T) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\tresolve(result);\n\t\t\t}, (err: unknown) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\treject(err);\n\t\t\t});\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tthis.isDisposed = true;\n\t}\n}\n\nexport class Sequencer {\n\n\tprivate current: Promise<unknown> = Promise.resolve(null);\n\n\tqueue<T>(promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\treturn this.current = this.current.then(() => promiseTask(), () => promiseTask());\n\t}\n}\n\nexport class SequencerByKey<TKey> {\n\n\tprivate promiseMap = new Map<TKey, Promise<unknown>>();\n\n\tqueue<T>(key: TKey, promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\tconst runningPromise = this.promiseMap.get(key) ?? Promise.resolve();\n\t\tconst newPromise = runningPromise\n\t\t\t.catch(() => { })\n\t\t\t.then(promiseTask)\n\t\t\t.finally(() => {\n\t\t\t\tif (this.promiseMap.get(key) === newPromise) {\n\t\t\t\t\tthis.promiseMap.delete(key);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.promiseMap.set(key, newPromise);\n\t\treturn newPromise;\n\t}\n}\n\ninterface IScheduledLater extends IDisposable {\n\tisTriggered(): boolean;\n}\n\nconst timeoutDeferred = (timeout: number, fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tconst handle = setTimeout(() => {\n\t\tscheduled = false;\n\t\tfn();\n\t}, timeout);\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => {\n\t\t\tclearTimeout(handle);\n\t\t\tscheduled = false;\n\t\t},\n\t};\n};\n\nconst microtaskDeferred = (fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tqueueMicrotask(() => {\n\t\tif (scheduled) {\n\t\t\tscheduled = false;\n\t\t\tfn();\n\t\t}\n\t});\n\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => { scheduled = false; },\n\t};\n};\n\n/**\n * A helper to delay (debounce) execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer<T> implements IDisposable {\n\n\tprivate deferred: IScheduledLater | null;\n\tprivate completionPromise: Promise<any> | null;\n\tprivate doResolve: ((value?: any | Promise<any>) => void) | null;\n\tprivate doReject: ((err: any) => void) | null;\n\tprivate task: ITask<T | Promise<T>> | null;\n\n\tconstructor(public defaultDelay: number | typeof MicrotaskDelay) {\n\t\tthis.deferred = null;\n\t\tthis.completionPromise = null;\n\t\tthis.doResolve = null;\n\t\tthis.doReject = null;\n\t\tthis.task = null;\n\t}\n\n\ttrigger(task: ITask<T | Promise<T>>, delay = this.defaultDelay): Promise<T> {\n\t\tthis.task = task;\n\t\tthis.cancelTimeout();\n\n\t\tif (!this.completionPromise) {\n\t\t\tthis.completionPromise = new Promise((resolve, reject) => {\n\t\t\t\tthis.doResolve = resolve;\n\t\t\t\tthis.doReject = reject;\n\t\t\t}).then(() => {\n\t\t\t\tthis.completionPromise = null;\n\t\t\t\tthis.doResolve = null;\n\t\t\t\tif (this.task) {\n\t\t\t\t\tconst task = this.task;\n\t\t\t\t\tthis.task = null;\n\t\t\t\t\treturn task();\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t});\n\t\t}\n\n\t\tconst fn = () => {\n\t\t\tthis.deferred = null;\n\t\t\tthis.doResolve?.(null);\n\t\t};\n\n\t\tthis.deferred = delay === MicrotaskDelay ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);\n\n\t\treturn this.completionPromise;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn !!this.deferred?.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.cancelTimeout();\n\n\t\tif (this.completionPromise) {\n\t\t\tthis.doReject?.(new CancellationError());\n\t\t\tthis.completionPromise = null;\n\t\t}\n\t}\n\n\tprivate cancelTimeout(): void {\n\t\tthis.deferred?.dispose();\n\t\tthis.deferred = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer<T> {\n\n\tprivate delayer: Delayer<Promise<T>>;\n\tprivate throttler: Throttler;\n\n\tconstructor(defaultDelay: number) {\n\t\tthis.delayer = new Delayer(defaultDelay);\n\t\tthis.throttler = new Throttler();\n\t}\n\n\ttrigger(promiseFactory: ITask<Promise<T>>, delay?: number): Promise<T> {\n\t\treturn this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay) as unknown as Promise<T>;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.delayer.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.delayer.cancel();\n\t}\n\n\tdispose(): void {\n\t\tthis.delayer.dispose();\n\t\tthis.throttler.dispose();\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently.\n */\nexport class Barrier {\n\tprivate _isOpen: boolean;\n\tprivate _promise: Promise<boolean>;\n\tprivate _completePromise!: (v: boolean) => void;\n\n\tconstructor() {\n\t\tthis._isOpen = false;\n\t\tthis._promise = new Promise<boolean>((c, e) => {\n\t\t\tthis._completePromise = c;\n\t\t});\n\t}\n\n\tisOpen(): boolean {\n\t\treturn this._isOpen;\n\t}\n\n\topen(): void {\n\t\tthis._isOpen = true;\n\t\tthis._completePromise(true);\n\t}\n\n\twait(): Promise<boolean> {\n\t\treturn this._promise;\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently after a certain period of\n * time or when open is called explicitly\n */\nexport class AutoOpenBarrier extends Barrier {\n\n\tprivate readonly _timeout: any;\n\n\tconstructor(autoOpenTimeMs: number) {\n\t\tsuper();\n\t\tthis._timeout = setTimeout(() => this.open(), autoOpenTimeMs);\n\t}\n\n\toverride open(): void {\n\t\tclearTimeout(this._timeout);\n\t\tsuper.open();\n\t}\n}\n\nexport function timeout(millis: number): CancelablePromise<void>;\nexport function timeout(millis: number, token: CancellationToken): Promise<void>;\nexport function timeout(millis: number, token?: CancellationToken): CancelablePromise<void> | Promise<void> {\n\tif (!token) {\n\t\treturn createCancelablePromise(token => timeout(millis, token));\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\tconst handle = setTimeout(() => {\n\t\t\tdisposable.dispose();\n\t\t\tresolve();\n\t\t}, millis);\n\t\tconst disposable = token.onCancellationRequested(() => {\n\t\t\tclearTimeout(handle);\n\t\t\tdisposable.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t});\n}\n\n/**\n * Creates a timeout that can be disposed using its returned value.\n * @param handler The timeout handler.\n * @param timeout An optional timeout in milliseconds.\n * @param store An optional {@link DisposableStore} that will have the timeout disposable managed automatically.\n *\n * @example\n * const store = new DisposableStore;\n * // Call the timeout after 1000ms at which point it will be automatically\n * // evicted from the store.\n * const timeoutDisposable = disposableTimeout(() => {}, 1000, store);\n *\n * if (foo) {\n *   // Cancel the timeout and evict it from store.\n *   timeoutDisposable.dispose();\n * }\n */\nexport function disposableTimeout(handler: () => void, timeout = 0, store?: DisposableStore): IDisposable {\n\tconst timer = setTimeout(() => {\n\t\thandler();\n\t\tif (store) {\n\t\t\tdisposable.dispose();\n\t\t}\n\t}, timeout);\n\tconst disposable = toDisposable(() => {\n\t\tclearTimeout(timer);\n\t\tstore?.deleteAndLeak(disposable);\n\t});\n\tstore?.add(disposable);\n\treturn disposable;\n}\n\n/**\n * Runs the provided list of promise factories in sequential order. The returned\n * promise will complete to an array of results from each promise.\n */\n\nexport function sequence<T>(promiseFactories: ITask<Promise<T>>[]): Promise<T[]> {\n\tconst results: T[] = [];\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tfunction next(): Promise<T> | null {\n\t\treturn index < len ? promiseFactories[index++]() : null;\n\t}\n\n\tfunction thenHandler(result: any): Promise<any> {\n\t\tif (result !== undefined && result !== null) {\n\t\t\tresults.push(result);\n\t\t}\n\n\t\tconst n = next();\n\t\tif (n) {\n\t\t\treturn n.then(thenHandler);\n\t\t}\n\n\t\treturn Promise.resolve(results);\n\t}\n\n\treturn Promise.resolve(null).then(thenHandler);\n}\n\nexport function first<T>(promiseFactories: ITask<Promise<T>>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null): Promise<T | null> {\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tconst loop: () => Promise<T | null> = () => {\n\t\tif (index >= len) {\n\t\t\treturn Promise.resolve(defaultValue);\n\t\t}\n\n\t\tconst factory = promiseFactories[index++];\n\t\tconst promise = Promise.resolve(factory());\n\n\t\treturn promise.then(result => {\n\t\t\tif (shouldStop(result)) {\n\t\t\t\treturn Promise.resolve(result);\n\t\t\t}\n\n\t\t\treturn loop();\n\t\t});\n\t};\n\n\treturn loop();\n}\n\n/**\n * Returns the result of the first promise that matches the \"shouldStop\",\n * running all promises in parallel. Supports cancelable promises.\n */\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop?: (t: T) => boolean, defaultValue?: T | null): Promise<T | null>;\nexport function firstParallel<T, R extends T>(promiseList: Promise<T>[], shouldStop: (t: T) => t is R, defaultValue?: R | null): Promise<R | null>;\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null) {\n\tif (promiseList.length === 0) {\n\t\treturn Promise.resolve(defaultValue);\n\t}\n\n\tlet todo = promiseList.length;\n\tconst finish = () => {\n\t\ttodo = -1;\n\t\tfor (const promise of promiseList) {\n\t\t\t(promise as Partial<CancelablePromise<T>>).cancel?.();\n\t\t}\n\t};\n\n\treturn new Promise<T | null>((resolve, reject) => {\n\t\tfor (const promise of promiseList) {\n\t\t\tpromise.then(result => {\n\t\t\t\tif (--todo >= 0 && shouldStop(result)) {\n\t\t\t\t\tfinish();\n\t\t\t\t\tresolve(result);\n\t\t\t\t} else if (todo === 0) {\n\t\t\t\t\tresolve(defaultValue);\n\t\t\t\t}\n\t\t\t})\n\t\t\t\t.catch(err => {\n\t\t\t\t\tif (--todo >= 0) {\n\t\t\t\t\t\tfinish();\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t});\n}\n\ninterface ILimitedTaskFactory<T> {\n\tfactory: ITask<Promise<T>>;\n\tc: (value: T | Promise<T>) => void;\n\te: (error?: unknown) => void;\n}\n\nexport interface ILimiter<T> {\n\n\treadonly size: number;\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T>;\n\n\tclear(): void;\n}\n\n/**\n * A helper to queue N promises and run them all with a max degree of parallelism. The helper\n * ensures that at any time no more than M promises are running at the same time.\n */\nexport class Limiter<T> implements ILimiter<T> {\n\n\tprivate _size = 0;\n\tprivate _isDisposed = false;\n\tprivate runningPromises: number;\n\tprivate readonly maxDegreeOfParalellism: number;\n\tprivate readonly outstandingPromises: ILimitedTaskFactory<T>[];\n\tprivate readonly _onDrained: Emitter<void>;\n\n\tconstructor(maxDegreeOfParalellism: number) {\n\t\tthis.maxDegreeOfParalellism = maxDegreeOfParalellism;\n\t\tthis.outstandingPromises = [];\n\t\tthis.runningPromises = 0;\n\t\tthis._onDrained = new Emitter<void>();\n\t}\n\n\t/**\n\t *\n\t * @returns A promise that resolved when all work is done (onDrained) or when\n\t * there is nothing to do\n\t */\n\twhenIdle(): Promise<void> {\n\t\treturn this.size > 0\n\t\t\t? Event.toPromise(this.onDrained)\n\t\t\t: Promise.resolve();\n\t}\n\n\tget onDrained(): Event<void> {\n\t\treturn this._onDrained.event;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new Error('Object has been disposed');\n\t\t}\n\t\tthis._size++;\n\n\t\treturn new Promise<T>((c, e) => {\n\t\t\tthis.outstandingPromises.push({ factory, c, e });\n\t\t\tthis.consume();\n\t\t});\n\t}\n\n\tprivate consume(): void {\n\t\twhile (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n\t\t\tconst iLimitedTask = this.outstandingPromises.shift()!;\n\t\t\tthis.runningPromises++;\n\n\t\t\tconst promise = iLimitedTask.factory();\n\t\t\tpromise.then(iLimitedTask.c, iLimitedTask.e);\n\t\t\tpromise.then(() => this.consumed(), () => this.consumed());\n\t\t}\n\t}\n\n\tprivate consumed(): void {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\tthis.runningPromises--;\n\t\tif (--this._size === 0) {\n\t\t\tthis._onDrained.fire();\n\t\t}\n\n\t\tif (this.outstandingPromises.length > 0) {\n\t\t\tthis.consume();\n\t\t}\n\t}\n\n\tclear(): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new Error('Object has been disposed');\n\t\t}\n\t\tthis.outstandingPromises.length = 0;\n\t\tthis._size = this.runningPromises;\n\t}\n\n\tdispose(): void {\n\t\tthis._isDisposed = true;\n\t\tthis.outstandingPromises.length = 0; // stop further processing\n\t\tthis._size = 0;\n\t\tthis._onDrained.dispose();\n\t}\n}\n\n/**\n * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.\n */\nexport class Queue<T> extends Limiter<T> {\n\n\tconstructor() {\n\t\tsuper(1);\n\t}\n}\n\n/**\n * Same as `Queue`, ensures that only 1 task is executed at the same time. The difference to `Queue` is that\n * there is only 1 task about to be scheduled next. As such, calling `queue` while a task is executing will\n * replace the currently queued task until it executes.\n *\n * As such, the returned promise may not be from the factory that is passed in but from the next factory that\n * is running after having called `queue`.\n */\nexport class LimitedQueue {\n\n\tprivate readonly sequentializer = new TaskSequentializer();\n\n\tprivate tasks = 0;\n\n\tqueue(factory: ITask<Promise<void>>): Promise<void> {\n\t\tif (!this.sequentializer.isRunning()) {\n\t\t\treturn this.sequentializer.run(this.tasks++, factory());\n\t\t}\n\n\t\treturn this.sequentializer.queue(() => {\n\t\t\treturn this.sequentializer.run(this.tasks++, factory());\n\t\t});\n\t}\n}\n\nexport class TimeoutTimer implements IDisposable {\n\tprivate _token: any;\n\tprivate _isDisposed = false;\n\n\tconstructor();\n\tconstructor(runner: () => void, timeout: number);\n\tconstructor(runner?: () => void, timeout?: number) {\n\t\tthis._token = -1;\n\n\t\tif (typeof runner === 'function' && typeof timeout === 'number') {\n\t\t\tthis.setIfNotSet(runner, timeout);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis._isDisposed = true;\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearTimeout(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, timeout: number): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new BugIndicatingError(`Calling 'cancelAndSet' on a disposed TimeoutTimer`);\n\t\t}\n\n\t\tthis.cancel();\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n\n\tsetIfNotSet(runner: () => void, timeout: number): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new BugIndicatingError(`Calling 'setIfNotSet' on a disposed TimeoutTimer`);\n\t\t}\n\n\t\tif (this._token !== -1) {\n\t\t\t// timer is already set\n\t\t\treturn;\n\t\t}\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n}\n\nexport class IntervalTimer implements IDisposable {\n\n\tprivate disposable: IDisposable | undefined = undefined;\n\tprivate isDisposed = false;\n\n\tcancel(): void {\n\t\tthis.disposable?.dispose();\n\t\tthis.disposable = undefined;\n\t}\n\n\tcancelAndSet(runner: () => void, interval: number, context = globalThis): void {\n\t\tif (this.isDisposed) {\n\t\t\tthrow new BugIndicatingError(`Calling 'cancelAndSet' on a disposed IntervalTimer`);\n\t\t}\n\n\t\tthis.cancel();\n\t\tconst handle = context.setInterval(() => {\n\t\t\trunner();\n\t\t}, interval);\n\n\t\tthis.disposable = toDisposable(() => {\n\t\t\tcontext.clearInterval(handle);\n\t\t\tthis.disposable = undefined;\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.isDisposed = true;\n\t}\n}\n\nexport class RunOnceScheduler implements IDisposable {\n\n\tprotected runner: ((...args: unknown[]) => void) | null;\n\n\tprivate timeoutToken: any;\n\tprivate timeout: number;\n\tprivate timeoutHandler: () => void;\n\n\tconstructor(runner: (...args: any[]) => void, delay: number) {\n\t\tthis.timeoutToken = -1;\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.timeoutHandler = this.onTimeout.bind(this);\n\t}\n\n\t/**\n\t * Dispose RunOnceScheduler\n\t */\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\t/**\n\t * Cancel current scheduled runner (if any).\n\t */\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearTimeout(this.timeoutToken);\n\t\t\tthis.timeoutToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tthis.cancel();\n\t\tthis.timeoutToken = setTimeout(this.timeoutHandler, delay);\n\t}\n\n\tget delay(): number {\n\t\treturn this.timeout;\n\t}\n\n\tset delay(value: number) {\n\t\tthis.timeout = value;\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.timeoutToken !== -1;\n\t}\n\n\tflush(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tthis.cancel();\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprivate onTimeout() {\n\t\tthis.timeoutToken = -1;\n\t\tif (this.runner) {\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tthis.runner?.();\n\t}\n}\n\n/**\n * Same as `RunOnceScheduler`, but doesn't count the time spent in sleep mode.\n * > **NOTE**: Only offers 1s resolution.\n *\n * When calling `setTimeout` with 3hrs, and putting the computer immediately to sleep\n * for 8hrs, `setTimeout` will fire **as soon as the computer wakes from sleep**. But\n * this scheduler will execute 3hrs **after waking the computer from sleep**.\n */\nexport class ProcessTimeRunOnceScheduler {\n\n\tprivate runner: (() => void) | null;\n\tprivate timeout: number;\n\n\tprivate counter: number;\n\tprivate intervalToken: any;\n\tprivate intervalHandler: () => void;\n\n\tconstructor(runner: () => void, delay: number) {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.counter = 0;\n\t\tthis.intervalToken = -1;\n\t\tthis.intervalHandler = this.onInterval.bind(this);\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearInterval(this.intervalToken);\n\t\t\tthis.intervalToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.cancel();\n\t\tthis.counter = Math.ceil(delay / 1000);\n\t\tthis.intervalToken = setInterval(this.intervalHandler, 1000);\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.intervalToken !== -1;\n\t}\n\n\tprivate onInterval() {\n\t\tthis.counter--;\n\t\tif (this.counter > 0) {\n\t\t\t// still need to wait\n\t\t\treturn;\n\t\t}\n\n\t\t// time elapsed\n\t\tclearInterval(this.intervalToken);\n\t\tthis.intervalToken = -1;\n\t\tthis.runner?.();\n\t}\n}\n\nexport class RunOnceWorker<T> extends RunOnceScheduler {\n\n\tprivate units: T[] = [];\n\n\tconstructor(runner: (units: T[]) => void, timeout: number) {\n\t\tsuper(runner, timeout);\n\t}\n\n\twork(unit: T): void {\n\t\tthis.units.push(unit);\n\n\t\tif (!this.isScheduled()) {\n\t\t\tthis.schedule();\n\t\t}\n\t}\n\n\tprotected override doRun(): void {\n\t\tconst units = this.units;\n\t\tthis.units = [];\n\n\t\tthis.runner?.(units);\n\t}\n\n\toverride dispose(): void {\n\t\tthis.units = [];\n\n\t\tsuper.dispose();\n\t}\n}\n\nexport interface IThrottledWorkerOptions {\n\n\t/**\n\t * maximum of units the worker will pass onto handler at once\n\t */\n\tmaxWorkChunkSize: number;\n\n\t/**\n\t * maximum of units the worker will keep in memory for processing\n\t */\n\tmaxBufferedWork: number | undefined;\n\n\t/**\n\t * delay before processing the next round of chunks when chunk size exceeds limits\n\t */\n\tthrottleDelay: number;\n}\n\n/**\n * The `ThrottledWorker` will accept units of work `T`\n * to handle. The contract is:\n * * there is a maximum of units the worker can handle at once (via `maxWorkChunkSize`)\n * * there is a maximum of units the worker will keep in memory for processing (via `maxBufferedWork`)\n * * after having handled `maxWorkChunkSize` units, the worker needs to rest (via `throttleDelay`)\n */\nexport class ThrottledWorker<T> extends Disposable {\n\n\tprivate readonly pendingWork: T[] = [];\n\n\tprivate readonly throttler = this._register(new MutableDisposable<RunOnceScheduler>());\n\tprivate disposed = false;\n\n\tconstructor(\n\t\tprivate options: IThrottledWorkerOptions,\n\t\tprivate readonly handler: (units: T[]) => void\n\t) {\n\t\tsuper();\n\t}\n\n\t/**\n\t * The number of work units that are pending to be processed.\n\t */\n\tget pending(): number { return this.pendingWork.length; }\n\n\t/**\n\t * Add units to be worked on. Use `pending` to figure out\n\t * how many units are not yet processed after this method\n\t * was called.\n\t *\n\t * @returns whether the work was accepted or not. If the\n\t * worker is disposed, it will not accept any more work.\n\t * If the number of pending units would become larger\n\t * than `maxPendingWork`, more work will also not be accepted.\n\t */\n\twork(units: readonly T[]): boolean {\n\t\tif (this.disposed) {\n\t\t\treturn false; // work not accepted: disposed\n\t\t}\n\n\t\t// Check for reaching maximum of pending work\n\t\tif (typeof this.options.maxBufferedWork === 'number') {\n\n\t\t\t// Throttled: simple check if pending + units exceeds max pending\n\t\t\tif (this.throttler.value) {\n\t\t\t\tif (this.pending + units.length > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Unthrottled: same as throttled, but account for max chunk getting\n\t\t\t// worked on directly without being pending\n\t\t\telse {\n\t\t\t\tif (this.pending + units.length - this.options.maxWorkChunkSize > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add to pending units first\n\t\tfor (const unit of units) {\n\t\t\tthis.pendingWork.push(unit);\n\t\t}\n\n\t\t// If not throttled, start working directly\n\t\t// Otherwise, when the throttle delay has\n\t\t// past, pending work will be worked again.\n\t\tif (!this.throttler.value) {\n\t\t\tthis.doWork();\n\t\t}\n\n\t\treturn true; // work accepted\n\t}\n\n\tprivate doWork(): void {\n\n\t\t// Extract chunk to handle and handle it\n\t\tthis.handler(this.pendingWork.splice(0, this.options.maxWorkChunkSize));\n\n\t\t// If we have remaining work, schedule it after a delay\n\t\tif (this.pendingWork.length > 0) {\n\t\t\tthis.throttler.value = new RunOnceScheduler(() => {\n\t\t\t\tthis.throttler.clear();\n\n\t\t\t\tthis.doWork();\n\t\t\t}, this.options.throttleDelay);\n\t\t\tthis.throttler.value.schedule();\n\t\t}\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\tthis.disposed = true;\n\t}\n}\n\n//#region -- run on idle tricks ------------\n\nexport interface IdleDeadline {\n\treadonly didTimeout: boolean;\n\ttimeRemaining(): number;\n}\n\ntype IdleApi = Pick<typeof globalThis, 'requestIdleCallback' | 'cancelIdleCallback'>;\n\n\n/**\n * Execute the callback the next time the browser is idle, returning an\n * {@link IDisposable} that will cancel the callback when disposed. This wraps\n * [requestIdleCallback] so it will fallback to [setTimeout] if the environment\n * doesn't support it.\n *\n * @param callback The callback to run when idle, this includes an\n * [IdleDeadline] that provides the time alloted for the idle callback by the\n * browser. Not respecting this deadline will result in a degraded user\n * experience.\n * @param timeout A timeout at which point to queue no longer wait for an idle\n * callback but queue it on the regular event loop (like setTimeout). Typically\n * this should not be used.\n *\n * [IdleDeadline]: https://developer.mozilla.org/en-US/docs/Web/API/IdleDeadline\n * [requestIdleCallback]: https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\n * [setTimeout]: https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout\n *\n * **Note** that there is `dom.ts#runWhenWindowIdle` which is better suited when running inside a browser\n * context\n */\nexport let runWhenGlobalIdle: (callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\nexport let _runWhenIdle: (targetWindow: IdleApi, callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\n(function () {\n\tif (typeof globalThis.requestIdleCallback !== 'function' || typeof globalThis.cancelIdleCallback !== 'function') {\n\t\t_runWhenIdle = (_targetWindow, runner) => {\n\t\t\tsetTimeout0(() => {\n\t\t\t\tif (disposed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst end = Date.now() + 15; // one frame at 64fps\n\t\t\t\tconst deadline: IdleDeadline = {\n\t\t\t\t\tdidTimeout: true,\n\t\t\t\t\ttimeRemaining() {\n\t\t\t\t\t\treturn Math.max(0, end - Date.now());\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\trunner(Object.freeze(deadline));\n\t\t\t});\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t} else {\n\t\t_runWhenIdle = (targetWindow: IdleApi, runner, timeout?) => {\n\t\t\tconst handle: number = targetWindow.requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\ttargetWindow.cancelIdleCallback(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n\trunWhenGlobalIdle = (runner) => _runWhenIdle(globalThis, runner);\n})();\n\nexport abstract class AbstractIdleValue<T> {\n\n\tprivate readonly _executor: () => void;\n\tprivate readonly _handle: IDisposable;\n\n\tprivate _didRun: boolean = false;\n\tprivate _value?: T;\n\tprivate _error: unknown;\n\n\tconstructor(targetWindow: IdleApi, executor: () => T) {\n\t\tthis._executor = () => {\n\t\t\ttry {\n\t\t\t\tthis._value = executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._didRun = true;\n\t\t\t}\n\t\t};\n\t\tthis._handle = _runWhenIdle(targetWindow, () => this._executor());\n\t}\n\n\tdispose(): void {\n\t\tthis._handle.dispose();\n\t}\n\n\tget value(): T {\n\t\tif (!this._didRun) {\n\t\t\tthis._handle.dispose();\n\t\t\tthis._executor();\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n\n\tget isInitialized(): boolean {\n\t\treturn this._didRun;\n\t}\n}\n\n/**\n * An `IdleValue` that always uses the current window (which might be throttled or inactive)\n *\n * **Note** that there is `dom.ts#WindowIdleValue` which is better suited when running inside a browser\n * context\n */\nexport class GlobalIdleValue<T> extends AbstractIdleValue<T> {\n\n\tconstructor(executor: () => T) {\n\t\tsuper(globalThis, executor);\n\t}\n}\n\n//#endregion\n\nexport async function retry<T>(task: ITask<Promise<T>>, delay: number, retries: number): Promise<T> {\n\tlet lastError: Error | undefined;\n\n\tfor (let i = 0; i < retries; i++) {\n\t\ttry {\n\t\t\treturn await task();\n\t\t} catch (error) {\n\t\t\tlastError = error;\n\n\t\t\tawait timeout(delay);\n\t\t}\n\t}\n\n\tthrow lastError;\n}\n\n//#region Task Sequentializer\n\ninterface IRunningTask {\n\treadonly taskId: number;\n\treadonly cancel: () => void;\n\treadonly promise: Promise<void>;\n}\n\ninterface IQueuedTask {\n\treadonly promise: Promise<void>;\n\treadonly promiseResolve: () => void;\n\treadonly promiseReject: (error: Error) => void;\n\trun: ITask<Promise<void>>;\n}\n\nexport interface ITaskSequentializerWithRunningTask {\n\treadonly running: Promise<void>;\n}\n\nexport interface ITaskSequentializerWithQueuedTask {\n\treadonly queued: IQueuedTask;\n}\n\n/**\n * @deprecated use `LimitedQueue` instead for an easier to use API\n */\nexport class TaskSequentializer {\n\n\tprivate _running?: IRunningTask;\n\tprivate _queued?: IQueuedTask;\n\n\tisRunning(taskId?: number): this is ITaskSequentializerWithRunningTask {\n\t\tif (typeof taskId === 'number') {\n\t\t\treturn this._running?.taskId === taskId;\n\t\t}\n\n\t\treturn !!this._running;\n\t}\n\n\tget running(): Promise<void> | undefined {\n\t\treturn this._running?.promise;\n\t}\n\n\tcancelRunning(): void {\n\t\tthis._running?.cancel();\n\t}\n\n\trun(taskId: number, promise: Promise<void>, onCancel?: () => void,): Promise<void> {\n\t\tthis._running = { taskId, cancel: () => onCancel?.(), promise };\n\n\t\tpromise.then(() => this.doneRunning(taskId), () => this.doneRunning(taskId));\n\n\t\treturn promise;\n\t}\n\n\tprivate doneRunning(taskId: number): void {\n\t\tif (this._running && taskId === this._running.taskId) {\n\n\t\t\t// only set running to done if the promise finished that is associated with that taskId\n\t\t\tthis._running = undefined;\n\n\t\t\t// schedule the queued task now that we are free if we have any\n\t\t\tthis.runQueued();\n\t\t}\n\t}\n\n\tprivate runQueued(): void {\n\t\tif (this._queued) {\n\t\t\tconst queued = this._queued;\n\t\t\tthis._queued = undefined;\n\n\t\t\t// Run queued task and complete on the associated promise\n\t\t\tqueued.run().then(queued.promiseResolve, queued.promiseReject);\n\t\t}\n\t}\n\n\t/**\n\t * Note: the promise to schedule as next run MUST itself call `run`.\n\t *       Otherwise, this sequentializer will report `false` for `isRunning`\n\t *       even when this task is running. Missing this detail means that\n\t *       suddenly multiple tasks will run in parallel.\n\t */\n\tqueue(run: ITask<Promise<void>>): Promise<void> {\n\n\t\t// this is our first queued task, so we create associated promise with it\n\t\t// so that we can return a promise that completes when the task has\n\t\t// completed.\n\t\tif (!this._queued) {\n\t\t\tconst { promise, resolve: promiseResolve, reject: promiseReject } = promiseWithResolvers<void>();\n\t\t\tthis._queued = {\n\t\t\t\trun,\n\t\t\t\tpromise,\n\t\t\t\tpromiseResolve: promiseResolve!,\n\t\t\t\tpromiseReject: promiseReject!\n\t\t\t};\n\t\t}\n\n\t\t// we have a previous queued task, just overwrite it\n\t\telse {\n\t\t\tthis._queued.run = run;\n\t\t}\n\n\t\treturn this._queued.promise;\n\t}\n\n\thasQueued(): this is ITaskSequentializerWithQueuedTask {\n\t\treturn !!this._queued;\n\t}\n\n\tasync join(): Promise<void> {\n\t\treturn this._queued?.promise ?? this._running?.promise;\n\t}\n}\n\n//#endregion\n\n//#region\n\n/**\n * The `IntervalCounter` allows to count the number\n * of calls to `increment()` over a duration of\n * `interval`. This utility can be used to conditionally\n * throttle a frequent task when a certain threshold\n * is reached.\n */\nexport class IntervalCounter {\n\n\tprivate lastIncrementTime = 0;\n\n\tprivate value = 0;\n\n\tconstructor(private readonly interval: number, private readonly nowFn = () => Date.now()) { }\n\n\tincrement(): number {\n\t\tconst now = this.nowFn();\n\n\t\t// We are outside of the range of `interval` and as such\n\t\t// start counting from 0 and remember the time\n\t\tif (now - this.lastIncrementTime > this.interval) {\n\t\t\tthis.lastIncrementTime = now;\n\t\t\tthis.value = 0;\n\t\t}\n\n\t\tthis.value++;\n\n\t\treturn this.value;\n\t}\n}\n\n//#endregion\n\n//#region\n\nexport type ValueCallback<T = unknown> = (value: T | Promise<T>) => void;\n\nconst enum DeferredOutcome {\n\tResolved,\n\tRejected\n}\n\n/**\n * Creates a promise whose resolution or rejection can be controlled imperatively.\n */\nexport class DeferredPromise<T> {\n\n\tprivate completeCallback!: ValueCallback<T>;\n\tprivate errorCallback!: (err: unknown) => void;\n\tprivate outcome?: { outcome: DeferredOutcome.Rejected; value: any } | { outcome: DeferredOutcome.Resolved; value: T };\n\n\tpublic get isRejected() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Rejected;\n\t}\n\n\tpublic get isResolved() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Resolved;\n\t}\n\n\tpublic get isSettled() {\n\t\treturn !!this.outcome;\n\t}\n\n\tpublic get value() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Resolved ? this.outcome?.value : undefined;\n\t}\n\n\tpublic readonly p: Promise<T>;\n\n\tconstructor() {\n\t\tthis.p = new Promise<T>((c, e) => {\n\t\t\tthis.completeCallback = c;\n\t\t\tthis.errorCallback = e;\n\t\t});\n\t}\n\n\tpublic complete(value: T) {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.completeCallback(value);\n\t\t\tthis.outcome = { outcome: DeferredOutcome.Resolved, value };\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic error(err: unknown) {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.errorCallback(err);\n\t\t\tthis.outcome = { outcome: DeferredOutcome.Rejected, value: err };\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic cancel() {\n\t\treturn this.error(new CancellationError());\n\t}\n}\n\n//#endregion\n\n//#region Promises\n\nexport namespace Promises {\n\n\t/**\n\t * A drop-in replacement for `Promise.all` with the only difference\n\t * that the method awaits every promise to either fulfill or reject.\n\t *\n\t * Similar to `Promise.all`, only the first error will be returned\n\t * if any.\n\t */\n\texport async function settled<T>(promises: Promise<T>[]): Promise<T[]> {\n\t\tlet firstError: Error | undefined = undefined;\n\n\t\tconst result = await Promise.all(promises.map(promise => promise.then(value => value, error => {\n\t\t\tif (!firstError) {\n\t\t\t\tfirstError = error;\n\t\t\t}\n\n\t\t\treturn undefined; // do not rethrow so that other promises can settle\n\t\t})));\n\n\t\tif (typeof firstError !== 'undefined') {\n\t\t\tthrow firstError;\n\t\t}\n\n\t\treturn result as unknown as T[]; // cast is needed and protected by the `throw` above\n\t}\n\n\t/**\n\t * A helper to create a new `Promise<T>` with a body that is a promise\n\t * itself. By default, an error that raises from the async body will\n\t * end up as a unhandled rejection, so this utility properly awaits the\n\t * body and rejects the promise as a normal promise does without async\n\t * body.\n\t *\n\t * This method should only be used in rare cases where otherwise `async`\n\t * cannot be used (e.g. when callbacks are involved that require this).\n\t */\n\texport function withAsyncBody<T, E = Error>(bodyFn: (resolve: (value: T) => unknown, reject: (error: E) => unknown) => Promise<unknown>): Promise<T> {\n\t\t// eslint-disable-next-line no-async-promise-executor\n\t\treturn new Promise<T>(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tawait bodyFn(resolve, reject);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport class StatefulPromise<T> {\n\tprivate _value: T | undefined = undefined;\n\tget value(): T | undefined { return this._value; }\n\n\tprivate _error: unknown = undefined;\n\tget error(): unknown { return this._error; }\n\n\tprivate _isResolved = false;\n\tget isResolved() { return this._isResolved; }\n\n\tpublic readonly promise: Promise<T>;\n\n\tconstructor(promise: Promise<T>) {\n\t\tthis.promise = promise.then(\n\t\t\tvalue => {\n\t\t\t\tthis._value = value;\n\t\t\t\tthis._isResolved = true;\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\terror => {\n\t\t\t\tthis._error = error;\n\t\t\t\tthis._isResolved = true;\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * Returns the resolved value.\n\t * Throws if the promise is not resolved yet.\n\t */\n\tpublic requireValue(): T {\n\t\tif (!this._isResolved) {\n\t\t\tthrow new BugIndicatingError('Promise is not resolved yet');\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n}\n\nexport class LazyStatefulPromise<T> {\n\tprivate readonly _promise = new Lazy(() => new StatefulPromise(this._compute()));\n\n\tconstructor(\n\t\tprivate readonly _compute: () => Promise<T>,\n\t) { }\n\n\t/**\n\t * Returns the resolved value.\n\t * Throws if the promise is not resolved yet.\n\t */\n\tpublic requireValue(): T {\n\t\treturn this._promise.value.requireValue();\n\t}\n\n\t/**\n\t * Returns the promise (and triggers a computation of the promise if not yet done so).\n\t */\n\tpublic getPromise(): Promise<T> {\n\t\treturn this._promise.value.promise;\n\t}\n\n\t/**\n\t * Reads the current value without triggering a computation of the promise.\n\t */\n\tpublic get currentValue(): T | undefined {\n\t\treturn this._promise.rawValue?.value;\n\t}\n}\n\n//#endregion\n\n//#region\n\nconst enum AsyncIterableSourceState {\n\tInitial,\n\tDoneOK,\n\tDoneError,\n}\n\n/**\n * An object that allows to emit async values asynchronously or bring the iterable to an error state using `reject()`.\n * This emitter is valid only for the duration of the executor (until the promise returned by the executor settles).\n */\nexport interface AsyncIterableEmitter<T> {\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitOne(value: T): void;\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitMany(values: T[]): void;\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `reject()` have already been called, this method has no effect.\n\t */\n\treject(error: Error): void;\n}\n\n/**\n * An executor for the `AsyncIterableObject` that has access to an emitter.\n */\nexport interface AsyncIterableExecutor<T> {\n\t/**\n\t * @param emitter An object that allows to emit async values valid only for the duration of the executor.\n\t */\n\t(emitter: AsyncIterableEmitter<T>): void | Promise<void>;\n}\n\n/**\n * A rich implementation for an `AsyncIterable<T>`.\n */\nexport class AsyncIterableObject<T> implements AsyncIterable<T> {\n\n\tpublic static fromArray<T>(items: T[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>((writer) => {\n\t\t\twriter.emitMany(items);\n\t\t});\n\t}\n\n\tpublic static fromPromise<T>(promise: Promise<T[]>): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\temitter.emitMany(await promise);\n\t\t});\n\t}\n\n\tpublic static fromPromises<T>(promises: Promise<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tawait Promise.all(promises.map(async (p) => emitter.emitOne(await p)));\n\t\t});\n\t}\n\n\tpublic static merge<T>(iterables: AsyncIterable<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject(async (emitter) => {\n\t\t\tawait Promise.all(iterables.map(async (iterable) => {\n\t\t\t\tfor await (const item of iterable) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}));\n\t\t});\n\t}\n\n\tpublic static EMPTY = AsyncIterableObject.fromArray<any>([]);\n\n\tprivate _state: AsyncIterableSourceState;\n\tprivate _results: T[];\n\tprivate _error: Error | null;\n\tprivate readonly _onReturn?: () => void | Promise<void>;\n\tprivate readonly _onStateChanged: Emitter<void>;\n\n\tconstructor(executor: AsyncIterableExecutor<T>, onReturn?: () => void | Promise<void>) {\n\t\tthis._state = AsyncIterableSourceState.Initial;\n\t\tthis._results = [];\n\t\tthis._error = null;\n\t\tthis._onReturn = onReturn;\n\t\tthis._onStateChanged = new Emitter<void>();\n\n\t\tqueueMicrotask(async () => {\n\t\t\tconst writer: AsyncIterableEmitter<T> = {\n\t\t\t\temitOne: (item) => this.emitOne(item),\n\t\t\t\temitMany: (items) => this.emitMany(items),\n\t\t\t\treject: (error) => this.reject(error)\n\t\t\t};\n\t\t\ttry {\n\t\t\t\tawait Promise.resolve(executor(writer));\n\t\t\t\tthis.resolve();\n\t\t\t} catch (err) {\n\t\t\t\tthis.reject(err);\n\t\t\t} finally {\n\t\t\t\twriter.emitOne = undefined!;\n\t\t\t\twriter.emitMany = undefined!;\n\t\t\t\twriter.reject = undefined!;\n\t\t\t}\n\t\t});\n\t}\n\n\t[Symbol.asyncIterator](): AsyncIterator<T, undefined, undefined> {\n\t\tlet i = 0;\n\t\treturn {\n\t\t\tnext: async () => {\n\t\t\t\tdo {\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneError) {\n\t\t\t\t\t\tthrow this._error;\n\t\t\t\t\t}\n\t\t\t\t\tif (i < this._results.length) {\n\t\t\t\t\t\treturn { done: false, value: this._results[i++] };\n\t\t\t\t\t}\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneOK) {\n\t\t\t\t\t\treturn { done: true, value: undefined };\n\t\t\t\t\t}\n\t\t\t\t\tawait Event.toPromise(this._onStateChanged.event);\n\t\t\t\t} while (true);\n\t\t\t},\n\t\t\treturn: async () => {\n\t\t\t\tthis._onReturn?.();\n\t\t\t\treturn { done: true, value: undefined };\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic static map<T, R>(iterable: AsyncIterable<T>, mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn new AsyncIterableObject<R>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\temitter.emitOne(mapFn(item));\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic map<R>(mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn AsyncIterableObject.map(this, mapFn);\n\t}\n\n\tpublic static filter<T>(iterable: AsyncIterable<T>, filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\tif (filterFn(item)) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn AsyncIterableObject.filter(this, filterFn);\n\t}\n\n\tpublic static coalesce<T>(iterable: AsyncIterable<T | undefined | null>): AsyncIterableObject<T> {\n\t\treturn <AsyncIterableObject<T>>AsyncIterableObject.filter(iterable, item => !!item);\n\t}\n\n\tpublic coalesce(): AsyncIterableObject<NonNullable<T>> {\n\t\treturn AsyncIterableObject.coalesce(this) as AsyncIterableObject<NonNullable<T>>;\n\t}\n\n\tpublic static async toPromise<T>(iterable: AsyncIterable<T>): Promise<T[]> {\n\t\tconst result: T[] = [];\n\t\tfor await (const item of iterable) {\n\t\t\tresult.push(item);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic toPromise(): Promise<T[]> {\n\t\treturn AsyncIterableObject.toPromise(this);\n\t}\n\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitOne(value: T): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results.push(value);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitMany(values: T[]): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results = this._results.concat(values);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Calling `resolve()` will mark the result array as complete.\n\t *\n\t * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate resolve(): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneOK;\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate reject(error: Error) {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneError;\n\t\tthis._error = error;\n\t\tthis._onStateChanged.fire();\n\t}\n}\n\nexport class CancelableAsyncIterableObject<T> extends AsyncIterableObject<T> {\n\tconstructor(\n\t\tprivate readonly _source: CancellationTokenSource,\n\t\texecutor: AsyncIterableExecutor<T>\n\t) {\n\t\tsuper(executor);\n\t}\n\n\tcancel(): void {\n\t\tthis._source.cancel();\n\t}\n}\n\nexport function createCancelableAsyncIterable<T>(callback: (token: CancellationToken) => AsyncIterable<T>): CancelableAsyncIterableObject<T> {\n\tconst source = new CancellationTokenSource();\n\tconst innerIterable = callback(source.token);\n\n\treturn new CancelableAsyncIterableObject<T>(source, async (emitter) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(new CancellationError());\n\t\t});\n\t\ttry {\n\t\t\tfor await (const item of innerIterable) {\n\t\t\t\tif (source.token.isCancellationRequested) {\n\t\t\t\t\t// canceled in the meantime\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\temitter.emitOne(item);\n\t\t\t}\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t} catch (err) {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(err);\n\t\t}\n\t});\n}\n\nexport class AsyncIterableSource<T> {\n\n\tprivate readonly _deferred = new DeferredPromise<void>();\n\tprivate readonly _asyncIterable: AsyncIterableObject<T>;\n\n\tprivate _errorFn: (error: Error) => void;\n\tprivate _emitFn: (item: T) => void;\n\n\t/**\n\t *\n\t * @param onReturn A function that will be called when consuming the async iterable\n\t * has finished by the consumer, e.g the for-await-loop has be existed (break, return) early.\n\t * This is NOT called when resolving this source by its owner.\n\t */\n\tconstructor(onReturn?: () => Promise<void> | void) {\n\t\tthis._asyncIterable = new AsyncIterableObject(emitter => {\n\n\t\t\tif (earlyError) {\n\t\t\t\temitter.reject(earlyError);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (earlyItems) {\n\t\t\t\temitter.emitMany(earlyItems);\n\t\t\t}\n\t\t\tthis._errorFn = (error: Error) => emitter.reject(error);\n\t\t\tthis._emitFn = (item: T) => emitter.emitOne(item);\n\t\t\treturn this._deferred.p;\n\t\t}, onReturn);\n\n\t\tlet earlyError: Error | undefined;\n\t\tlet earlyItems: T[] | undefined;\n\n\t\tthis._emitFn = (item: T) => {\n\t\t\tif (!earlyItems) {\n\t\t\t\tearlyItems = [];\n\t\t\t}\n\t\t\tearlyItems.push(item);\n\t\t};\n\t\tthis._errorFn = (error: Error) => {\n\t\t\tif (!earlyError) {\n\t\t\t\tearlyError = error;\n\t\t\t}\n\t\t};\n\t}\n\n\tget asyncIterable(): AsyncIterableObject<T> {\n\t\treturn this._asyncIterable;\n\t}\n\n\tresolve(): void {\n\t\tthis._deferred.complete();\n\t}\n\n\treject(error: Error): void {\n\t\tthis._errorFn(error);\n\t\tthis._deferred.complete();\n\t}\n\n\temitOne(item: T): void {\n\t\tthis._emitFn(item);\n\t}\n}\n\n//#endregion\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport { Constants } from 'vs/base/common/uint';\n\nexport function isFalsyOrWhitespace(str: string | undefined): boolean {\n\tif (!str || typeof str !== 'string') {\n\t\treturn true;\n\t}\n\treturn str.trim().length === 0;\n}\n\nconst _formatRegexp = /{(\\d+)}/g;\n\n/**\n * Helper to produce a string with a variable number of arguments. Insert variable segments\n * into the string using the {n} notation where N is the index of the argument following the string.\n * @param value string to which formatting is applied\n * @param args replacements for {n}-entries\n */\nexport function format(value: string, ...args: any[]): string {\n\tif (args.length === 0) {\n\t\treturn value;\n\t}\n\treturn value.replace(_formatRegexp, function (match, group) {\n\t\tconst idx = parseInt(group, 10);\n\t\treturn isNaN(idx) || idx < 0 || idx >= args.length ?\n\t\t\tmatch :\n\t\t\targs[idx];\n\t});\n}\n\nconst _format2Regexp = /{([^}]+)}/g;\n\n/**\n * Helper to create a string from a template and a string record.\n * Similar to `format` but with objects instead of positional arguments.\n */\nexport function format2(template: string, values: Record<string, unknown>): string {\n\tif (Object.keys(values).length === 0) {\n\t\treturn template;\n\t}\n\treturn template.replace(_format2Regexp, (match, group) => (values[group] ?? match) as string);\n}\n\n/**\n * Encodes the given value so that it can be used as literal value in html attributes.\n *\n * In other words, computes `$val`, such that `attr` in `<div attr=\"$val\" />` has the runtime value `value`.\n * This prevents XSS injection.\n */\nexport function htmlAttributeEncodeValue(value: string): string {\n\treturn value.replace(/[<>\"'&]/g, ch => {\n\t\tswitch (ch) {\n\t\t\tcase '<': return '&lt;';\n\t\t\tcase '>': return '&gt;';\n\t\t\tcase '\"': return '&quot;';\n\t\t\tcase '\\'': return '&apos;';\n\t\t\tcase '&': return '&amp;';\n\t\t}\n\t\treturn ch;\n\t});\n}\n\n/**\n * Converts HTML characters inside the string to use entities instead. Makes the string safe from\n * being used e.g. in HTMLElement.innerHTML.\n */\nexport function escape(html: string): string {\n\treturn html.replace(/[<>&]/g, function (match) {\n\t\tswitch (match) {\n\t\t\tcase '<': return '&lt;';\n\t\t\tcase '>': return '&gt;';\n\t\t\tcase '&': return '&amp;';\n\t\t\tdefault: return match;\n\t\t}\n\t});\n}\n\n/**\n * Escapes regular expression characters in a given string\n */\nexport function escapeRegExpCharacters(value: string): string {\n\treturn value.replace(/[\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\[\\]\\(\\)]/g, '\\\\$&');\n}\n\n/**\n * Counts how often `substr` occurs inside `value`.\n */\nexport function count(value: string, substr: string): number {\n\tlet result = 0;\n\tlet index = value.indexOf(substr);\n\twhile (index !== -1) {\n\t\tresult++;\n\t\tindex = value.indexOf(substr, index + substr.length);\n\t}\n\treturn result;\n}\n\nexport function truncate(value: string, maxLength: number, suffix = '\u2026'): string {\n\tif (value.length <= maxLength) {\n\t\treturn value;\n\t}\n\n\treturn `${value.substr(0, maxLength)}${suffix}`;\n}\n\nexport function truncateMiddle(value: string, maxLength: number, suffix = '\u2026'): string {\n\tif (value.length <= maxLength) {\n\t\treturn value;\n\t}\n\n\tconst prefixLength = Math.ceil(maxLength / 2) - suffix.length / 2;\n\tconst suffixLength = Math.floor(maxLength / 2) - suffix.length / 2;\n\n\treturn `${value.substr(0, prefixLength)}${suffix}${value.substr(value.length - suffixLength)}`;\n}\n\n/**\n * Removes all occurrences of needle from the beginning and end of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim (default is a blank)\n */\nexport function trim(haystack: string, needle: string = ' '): string {\n\tconst trimmed = ltrim(haystack, needle);\n\treturn rtrim(trimmed, needle);\n}\n\n/**\n * Removes all occurrences of needle from the beginning of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim\n */\nexport function ltrim(haystack: string, needle: string): string {\n\tif (!haystack || !needle) {\n\t\treturn haystack;\n\t}\n\n\tconst needleLen = needle.length;\n\tif (needleLen === 0 || haystack.length === 0) {\n\t\treturn haystack;\n\t}\n\n\tlet offset = 0;\n\n\twhile (haystack.indexOf(needle, offset) === offset) {\n\t\toffset = offset + needleLen;\n\t}\n\treturn haystack.substring(offset);\n}\n\n/**\n * Removes all occurrences of needle from the end of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim\n */\nexport function rtrim(haystack: string, needle: string): string {\n\tif (!haystack || !needle) {\n\t\treturn haystack;\n\t}\n\n\tconst needleLen = needle.length,\n\t\thaystackLen = haystack.length;\n\n\tif (needleLen === 0 || haystackLen === 0) {\n\t\treturn haystack;\n\t}\n\n\tlet offset = haystackLen,\n\t\tidx = -1;\n\n\twhile (true) {\n\t\tidx = haystack.lastIndexOf(needle, offset - 1);\n\t\tif (idx === -1 || idx + needleLen !== offset) {\n\t\t\tbreak;\n\t\t}\n\t\tif (idx === 0) {\n\t\t\treturn '';\n\t\t}\n\t\toffset = idx;\n\t}\n\n\treturn haystack.substring(0, offset);\n}\n\nexport function convertSimple2RegExpPattern(pattern: string): string {\n\treturn pattern.replace(/[\\-\\\\\\{\\}\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, '\\\\$&').replace(/[\\*]/g, '.*');\n}\n\nexport function stripWildcards(pattern: string): string {\n\treturn pattern.replace(/\\*/g, '');\n}\n\nexport interface RegExpOptions {\n\tmatchCase?: boolean;\n\twholeWord?: boolean;\n\tmultiline?: boolean;\n\tglobal?: boolean;\n\tunicode?: boolean;\n}\n\nexport function createRegExp(searchString: string, isRegex: boolean, options: RegExpOptions = {}): RegExp {\n\tif (!searchString) {\n\t\tthrow new Error('Cannot create regex from empty string');\n\t}\n\tif (!isRegex) {\n\t\tsearchString = escapeRegExpCharacters(searchString);\n\t}\n\tif (options.wholeWord) {\n\t\tif (!/\\B/.test(searchString.charAt(0))) {\n\t\t\tsearchString = '\\\\b' + searchString;\n\t\t}\n\t\tif (!/\\B/.test(searchString.charAt(searchString.length - 1))) {\n\t\t\tsearchString = searchString + '\\\\b';\n\t\t}\n\t}\n\tlet modifiers = '';\n\tif (options.global) {\n\t\tmodifiers += 'g';\n\t}\n\tif (!options.matchCase) {\n\t\tmodifiers += 'i';\n\t}\n\tif (options.multiline) {\n\t\tmodifiers += 'm';\n\t}\n\tif (options.unicode) {\n\t\tmodifiers += 'u';\n\t}\n\n\treturn new RegExp(searchString, modifiers);\n}\n\nexport function regExpLeadsToEndlessLoop(regexp: RegExp): boolean {\n\t// Exit early if it's one of these special cases which are meant to match\n\t// against an empty string\n\tif (regexp.source === '^' || regexp.source === '^$' || regexp.source === '$' || regexp.source === '^\\\\s*$') {\n\t\treturn false;\n\t}\n\n\t// We check against an empty string. If the regular expression doesn't advance\n\t// (e.g. ends in an endless loop) it will match an empty string.\n\tconst match = regexp.exec('');\n\treturn !!(match && regexp.lastIndex === 0);\n}\n\nexport function splitLines(str: string): string[] {\n\treturn str.split(/\\r\\n|\\r|\\n/);\n}\n\nexport function splitLinesIncludeSeparators(str: string): string[] {\n\tconst linesWithSeparators: string[] = [];\n\tconst splitLinesAndSeparators = str.split(/(\\r\\n|\\r|\\n)/);\n\tfor (let i = 0; i < Math.ceil(splitLinesAndSeparators.length / 2); i++) {\n\t\tlinesWithSeparators.push(splitLinesAndSeparators[2 * i] + (splitLinesAndSeparators[2 * i + 1] ?? ''));\n\t}\n\treturn linesWithSeparators;\n}\n\n/**\n * Returns first index of the string that is not whitespace.\n * If string is empty or contains only whitespaces, returns -1\n */\nexport function firstNonWhitespaceIndex(str: string): number {\n\tfor (let i = 0, len = str.length; i < len; i++) {\n\t\tconst chCode = str.charCodeAt(i);\n\t\tif (chCode !== CharCode.Space && chCode !== CharCode.Tab) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/**\n * Returns the leading whitespace of the string.\n * If the string contains only whitespaces, returns entire string\n */\nexport function getLeadingWhitespace(str: string, start: number = 0, end: number = str.length): string {\n\tfor (let i = start; i < end; i++) {\n\t\tconst chCode = str.charCodeAt(i);\n\t\tif (chCode !== CharCode.Space && chCode !== CharCode.Tab) {\n\t\t\treturn str.substring(start, i);\n\t\t}\n\t}\n\treturn str.substring(start, end);\n}\n\n/**\n * Returns last index of the string that is not whitespace.\n * If string is empty or contains only whitespaces, returns -1\n */\nexport function lastNonWhitespaceIndex(str: string, startIndex: number = str.length - 1): number {\n\tfor (let i = startIndex; i >= 0; i--) {\n\t\tconst chCode = str.charCodeAt(i);\n\t\tif (chCode !== CharCode.Space && chCode !== CharCode.Tab) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/**\n * Function that works identically to String.prototype.replace, except, the\n * replace function is allowed to be async and return a Promise.\n */\nexport function replaceAsync(str: string, search: RegExp, replacer: (match: string, ...args: any[]) => Promise<string>): Promise<string> {\n\tconst parts: (string | Promise<string>)[] = [];\n\n\tlet last = 0;\n\tfor (const match of str.matchAll(search)) {\n\t\tparts.push(str.slice(last, match.index));\n\t\tif (match.index === undefined) {\n\t\t\tthrow new Error('match.index should be defined');\n\t\t}\n\n\t\tlast = match.index + match[0].length;\n\t\tparts.push(replacer(match[0], ...match.slice(1), match.index, str, match.groups));\n\t}\n\n\tparts.push(str.slice(last));\n\n\treturn Promise.all(parts).then(p => p.join(''));\n}\n\nexport function compare(a: string, b: string): number {\n\tif (a < b) {\n\t\treturn -1;\n\t} else if (a > b) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nexport function compareSubstring(a: string, b: string, aStart: number = 0, aEnd: number = a.length, bStart: number = 0, bEnd: number = b.length): number {\n\tfor (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {\n\t\tconst codeA = a.charCodeAt(aStart);\n\t\tconst codeB = b.charCodeAt(bStart);\n\t\tif (codeA < codeB) {\n\t\t\treturn -1;\n\t\t} else if (codeA > codeB) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\tconst aLen = aEnd - aStart;\n\tconst bLen = bEnd - bStart;\n\tif (aLen < bLen) {\n\t\treturn -1;\n\t} else if (aLen > bLen) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nexport function compareIgnoreCase(a: string, b: string): number {\n\treturn compareSubstringIgnoreCase(a, b, 0, a.length, 0, b.length);\n}\n\nexport function compareSubstringIgnoreCase(a: string, b: string, aStart: number = 0, aEnd: number = a.length, bStart: number = 0, bEnd: number = b.length): number {\n\n\tfor (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {\n\n\t\tlet codeA = a.charCodeAt(aStart);\n\t\tlet codeB = b.charCodeAt(bStart);\n\n\t\tif (codeA === codeB) {\n\t\t\t// equal\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (codeA >= 128 || codeB >= 128) {\n\t\t\t// not ASCII letters -> fallback to lower-casing strings\n\t\t\treturn compareSubstring(a.toLowerCase(), b.toLowerCase(), aStart, aEnd, bStart, bEnd);\n\t\t}\n\n\t\t// mapper lower-case ascii letter onto upper-case varinats\n\t\t// [97-122] (lower ascii) --> [65-90] (upper ascii)\n\t\tif (isLowerAsciiLetter(codeA)) {\n\t\t\tcodeA -= 32;\n\t\t}\n\t\tif (isLowerAsciiLetter(codeB)) {\n\t\t\tcodeB -= 32;\n\t\t}\n\n\t\t// compare both code points\n\t\tconst diff = codeA - codeB;\n\t\tif (diff === 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\treturn diff;\n\t}\n\n\tconst aLen = aEnd - aStart;\n\tconst bLen = bEnd - bStart;\n\n\tif (aLen < bLen) {\n\t\treturn -1;\n\t} else if (aLen > bLen) {\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nexport function isAsciiDigit(code: number): boolean {\n\treturn code >= CharCode.Digit0 && code <= CharCode.Digit9;\n}\n\nexport function isLowerAsciiLetter(code: number): boolean {\n\treturn code >= CharCode.a && code <= CharCode.z;\n}\n\nexport function isUpperAsciiLetter(code: number): boolean {\n\treturn code >= CharCode.A && code <= CharCode.Z;\n}\n\nexport function equalsIgnoreCase(a: string, b: string): boolean {\n\treturn a.length === b.length && compareSubstringIgnoreCase(a, b) === 0;\n}\n\nexport function startsWithIgnoreCase(str: string, candidate: string): boolean {\n\tconst candidateLength = candidate.length;\n\tif (candidate.length > str.length) {\n\t\treturn false;\n\t}\n\n\treturn compareSubstringIgnoreCase(str, candidate, 0, candidateLength) === 0;\n}\n\n/**\n * @returns the length of the common prefix of the two strings.\n */\nexport function commonPrefixLength(a: string, b: string): number {\n\n\tconst len = Math.min(a.length, b.length);\n\tlet i: number;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (a.charCodeAt(i) !== b.charCodeAt(i)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn len;\n}\n\n/**\n * @returns the length of the common suffix of the two strings.\n */\nexport function commonSuffixLength(a: string, b: string): number {\n\n\tconst len = Math.min(a.length, b.length);\n\tlet i: number;\n\n\tconst aLastIndex = a.length - 1;\n\tconst bLastIndex = b.length - 1;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn len;\n}\n\n/**\n * See http://en.wikipedia.org/wiki/Surrogate_pair\n */\nexport function isHighSurrogate(charCode: number): boolean {\n\treturn (0xD800 <= charCode && charCode <= 0xDBFF);\n}\n\n/**\n * See http://en.wikipedia.org/wiki/Surrogate_pair\n */\nexport function isLowSurrogate(charCode: number): boolean {\n\treturn (0xDC00 <= charCode && charCode <= 0xDFFF);\n}\n\n/**\n * See http://en.wikipedia.org/wiki/Surrogate_pair\n */\nexport function computeCodePoint(highSurrogate: number, lowSurrogate: number): number {\n\treturn ((highSurrogate - 0xD800) << 10) + (lowSurrogate - 0xDC00) + 0x10000;\n}\n\n/**\n * get the code point that begins at offset `offset`\n */\nexport function getNextCodePoint(str: string, len: number, offset: number): number {\n\tconst charCode = str.charCodeAt(offset);\n\tif (isHighSurrogate(charCode) && offset + 1 < len) {\n\t\tconst nextCharCode = str.charCodeAt(offset + 1);\n\t\tif (isLowSurrogate(nextCharCode)) {\n\t\t\treturn computeCodePoint(charCode, nextCharCode);\n\t\t}\n\t}\n\treturn charCode;\n}\n\n/**\n * get the code point that ends right before offset `offset`\n */\nfunction getPrevCodePoint(str: string, offset: number): number {\n\tconst charCode = str.charCodeAt(offset - 1);\n\tif (isLowSurrogate(charCode) && offset > 1) {\n\t\tconst prevCharCode = str.charCodeAt(offset - 2);\n\t\tif (isHighSurrogate(prevCharCode)) {\n\t\t\treturn computeCodePoint(prevCharCode, charCode);\n\t\t}\n\t}\n\treturn charCode;\n}\n\nexport class CodePointIterator {\n\n\tprivate readonly _str: string;\n\tprivate readonly _len: number;\n\tprivate _offset: number;\n\n\tpublic get offset(): number {\n\t\treturn this._offset;\n\t}\n\n\tconstructor(str: string, offset: number = 0) {\n\t\tthis._str = str;\n\t\tthis._len = str.length;\n\t\tthis._offset = offset;\n\t}\n\n\tpublic setOffset(offset: number): void {\n\t\tthis._offset = offset;\n\t}\n\n\tpublic prevCodePoint(): number {\n\t\tconst codePoint = getPrevCodePoint(this._str, this._offset);\n\t\tthis._offset -= (codePoint >= Constants.UNICODE_SUPPLEMENTARY_PLANE_BEGIN ? 2 : 1);\n\t\treturn codePoint;\n\t}\n\n\tpublic nextCodePoint(): number {\n\t\tconst codePoint = getNextCodePoint(this._str, this._len, this._offset);\n\t\tthis._offset += (codePoint >= Constants.UNICODE_SUPPLEMENTARY_PLANE_BEGIN ? 2 : 1);\n\t\treturn codePoint;\n\t}\n\n\tpublic eol(): boolean {\n\t\treturn (this._offset >= this._len);\n\t}\n}\n\nexport const noBreakWhitespace = '\\xa0';\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as strings from 'vs/base/common/strings';\n\n/**\n * Return a hash value for an object.\n */\nexport function hash(obj: any): number {\n\treturn doHash(obj, 0);\n}\n\nexport function doHash(obj: any, hashVal: number): number {\n\tswitch (typeof obj) {\n\t\tcase 'object':\n\t\t\tif (obj === null) {\n\t\t\t\treturn numberHash(349, hashVal);\n\t\t\t} else if (Array.isArray(obj)) {\n\t\t\t\treturn arrayHash(obj, hashVal);\n\t\t\t}\n\t\t\treturn objectHash(obj, hashVal);\n\t\tcase 'string':\n\t\t\treturn stringHash(obj, hashVal);\n\t\tcase 'boolean':\n\t\t\treturn booleanHash(obj, hashVal);\n\t\tcase 'number':\n\t\t\treturn numberHash(obj, hashVal);\n\t\tcase 'undefined':\n\t\t\treturn numberHash(937, hashVal);\n\t\tdefault:\n\t\t\treturn numberHash(617, hashVal);\n\t}\n}\n\nexport function numberHash(val: number, initialHashVal: number): number {\n\treturn (((initialHashVal << 5) - initialHashVal) + val) | 0;  // hashVal * 31 + ch, keep as int32\n}\n\nfunction booleanHash(b: boolean, initialHashVal: number): number {\n\treturn numberHash(b ? 433 : 863, initialHashVal);\n}\n\nexport function stringHash(s: string, hashVal: number) {\n\thashVal = numberHash(149417, hashVal);\n\tfor (let i = 0, length = s.length; i < length; i++) {\n\t\thashVal = numberHash(s.charCodeAt(i), hashVal);\n\t}\n\treturn hashVal;\n}\n\nfunction arrayHash(arr: any[], initialHashVal: number): number {\n\tinitialHashVal = numberHash(104579, initialHashVal);\n\treturn arr.reduce((hashVal, item) => doHash(item, hashVal), initialHashVal);\n}\n\nfunction objectHash(obj: any, initialHashVal: number): number {\n\tinitialHashVal = numberHash(181387, initialHashVal);\n\treturn Object.keys(obj).sort().reduce((hashVal, key) => {\n\t\thashVal = stringHash(key, hashVal);\n\t\treturn doHash(obj[key], hashVal);\n\t}, initialHashVal);\n}\n\nexport class Hasher {\n\n\tprivate _value = 0;\n\n\tget value(): number {\n\t\treturn this._value;\n\t}\n\n\thash(obj: any): number {\n\t\tthis._value = doHash(obj, this._value);\n\t\treturn this._value;\n\t}\n}\n\nconst enum SHA1Constant {\n\tBLOCK_SIZE = 64, // 512 / 8\n\tUNICODE_REPLACEMENT = 0xFFFD,\n}\n\nfunction leftRotate(value: number, bits: number, totalBits: number = 32): number {\n\t// delta + bits = totalBits\n\tconst delta = totalBits - bits;\n\n\t// All ones, expect `delta` zeros aligned to the right\n\tconst mask = ~((1 << delta) - 1);\n\n\t// Join (value left-shifted `bits` bits) with (masked value right-shifted `delta` bits)\n\treturn ((value << bits) | ((mask & value) >>> delta)) >>> 0;\n}\n\nfunction fill(dest: Uint8Array, index: number = 0, count: number = dest.byteLength, value: number = 0): void {\n\tfor (let i = 0; i < count; i++) {\n\t\tdest[index + i] = value;\n\t}\n}\n\nfunction leftPad(value: string, length: number, char: string = '0'): string {\n\twhile (value.length < length) {\n\t\tvalue = char + value;\n\t}\n\treturn value;\n}\n\nexport function toHexString(buffer: ArrayBuffer): string;\nexport function toHexString(value: number, bitsize?: number): string;\nexport function toHexString(bufferOrValue: ArrayBuffer | number, bitsize: number = 32): string {\n\tif (bufferOrValue instanceof ArrayBuffer) {\n\t\treturn Array.from(new Uint8Array(bufferOrValue)).map(b => b.toString(16).padStart(2, '0')).join('');\n\t}\n\n\treturn leftPad((bufferOrValue >>> 0).toString(16), bitsize / 4);\n}\n\n/**\n * A SHA1 implementation that works with strings and does not allocate.\n */\nexport class StringSHA1 {\n\tprivate static _bigBlock32 = new DataView(new ArrayBuffer(320)); // 80 * 4 = 320\n\n\tprivate _h0 = 0x67452301;\n\tprivate _h1 = 0xEFCDAB89;\n\tprivate _h2 = 0x98BADCFE;\n\tprivate _h3 = 0x10325476;\n\tprivate _h4 = 0xC3D2E1F0;\n\n\tprivate readonly _buff: Uint8Array;\n\tprivate readonly _buffDV: DataView;\n\tprivate _buffLen: number;\n\tprivate _totalLen: number;\n\tprivate _leftoverHighSurrogate: number;\n\tprivate _finished: boolean;\n\n\tconstructor() {\n\t\tthis._buff = new Uint8Array(SHA1Constant.BLOCK_SIZE + 3 /* to fit any utf-8 */);\n\t\tthis._buffDV = new DataView(this._buff.buffer);\n\t\tthis._buffLen = 0;\n\t\tthis._totalLen = 0;\n\t\tthis._leftoverHighSurrogate = 0;\n\t\tthis._finished = false;\n\t}\n\n\tpublic update(str: string): void {\n\t\tconst strLen = str.length;\n\t\tif (strLen === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst buff = this._buff;\n\t\tlet buffLen = this._buffLen;\n\t\tlet leftoverHighSurrogate = this._leftoverHighSurrogate;\n\t\tlet charCode: number;\n\t\tlet offset: number;\n\n\t\tif (leftoverHighSurrogate !== 0) {\n\t\t\tcharCode = leftoverHighSurrogate;\n\t\t\toffset = -1;\n\t\t\tleftoverHighSurrogate = 0;\n\t\t} else {\n\t\t\tcharCode = str.charCodeAt(0);\n\t\t\toffset = 0;\n\t\t}\n\n\t\twhile (true) {\n\t\t\tlet codePoint = charCode;\n\t\t\tif (strings.isHighSurrogate(charCode)) {\n\t\t\t\tif (offset + 1 < strLen) {\n\t\t\t\t\tconst nextCharCode = str.charCodeAt(offset + 1);\n\t\t\t\t\tif (strings.isLowSurrogate(nextCharCode)) {\n\t\t\t\t\t\toffset++;\n\t\t\t\t\t\tcodePoint = strings.computeCodePoint(charCode, nextCharCode);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// illegal => unicode replacement character\n\t\t\t\t\t\tcodePoint = SHA1Constant.UNICODE_REPLACEMENT;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// last character is a surrogate pair\n\t\t\t\t\tleftoverHighSurrogate = charCode;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (strings.isLowSurrogate(charCode)) {\n\t\t\t\t// illegal => unicode replacement character\n\t\t\t\tcodePoint = SHA1Constant.UNICODE_REPLACEMENT;\n\t\t\t}\n\n\t\t\tbuffLen = this._push(buff, buffLen, codePoint);\n\t\t\toffset++;\n\t\t\tif (offset < strLen) {\n\t\t\t\tcharCode = str.charCodeAt(offset);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tthis._buffLen = buffLen;\n\t\tthis._leftoverHighSurrogate = leftoverHighSurrogate;\n\t}\n\n\tprivate _push(buff: Uint8Array, buffLen: number, codePoint: number): number {\n\t\tif (codePoint < 0x0080) {\n\t\t\tbuff[buffLen++] = codePoint;\n\t\t} else if (codePoint < 0x0800) {\n\t\t\tbuff[buffLen++] = 0b11000000 | ((codePoint & 0b00000000000000000000011111000000) >>> 6);\n\t\t\tbuff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);\n\t\t} else if (codePoint < 0x10000) {\n\t\t\tbuff[buffLen++] = 0b11100000 | ((codePoint & 0b00000000000000001111000000000000) >>> 12);\n\t\t\tbuff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000111111000000) >>> 6);\n\t\t\tbuff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);\n\t\t} else {\n\t\t\tbuff[buffLen++] = 0b11110000 | ((codePoint & 0b00000000000111000000000000000000) >>> 18);\n\t\t\tbuff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000111111000000000000) >>> 12);\n\t\t\tbuff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000111111000000) >>> 6);\n\t\t\tbuff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);\n\t\t}\n\n\t\tif (buffLen >= SHA1Constant.BLOCK_SIZE) {\n\t\t\tthis._step();\n\t\t\tbuffLen -= SHA1Constant.BLOCK_SIZE;\n\t\t\tthis._totalLen += SHA1Constant.BLOCK_SIZE;\n\t\t\t// take last 3 in case of UTF8 overflow\n\t\t\tbuff[0] = buff[SHA1Constant.BLOCK_SIZE + 0];\n\t\t\tbuff[1] = buff[SHA1Constant.BLOCK_SIZE + 1];\n\t\t\tbuff[2] = buff[SHA1Constant.BLOCK_SIZE + 2];\n\t\t}\n\n\t\treturn buffLen;\n\t}\n\n\tpublic digest(): string {\n\t\tif (!this._finished) {\n\t\t\tthis._finished = true;\n\t\t\tif (this._leftoverHighSurrogate) {\n\t\t\t\t// illegal => unicode replacement character\n\t\t\t\tthis._leftoverHighSurrogate = 0;\n\t\t\t\tthis._buffLen = this._push(this._buff, this._buffLen, SHA1Constant.UNICODE_REPLACEMENT);\n\t\t\t}\n\t\t\tthis._totalLen += this._buffLen;\n\t\t\tthis._wrapUp();\n\t\t}\n\n\t\treturn toHexString(this._h0) + toHexString(this._h1) + toHexString(this._h2) + toHexString(this._h3) + toHexString(this._h4);\n\t}\n\n\tprivate _wrapUp(): void {\n\t\tthis._buff[this._buffLen++] = 0x80;\n\t\tfill(this._buff, this._buffLen);\n\n\t\tif (this._buffLen > 56) {\n\t\t\tthis._step();\n\t\t\tfill(this._buff);\n\t\t}\n\n\t\t// this will fit because the mantissa can cover up to 52 bits\n\t\tconst ml = 8 * this._totalLen;\n\n\t\tthis._buffDV.setUint32(56, Math.floor(ml / 4294967296), false);\n\t\tthis._buffDV.setUint32(60, ml % 4294967296, false);\n\n\t\tthis._step();\n\t}\n\n\tprivate _step(): void {\n\t\tconst bigBlock32 = StringSHA1._bigBlock32;\n\t\tconst data = this._buffDV;\n\n\t\tfor (let j = 0; j < 64 /* 16*4 */; j += 4) {\n\t\t\tbigBlock32.setUint32(j, data.getUint32(j, false), false);\n\t\t}\n\n\t\tfor (let j = 64; j < 320 /* 80*4 */; j += 4) {\n\t\t\tbigBlock32.setUint32(j, leftRotate((bigBlock32.getUint32(j - 12, false) ^ bigBlock32.getUint32(j - 32, false) ^ bigBlock32.getUint32(j - 56, false) ^ bigBlock32.getUint32(j - 64, false)), 1), false);\n\t\t}\n\n\t\tlet a = this._h0;\n\t\tlet b = this._h1;\n\t\tlet c = this._h2;\n\t\tlet d = this._h3;\n\t\tlet e = this._h4;\n\n\t\tlet f: number, k: number;\n\t\tlet temp: number;\n\n\t\tfor (let j = 0; j < 80; j++) {\n\t\t\tif (j < 20) {\n\t\t\t\tf = (b & c) | ((~b) & d);\n\t\t\t\tk = 0x5A827999;\n\t\t\t} else if (j < 40) {\n\t\t\t\tf = b ^ c ^ d;\n\t\t\t\tk = 0x6ED9EBA1;\n\t\t\t} else if (j < 60) {\n\t\t\t\tf = (b & c) | (b & d) | (c & d);\n\t\t\t\tk = 0x8F1BBCDC;\n\t\t\t} else {\n\t\t\t\tf = b ^ c ^ d;\n\t\t\t\tk = 0xCA62C1D6;\n\t\t\t}\n\n\t\t\ttemp = (leftRotate(a, 5) + f + e + k + bigBlock32.getUint32(j * 4, false)) & 0xffffffff;\n\t\t\te = d;\n\t\t\td = c;\n\t\t\tc = leftRotate(b, 30);\n\t\t\tb = a;\n\t\t\ta = temp;\n\t\t}\n\n\t\tthis._h0 = (this._h0 + a) & 0xffffffff;\n\t\tthis._h1 = (this._h1 + b) & 0xffffffff;\n\t\tthis._h2 = (this._h2 + c) & 0xffffffff;\n\t\tthis._h3 = (this._h3 + d) & 0xffffffff;\n\t\tthis._h4 = (this._h4 + e) & 0xffffffff;\n\t}\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as browser from 'vs/base/browser/browser';\nimport { BrowserFeatures } from 'vs/base/browser/canIUse';\nimport { IKeyboardEvent, StandardKeyboardEvent } from 'vs/base/browser/keyboardEvent';\nimport { IMouseEvent, StandardMouseEvent } from 'vs/base/browser/mouseEvent';\nimport { AbstractIdleValue, IntervalTimer, TimeoutTimer, _runWhenIdle, IdleDeadline } from 'vs/base/common/async';\nimport { onUnexpectedError } from 'vs/base/common/errors';\nimport * as event from 'vs/base/common/event';\nimport { KeyCode } from 'vs/base/common/keyCodes';\nimport { Disposable, DisposableStore, IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport * as platform from 'vs/base/common/platform';\nimport { hash } from 'vs/base/common/hash';\nimport { CodeWindow, ensureCodeWindow, mainWindow } from 'vs/base/browser/window';\nimport { isPointWithinTriangle } from 'vs/base/common/numbers';\n\nexport interface IRegisteredCodeWindow {\n\treadonly window: CodeWindow;\n\treadonly disposables: DisposableStore;\n}\n\n//# region Multi-Window Support Utilities\n\nexport const {\n\tregisterWindow,\n\tgetWindow,\n\tgetDocument,\n\tgetWindows,\n\tgetWindowsCount,\n\tgetWindowId,\n\tgetWindowById,\n\thasWindow,\n\tonDidRegisterWindow,\n\tonWillUnregisterWindow,\n\tonDidUnregisterWindow\n} = (function () {\n\tconst windows = new Map<number, IRegisteredCodeWindow>();\n\n\tensureCodeWindow(mainWindow, 1);\n\tconst mainWindowRegistration = { window: mainWindow, disposables: new DisposableStore() };\n\twindows.set(mainWindow.vscodeWindowId, mainWindowRegistration);\n\n\tconst onDidRegisterWindow = new event.Emitter<IRegisteredCodeWindow>();\n\tconst onDidUnregisterWindow = new event.Emitter<CodeWindow>();\n\tconst onWillUnregisterWindow = new event.Emitter<CodeWindow>();\n\n\tfunction getWindowById(windowId: number): IRegisteredCodeWindow | undefined;\n\tfunction getWindowById(windowId: number | undefined, fallbackToMain: true): IRegisteredCodeWindow;\n\tfunction getWindowById(windowId: number | undefined, fallbackToMain?: boolean): IRegisteredCodeWindow | undefined {\n\t\tconst window = typeof windowId === 'number' ? windows.get(windowId) : undefined;\n\n\t\treturn window ?? (fallbackToMain ? mainWindowRegistration : undefined);\n\t}\n\n\treturn {\n\t\tonDidRegisterWindow: onDidRegisterWindow.event,\n\t\tonWillUnregisterWindow: onWillUnregisterWindow.event,\n\t\tonDidUnregisterWindow: onDidUnregisterWindow.event,\n\t\tregisterWindow(window: CodeWindow): IDisposable {\n\t\t\tif (windows.has(window.vscodeWindowId)) {\n\t\t\t\treturn Disposable.None;\n\t\t\t}\n\n\t\t\tconst disposables = new DisposableStore();\n\n\t\t\tconst registeredWindow = {\n\t\t\t\twindow,\n\t\t\t\tdisposables: disposables.add(new DisposableStore())\n\t\t\t};\n\t\t\twindows.set(window.vscodeWindowId, registeredWindow);\n\n\t\t\tdisposables.add(toDisposable(() => {\n\t\t\t\twindows.delete(window.vscodeWindowId);\n\t\t\t\tonDidUnregisterWindow.fire(window);\n\t\t\t}));\n\n\t\t\tdisposables.add(addDisposableListener(window, EventType.BEFORE_UNLOAD, () => {\n\t\t\t\tonWillUnregisterWindow.fire(window);\n\t\t\t}));\n\n\t\t\tonDidRegisterWindow.fire(registeredWindow);\n\n\t\t\treturn disposables;\n\t\t},\n\t\tgetWindows(): Iterable<IRegisteredCodeWindow> {\n\t\t\treturn windows.values();\n\t\t},\n\t\tgetWindowsCount(): number {\n\t\t\treturn windows.size;\n\t\t},\n\t\tgetWindowId(targetWindow: Window): number {\n\t\t\treturn (targetWindow as CodeWindow).vscodeWindowId;\n\t\t},\n\t\thasWindow(windowId: number): boolean {\n\t\t\treturn windows.has(windowId);\n\t\t},\n\t\tgetWindowById,\n\t\tgetWindow(e: Node | UIEvent | undefined | null): CodeWindow {\n\t\t\tconst candidateNode = e as Node | undefined | null;\n\t\t\tif (candidateNode?.ownerDocument?.defaultView) {\n\t\t\t\treturn candidateNode.ownerDocument.defaultView.window as CodeWindow;\n\t\t\t}\n\n\t\t\tconst candidateEvent = e as UIEvent | undefined | null;\n\t\t\tif (candidateEvent?.view) {\n\t\t\t\treturn candidateEvent.view.window as CodeWindow;\n\t\t\t}\n\n\t\t\treturn mainWindow;\n\t\t},\n\t\tgetDocument(e: Node | UIEvent | undefined | null): Document {\n\t\t\tconst candidateNode = e as Node | undefined | null;\n\t\t\treturn getWindow(candidateNode).document;\n\t\t}\n\t};\n})();\n\n//#endregion\n\nexport function clearNode(node: HTMLElement): void {\n\twhile (node.firstChild) {\n\t\tnode.firstChild.remove();\n\t}\n}\n\n\nexport function clearNodeRecursively(domNode: ChildNode) {\n\twhile (domNode.firstChild) {\n\t\tconst element = domNode.firstChild;\n\t\telement.remove();\n\t\tclearNodeRecursively(element);\n\t}\n}\n\n\nclass DomListener implements IDisposable {\n\n\tprivate _handler: (e: any) => void;\n\tprivate _node: EventTarget;\n\tprivate readonly _type: string;\n\tprivate readonly _options: boolean | AddEventListenerOptions;\n\n\tconstructor(node: EventTarget, type: string, handler: (e: any) => void, options?: boolean | AddEventListenerOptions) {\n\t\tthis._node = node;\n\t\tthis._type = type;\n\t\tthis._handler = handler;\n\t\tthis._options = (options || false);\n\t\tthis._node.addEventListener(this._type, this._handler, this._options);\n\t}\n\n\tdispose(): void {\n\t\tif (!this._handler) {\n\t\t\t// Already disposed\n\t\t\treturn;\n\t\t}\n\n\t\tthis._node.removeEventListener(this._type, this._handler, this._options);\n\n\t\t// Prevent leakers from holding on to the dom or handler func\n\t\tthis._node = null!;\n\t\tthis._handler = null!;\n\t}\n}\n\nexport function addDisposableListener<K extends keyof GlobalEventHandlersEventMap>(node: EventTarget, type: K, handler: (event: GlobalEventHandlersEventMap[K]) => void, useCapture?: boolean): IDisposable;\nexport function addDisposableListener(node: EventTarget, type: string, handler: (event: any) => void, useCapture?: boolean): IDisposable;\nexport function addDisposableListener(node: EventTarget, type: string, handler: (event: any) => void, options: AddEventListenerOptions): IDisposable;\nexport function addDisposableListener(node: EventTarget, type: string, handler: (event: any) => void, useCaptureOrOptions?: boolean | AddEventListenerOptions): IDisposable {\n\treturn new DomListener(node, type, handler, useCaptureOrOptions);\n}\n\nexport interface IAddStandardDisposableListenerSignature {\n\t(node: HTMLElement, type: 'click', handler: (event: IMouseEvent) => void, useCapture?: boolean): IDisposable;\n\t(node: HTMLElement, type: 'mousedown', handler: (event: IMouseEvent) => void, useCapture?: boolean): IDisposable;\n\t(node: HTMLElement, type: 'keydown', handler: (event: IKeyboardEvent) => void, useCapture?: boolean): IDisposable;\n\t(node: HTMLElement, type: 'keypress', handler: (event: IKeyboardEvent) => void, useCapture?: boolean): IDisposable;\n\t(node: HTMLElement, type: 'keyup', handler: (event: IKeyboardEvent) => void, useCapture?: boolean): IDisposable;\n\t(node: HTMLElement, type: 'pointerdown', handler: (event: PointerEvent) => void, useCapture?: boolean): IDisposable;\n\t(node: HTMLElement, type: 'pointermove', handler: (event: PointerEvent) => void, useCapture?: boolean): IDisposable;\n\t(node: HTMLElement, type: 'pointerup', handler: (event: PointerEvent) => void, useCapture?: boolean): IDisposable;\n\t(node: HTMLElement, type: string, handler: (event: any) => void, useCapture?: boolean): IDisposable;\n}\nfunction _wrapAsStandardMouseEvent(targetWindow: Window, handler: (e: IMouseEvent) => void): (e: MouseEvent) => void {\n\treturn function (e: MouseEvent) {\n\t\treturn handler(new StandardMouseEvent(targetWindow, e));\n\t};\n}\nfunction _wrapAsStandardKeyboardEvent(handler: (e: IKeyboardEvent) => void): (e: KeyboardEvent) => void {\n\treturn function (e: KeyboardEvent) {\n\t\treturn handler(new StandardKeyboardEvent(e));\n\t};\n}\nexport const addStandardDisposableListener: IAddStandardDisposableListenerSignature = function addStandardDisposableListener(node: HTMLElement, type: string, handler: (event: any) => void, useCapture?: boolean): IDisposable {\n\tlet wrapHandler = handler;\n\n\tif (type === 'click' || type === 'mousedown' || type === 'contextmenu') {\n\t\twrapHandler = _wrapAsStandardMouseEvent(getWindow(node), handler);\n\t} else if (type === 'keydown' || type === 'keypress' || type === 'keyup') {\n\t\twrapHandler = _wrapAsStandardKeyboardEvent(handler);\n\t}\n\n\treturn addDisposableListener(node, type, wrapHandler, useCapture);\n};\n\nexport const addStandardDisposableGenericMouseDownListener = function addStandardDisposableListener(node: HTMLElement, handler: (event: any) => void, useCapture?: boolean): IDisposable {\n\tconst wrapHandler = _wrapAsStandardMouseEvent(getWindow(node), handler);\n\n\treturn addDisposableGenericMouseDownListener(node, wrapHandler, useCapture);\n};\n\nexport const addStandardDisposableGenericMouseUpListener = function addStandardDisposableListener(node: HTMLElement, handler: (event: any) => void, useCapture?: boolean): IDisposable {\n\tconst wrapHandler = _wrapAsStandardMouseEvent(getWindow(node), handler);\n\n\treturn addDisposableGenericMouseUpListener(node, wrapHandler, useCapture);\n};\nexport function addDisposableGenericMouseDownListener(node: EventTarget, handler: (event: any) => void, useCapture?: boolean): IDisposable {\n\treturn addDisposableListener(node, platform.isIOS && BrowserFeatures.pointerEvents ? EventType.POINTER_DOWN : EventType.MOUSE_DOWN, handler, useCapture);\n}\n\nexport function addDisposableGenericMouseMoveListener(node: EventTarget, handler: (event: any) => void, useCapture?: boolean): IDisposable {\n\treturn addDisposableListener(node, platform.isIOS && BrowserFeatures.pointerEvents ? EventType.POINTER_MOVE : EventType.MOUSE_MOVE, handler, useCapture);\n}\n\nexport function addDisposableGenericMouseUpListener(node: EventTarget, handler: (event: any) => void, useCapture?: boolean): IDisposable {\n\treturn addDisposableListener(node, platform.isIOS && BrowserFeatures.pointerEvents ? EventType.POINTER_UP : EventType.MOUSE_UP, handler, useCapture);\n}\n\n/**\n * Execute the callback the next time the browser is idle, returning an\n * {@link IDisposable} that will cancel the callback when disposed. This wraps\n * [requestIdleCallback] so it will fallback to [setTimeout] if the environment\n * doesn't support it.\n *\n * @param targetWindow The window for which to run the idle callback\n * @param callback The callback to run when idle, this includes an\n * [IdleDeadline] that provides the time alloted for the idle callback by the\n * browser. Not respecting this deadline will result in a degraded user\n * experience.\n * @param timeout A timeout at which point to queue no longer wait for an idle\n * callback but queue it on the regular event loop (like setTimeout). Typically\n * this should not be used.\n *\n * [IdleDeadline]: https://developer.mozilla.org/en-US/docs/Web/API/IdleDeadline\n * [requestIdleCallback]: https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\n * [setTimeout]: https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout\n */\nexport function runWhenWindowIdle(targetWindow: Window | typeof globalThis, callback: (idle: IdleDeadline) => void, timeout?: number): IDisposable {\n\treturn _runWhenIdle(targetWindow, callback, timeout);\n}\n\n/**\n * An implementation of the \"idle-until-urgent\"-strategy as introduced\n * here: https://philipwalton.com/articles/idle-until-urgent/\n */\nexport class WindowIdleValue<T> extends AbstractIdleValue<T> {\n\tconstructor(targetWindow: Window | typeof globalThis, executor: () => T) {\n\t\tsuper(targetWindow, executor);\n\t}\n}\n\n/**\n * Schedule a callback to be run at the next animation frame.\n * This allows multiple parties to register callbacks that should run at the next animation frame.\n * If currently in an animation frame, `runner` will be executed immediately.\n * @return token that can be used to cancel the scheduled runner (only if `runner` was not executed immediately).\n */\nexport let runAtThisOrScheduleAtNextAnimationFrame: (targetWindow: Window, runner: () => void, priority?: number) => IDisposable;\n/**\n * Schedule a callback to be run at the next animation frame.\n * This allows multiple parties to register callbacks that should run at the next animation frame.\n * If currently in an animation frame, `runner` will be executed at the next animation frame.\n * @return token that can be used to cancel the scheduled runner.\n */\nexport let scheduleAtNextAnimationFrame: (targetWindow: Window, runner: () => void, priority?: number) => IDisposable;\n\nexport function disposableWindowInterval(targetWindow: Window, handler: () => void | boolean /* stop interval */ | Promise<unknown>, interval: number, iterations?: number): IDisposable {\n\tlet iteration = 0;\n\tconst timer = targetWindow.setInterval(() => {\n\t\titeration++;\n\t\tif ((typeof iterations === 'number' && iteration >= iterations) || handler() === true) {\n\t\t\tdisposable.dispose();\n\t\t}\n\t}, interval);\n\tconst disposable = toDisposable(() => {\n\t\ttargetWindow.clearInterval(timer);\n\t});\n\treturn disposable;\n}\n\nexport class WindowIntervalTimer extends IntervalTimer {\n\n\tprivate readonly defaultTarget?: Window & typeof globalThis;\n\n\t/**\n\t *\n\t * @param node The optional node from which the target window is determined\n\t */\n\tconstructor(node?: Node) {\n\t\tsuper();\n\t\tthis.defaultTarget = node && getWindow(node);\n\t}\n\n\toverride cancelAndSet(runner: () => void, interval: number, targetWindow?: Window & typeof globalThis): void {\n\t\treturn super.cancelAndSet(runner, interval, targetWindow ?? this.defaultTarget);\n\t}\n}\n\nclass AnimationFrameQueueItem implements IDisposable {\n\n\tprivate _runner: () => void;\n\tpublic priority: number;\n\tprivate _canceled: boolean;\n\n\tconstructor(runner: () => void, priority: number = 0) {\n\t\tthis._runner = runner;\n\t\tthis.priority = priority;\n\t\tthis._canceled = false;\n\t}\n\n\tdispose(): void {\n\t\tthis._canceled = true;\n\t}\n\n\texecute(): void {\n\t\tif (this._canceled) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tthis._runner();\n\t\t} catch (e) {\n\t\t\tonUnexpectedError(e);\n\t\t}\n\t}\n\n\t// Sort by priority (largest to lowest)\n\tstatic sort(a: AnimationFrameQueueItem, b: AnimationFrameQueueItem): number {\n\t\treturn b.priority - a.priority;\n\t}\n}\n\n(function () {\n\t/**\n\t * The runners scheduled at the next animation frame\n\t */\n\tconst NEXT_QUEUE = new Map<number /* window ID */, AnimationFrameQueueItem[]>();\n\t/**\n\t * The runners scheduled at the current animation frame\n\t */\n\tconst CURRENT_QUEUE = new Map<number /* window ID */, AnimationFrameQueueItem[]>();\n\t/**\n\t * A flag to keep track if the native requestAnimationFrame was already called\n\t */\n\tconst animFrameRequested = new Map<number /* window ID */, boolean>();\n\t/**\n\t * A flag to indicate if currently handling a native requestAnimationFrame callback\n\t */\n\tconst inAnimationFrameRunner = new Map<number /* window ID */, boolean>();\n\n\tconst animationFrameRunner = (targetWindowId: number) => {\n\t\tanimFrameRequested.set(targetWindowId, false);\n\n\t\tconst currentQueue = NEXT_QUEUE.get(targetWindowId) ?? [];\n\t\tCURRENT_QUEUE.set(targetWindowId, currentQueue);\n\t\tNEXT_QUEUE.set(targetWindowId, []);\n\n\t\tinAnimationFrameRunner.set(targetWindowId, true);\n\t\twhile (currentQueue.length > 0) {\n\t\t\tcurrentQueue.sort(AnimationFrameQueueItem.sort);\n\t\t\tconst top = currentQueue.shift()!;\n\t\t\ttop.execute();\n\t\t}\n\t\tinAnimationFrameRunner.set(targetWindowId, false);\n\t};\n\n\tscheduleAtNextAnimationFrame = (targetWindow: Window, runner: () => void, priority: number = 0) => {\n\t\tconst targetWindowId = getWindowId(targetWindow);\n\t\tconst item = new AnimationFrameQueueItem(runner, priority);\n\n\t\tlet nextQueue = NEXT_QUEUE.get(targetWindowId);\n\t\tif (!nextQueue) {\n\t\t\tnextQueue = [];\n\t\t\tNEXT_QUEUE.set(targetWindowId, nextQueue);\n\t\t}\n\t\tnextQueue.push(item);\n\n\t\tif (!animFrameRequested.get(targetWindowId)) {\n\t\t\tanimFrameRequested.set(targetWindowId, true);\n\t\t\ttargetWindow.requestAnimationFrame(() => animationFrameRunner(targetWindowId));\n\t\t}\n\n\t\treturn item;\n\t};\n\n\trunAtThisOrScheduleAtNextAnimationFrame = (targetWindow: Window, runner: () => void, priority?: number) => {\n\t\tconst targetWindowId = getWindowId(targetWindow);\n\t\tif (inAnimationFrameRunner.get(targetWindowId)) {\n\t\t\tconst item = new AnimationFrameQueueItem(runner, priority);\n\t\t\tlet currentQueue = CURRENT_QUEUE.get(targetWindowId);\n\t\t\tif (!currentQueue) {\n\t\t\t\tcurrentQueue = [];\n\t\t\t\tCURRENT_QUEUE.set(targetWindowId, currentQueue);\n\t\t\t}\n\t\t\tcurrentQueue.push(item);\n\t\t\treturn item;\n\t\t} else {\n\t\t\treturn scheduleAtNextAnimationFrame(targetWindow, runner, priority);\n\t\t}\n\t};\n})();\n\nexport function measure(targetWindow: Window, callback: () => void): IDisposable {\n\treturn scheduleAtNextAnimationFrame(targetWindow, callback, 10000 /* must be early */);\n}\n\nexport function modify(targetWindow: Window, callback: () => void): IDisposable {\n\treturn scheduleAtNextAnimationFrame(targetWindow, callback, -10000 /* must be late */);\n}\n\n/**\n * Add a throttled listener. `handler` is fired at most every 8.33333ms or with the next animation frame (if browser supports it).\n */\nexport interface IEventMerger<R, E> {\n\t(lastEvent: R | null, currentEvent: E): R;\n}\n\nconst MINIMUM_TIME_MS = 8;\nconst DEFAULT_EVENT_MERGER: IEventMerger<Event, Event> = function (lastEvent: Event | null, currentEvent: Event) {\n\treturn currentEvent;\n};\n\nclass TimeoutThrottledDomListener<R, E extends Event> extends Disposable {\n\n\tconstructor(node: any, type: string, handler: (event: R) => void, eventMerger: IEventMerger<R, E> = <any>DEFAULT_EVENT_MERGER, minimumTimeMs: number = MINIMUM_TIME_MS) {\n\t\tsuper();\n\n\t\tlet lastEvent: R | null = null;\n\t\tlet lastHandlerTime = 0;\n\t\tconst timeout = this._register(new TimeoutTimer());\n\n\t\tconst invokeHandler = () => {\n\t\t\tlastHandlerTime = (new Date()).getTime();\n\t\t\thandler(<R>lastEvent);\n\t\t\tlastEvent = null;\n\t\t};\n\n\t\tthis._register(addDisposableListener(node, type, (e) => {\n\n\t\t\tlastEvent = eventMerger(lastEvent, e);\n\t\t\tconst elapsedTime = (new Date()).getTime() - lastHandlerTime;\n\n\t\t\tif (elapsedTime >= minimumTimeMs) {\n\t\t\t\ttimeout.cancel();\n\t\t\t\tinvokeHandler();\n\t\t\t} else {\n\t\t\t\ttimeout.setIfNotSet(invokeHandler, minimumTimeMs - elapsedTime);\n\t\t\t}\n\t\t}));\n\t}\n}\n\nexport function addDisposableThrottledListener<R, E extends Event = Event>(node: any, type: string, handler: (event: R) => void, eventMerger?: IEventMerger<R, E>, minimumTimeMs?: number): IDisposable {\n\treturn new TimeoutThrottledDomListener<R, E>(node, type, handler, eventMerger, minimumTimeMs);\n}\n\nexport function getComputedStyle(el: HTMLElement): CSSStyleDeclaration {\n\treturn getWindow(el).getComputedStyle(el, null);\n}\n\nexport function getClientArea(element: HTMLElement, fallback?: HTMLElement): Dimension {\n\tconst elWindow = getWindow(element);\n\tconst elDocument = elWindow.document;\n\n\t// Try with DOM clientWidth / clientHeight\n\tif (element !== elDocument.body) {\n\t\treturn new Dimension(element.clientWidth, element.clientHeight);\n\t}\n\n\t// If visual view port exits and it's on mobile, it should be used instead of window innerWidth / innerHeight, or document.body.clientWidth / document.body.clientHeight\n\tif (platform.isIOS && elWindow?.visualViewport) {\n\t\treturn new Dimension(elWindow.visualViewport.width, elWindow.visualViewport.height);\n\t}\n\n\t// Try innerWidth / innerHeight\n\tif (elWindow?.innerWidth && elWindow.innerHeight) {\n\t\treturn new Dimension(elWindow.innerWidth, elWindow.innerHeight);\n\t}\n\n\t// Try with document.body.clientWidth / document.body.clientHeight\n\tif (elDocument.body && elDocument.body.clientWidth && elDocument.body.clientHeight) {\n\t\treturn new Dimension(elDocument.body.clientWidth, elDocument.body.clientHeight);\n\t}\n\n\t// Try with document.documentElement.clientWidth / document.documentElement.clientHeight\n\tif (elDocument.documentElement && elDocument.documentElement.clientWidth && elDocument.documentElement.clientHeight) {\n\t\treturn new Dimension(elDocument.documentElement.clientWidth, elDocument.documentElement.clientHeight);\n\t}\n\n\tif (fallback) {\n\t\treturn getClientArea(fallback);\n\t}\n\n\tthrow new Error('Unable to figure out browser width and height');\n}\n\nclass SizeUtils {\n\t// Adapted from WinJS\n\t// Converts a CSS positioning string for the specified element to pixels.\n\tprivate static convertToPixels(element: HTMLElement, value: string): number {\n\t\treturn parseFloat(value) || 0;\n\t}\n\n\tprivate static getDimension(element: HTMLElement, cssPropertyName: string, jsPropertyName: string): number {\n\t\tconst computedStyle = getComputedStyle(element);\n\t\tconst value = computedStyle ? computedStyle.getPropertyValue(cssPropertyName) : '0';\n\t\treturn SizeUtils.convertToPixels(element, value);\n\t}\n\n\tstatic getBorderLeftWidth(element: HTMLElement): number {\n\t\treturn SizeUtils.getDimension(element, 'border-left-width', 'borderLeftWidth');\n\t}\n\tstatic getBorderRightWidth(element: HTMLElement): number {\n\t\treturn SizeUtils.getDimension(element, 'border-right-width', 'borderRightWidth');\n\t}\n\tstatic getBorderTopWidth(element: HTMLElement): number {\n\t\treturn SizeUtils.getDimension(element, 'border-top-width', 'borderTopWidth');\n\t}\n\tstatic getBorderBottomWidth(element: HTMLElement): number {\n\t\treturn SizeUtils.getDimension(element, 'border-bottom-width', 'borderBottomWidth');\n\t}\n\n\tstatic getPaddingLeft(element: HTMLElement): number {\n\t\treturn SizeUtils.getDimension(element, 'padding-left', 'paddingLeft');\n\t}\n\tstatic getPaddingRight(element: HTMLElement): number {\n\t\treturn SizeUtils.getDimension(element, 'padding-right', 'paddingRight');\n\t}\n\tstatic getPaddingTop(element: HTMLElement): number {\n\t\treturn SizeUtils.getDimension(element, 'padding-top', 'paddingTop');\n\t}\n\tstatic getPaddingBottom(element: HTMLElement): number {\n\t\treturn SizeUtils.getDimension(element, 'padding-bottom', 'paddingBottom');\n\t}\n\n\tstatic getMarginLeft(element: HTMLElement): number {\n\t\treturn SizeUtils.getDimension(element, 'margin-left', 'marginLeft');\n\t}\n\tstatic getMarginTop(element: HTMLElement): number {\n\t\treturn SizeUtils.getDimension(element, 'margin-top', 'marginTop');\n\t}\n\tstatic getMarginRight(element: HTMLElement): number {\n\t\treturn SizeUtils.getDimension(element, 'margin-right', 'marginRight');\n\t}\n\tstatic getMarginBottom(element: HTMLElement): number {\n\t\treturn SizeUtils.getDimension(element, 'margin-bottom', 'marginBottom');\n\t}\n}\n\n// ----------------------------------------------------------------------------------------\n// Position & Dimension\n\nexport interface IDimension {\n\treadonly width: number;\n\treadonly height: number;\n}\n\nexport class Dimension implements IDimension {\n\n\tstatic readonly None = new Dimension(0, 0);\n\n\tconstructor(\n\t\treadonly width: number,\n\t\treadonly height: number,\n\t) { }\n\n\twith(width: number = this.width, height: number = this.height): Dimension {\n\t\tif (width !== this.width || height !== this.height) {\n\t\t\treturn new Dimension(width, height);\n\t\t} else {\n\t\t\treturn this;\n\t\t}\n\t}\n\n\tstatic is(obj: unknown): obj is IDimension {\n\t\treturn typeof obj === 'object' && typeof (<IDimension>obj).height === 'number' && typeof (<IDimension>obj).width === 'number';\n\t}\n\n\tstatic lift(obj: IDimension): Dimension {\n\t\tif (obj instanceof Dimension) {\n\t\t\treturn obj;\n\t\t} else {\n\t\t\treturn new Dimension(obj.width, obj.height);\n\t\t}\n\t}\n\n\tstatic equals(a: Dimension | undefined, b: Dimension | undefined): boolean {\n\t\tif (a === b) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!a || !b) {\n\t\t\treturn false;\n\t\t}\n\t\treturn a.width === b.width && a.height === b.height;\n\t}\n}\n\nexport interface IDomPosition {\n\treadonly left: number;\n\treadonly top: number;\n}\n\nexport function getTopLeftOffset(element: HTMLElement): IDomPosition {\n\t// Adapted from WinJS.Utilities.getPosition\n\t// and added borders to the mix\n\n\tlet offsetParent = element.offsetParent;\n\tlet top = element.offsetTop;\n\tlet left = element.offsetLeft;\n\n\twhile (\n\t\t(element = <HTMLElement>element.parentNode) !== null\n\t\t&& element !== element.ownerDocument.body\n\t\t&& element !== element.ownerDocument.documentElement\n\t) {\n\t\ttop -= element.scrollTop;\n\t\tconst c = isShadowRoot(element) ? null : getComputedStyle(element);\n\t\tif (c) {\n\t\t\tleft -= c.direction !== 'rtl' ? element.scrollLeft : -element.scrollLeft;\n\t\t}\n\n\t\tif (element === offsetParent) {\n\t\t\tleft += SizeUtils.getBorderLeftWidth(element);\n\t\t\ttop += SizeUtils.getBorderTopWidth(element);\n\t\t\ttop += element.offsetTop;\n\t\t\tleft += element.offsetLeft;\n\t\t\toffsetParent = element.offsetParent;\n\t\t}\n\t}\n\n\treturn {\n\t\tleft: left,\n\t\ttop: top\n\t};\n}\n\nexport interface IDomNodePagePosition {\n\tleft: number;\n\ttop: number;\n\twidth: number;\n\theight: number;\n}\n\nexport function size(element: HTMLElement, width: number | null, height: number | null): void {\n\tif (typeof width === 'number') {\n\t\telement.style.width = `${width}px`;\n\t}\n\n\tif (typeof height === 'number') {\n\t\telement.style.height = `${height}px`;\n\t}\n}\n\nexport function position(element: HTMLElement, top: number, right?: number, bottom?: number, left?: number, position: string = 'absolute'): void {\n\tif (typeof top === 'number') {\n\t\telement.style.top = `${top}px`;\n\t}\n\n\tif (typeof right === 'number') {\n\t\telement.style.right = `${right}px`;\n\t}\n\n\tif (typeof bottom === 'number') {\n\t\telement.style.bottom = `${bottom}px`;\n\t}\n\n\tif (typeof left === 'number') {\n\t\telement.style.left = `${left}px`;\n\t}\n\n\telement.style.position = position;\n}\n\n/**\n * Returns the position of a dom node relative to the entire page.\n */\nexport function getDomNodePagePosition(domNode: HTMLElement): IDomNodePagePosition {\n\tconst bb = domNode.getBoundingClientRect();\n\tconst window = getWindow(domNode);\n\treturn {\n\t\tleft: bb.left + window.scrollX,\n\t\ttop: bb.top + window.scrollY,\n\t\twidth: bb.width,\n\t\theight: bb.height\n\t};\n}\n\n/**\n * Returns the effective zoom on a given element before window zoom level is applied\n */\nexport function getDomNodeZoomLevel(domNode: HTMLElement): number {\n\tlet testElement: HTMLElement | null = domNode;\n\tlet zoom = 1.0;\n\tdo {\n\t\tconst elementZoomLevel = (getComputedStyle(testElement) as any).zoom;\n\t\tif (elementZoomLevel !== null && elementZoomLevel !== undefined && elementZoomLevel !== '1') {\n\t\t\tzoom *= elementZoomLevel;\n\t\t}\n\n\t\ttestElement = testElement.parentElement;\n\t} while (testElement !== null && testElement !== testElement.ownerDocument.documentElement);\n\n\treturn zoom;\n}\n\n\n// Adapted from WinJS\n// Gets the width of the element, including margins.\nexport function getTotalWidth(element: HTMLElement): number {\n\tconst margin = SizeUtils.getMarginLeft(element) + SizeUtils.getMarginRight(element);\n\treturn element.offsetWidth + margin;\n}\n\nexport function getContentWidth(element: HTMLElement): number {\n\tconst border = SizeUtils.getBorderLeftWidth(element) + SizeUtils.getBorderRightWidth(element);\n\tconst padding = SizeUtils.getPaddingLeft(element) + SizeUtils.getPaddingRight(element);\n\treturn element.offsetWidth - border - padding;\n}\n\nexport function getTotalScrollWidth(element: HTMLElement): number {\n\tconst margin = SizeUtils.getMarginLeft(element) + SizeUtils.getMarginRight(element);\n\treturn element.scrollWidth + margin;\n}\n\n// Adapted from WinJS\n// Gets the height of the content of the specified element. The content height does not include borders or padding.\nexport function getContentHeight(element: HTMLElement): number {\n\tconst border = SizeUtils.getBorderTopWidth(element) + SizeUtils.getBorderBottomWidth(element);\n\tconst padding = SizeUtils.getPaddingTop(element) + SizeUtils.getPaddingBottom(element);\n\treturn element.offsetHeight - border - padding;\n}\n\n// Adapted from WinJS\n// Gets the height of the element, including its margins.\nexport function getTotalHeight(element: HTMLElement): number {\n\tconst margin = SizeUtils.getMarginTop(element) + SizeUtils.getMarginBottom(element);\n\treturn element.offsetHeight + margin;\n}\n\n// Gets the left coordinate of the specified element relative to the specified parent.\nfunction getRelativeLeft(element: HTMLElement, parent: HTMLElement): number {\n\tif (element === null) {\n\t\treturn 0;\n\t}\n\n\tconst elementPosition = getTopLeftOffset(element);\n\tconst parentPosition = getTopLeftOffset(parent);\n\treturn elementPosition.left - parentPosition.left;\n}\n\nexport function getLargestChildWidth(parent: HTMLElement, children: HTMLElement[]): number {\n\tconst childWidths = children.map((child) => {\n\t\treturn Math.max(getTotalScrollWidth(child), getTotalWidth(child)) + getRelativeLeft(child, parent) || 0;\n\t});\n\tconst maxWidth = Math.max(...childWidths);\n\treturn maxWidth;\n}\n\n// ----------------------------------------------------------------------------------------\n\nexport function isAncestor(testChild: Node | null, testAncestor: Node | null): boolean {\n\treturn Boolean(testAncestor?.contains(testChild));\n}\n\nconst parentFlowToDataKey = 'parentFlowToElementId';\n\n/**\n * Set an explicit parent to use for nodes that are not part of the\n * regular dom structure.\n */\nexport function setParentFlowTo(fromChildElement: HTMLElement, toParentElement: Element): void {\n\tfromChildElement.dataset[parentFlowToDataKey] = toParentElement.id;\n}\n\nfunction getParentFlowToElement(node: HTMLElement): HTMLElement | null {\n\tconst flowToParentId = node.dataset[parentFlowToDataKey];\n\tif (typeof flowToParentId === 'string') {\n\t\treturn node.ownerDocument.getElementById(flowToParentId);\n\t}\n\treturn null;\n}\n\n/**\n * Check if `testAncestor` is an ancestor of `testChild`, observing the explicit\n * parents set by `setParentFlowTo`.\n */\nexport function isAncestorUsingFlowTo(testChild: Node, testAncestor: Node): boolean {\n\tlet node: Node | null = testChild;\n\twhile (node) {\n\t\tif (node === testAncestor) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (isHTMLElement(node)) {\n\t\t\tconst flowToParentElement = getParentFlowToElement(node);\n\t\t\tif (flowToParentElement) {\n\t\t\t\tnode = flowToParentElement;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tnode = node.parentNode;\n\t}\n\n\treturn false;\n}\n\nexport function findParentWithClass(node: HTMLElement, clazz: string, stopAtClazzOrNode?: string | HTMLElement): HTMLElement | null {\n\twhile (node && node.nodeType === node.ELEMENT_NODE) {\n\t\tif (node.classList.contains(clazz)) {\n\t\t\treturn node;\n\t\t}\n\n\t\tif (stopAtClazzOrNode) {\n\t\t\tif (typeof stopAtClazzOrNode === 'string') {\n\t\t\t\tif (node.classList.contains(stopAtClazzOrNode)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (node === stopAtClazzOrNode) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tnode = <HTMLElement>node.parentNode;\n\t}\n\n\treturn null;\n}\n\nexport function hasParentWithClass(node: HTMLElement, clazz: string, stopAtClazzOrNode?: string | HTMLElement): boolean {\n\treturn !!findParentWithClass(node, clazz, stopAtClazzOrNode);\n}\n\nexport function isShadowRoot(node: Node): node is ShadowRoot {\n\treturn (\n\t\tnode && !!(<ShadowRoot>node).host && !!(<ShadowRoot>node).mode\n\t);\n}\n\nexport function isInShadowDOM(domNode: Node): boolean {\n\treturn !!getShadowRoot(domNode);\n}\n\nexport function getShadowRoot(domNode: Node): ShadowRoot | null {\n\twhile (domNode.parentNode) {\n\t\tif (domNode === domNode.ownerDocument?.body) {\n\t\t\t// reached the body\n\t\t\treturn null;\n\t\t}\n\t\tdomNode = domNode.parentNode;\n\t}\n\treturn isShadowRoot(domNode) ? domNode : null;\n}\n\n/**\n * Returns the active element across all child windows\n * based on document focus. Falls back to the main\n * window if no window has focus.\n */\nexport function getActiveElement(): Element | null {\n\tlet result = getActiveDocument().activeElement;\n\n\twhile (result?.shadowRoot) {\n\t\tresult = result.shadowRoot.activeElement;\n\t}\n\n\treturn result;\n}\n\n/**\n * Returns true if the focused window active element matches\n * the provided element. Falls back to the main window if no\n * window has focus.\n */\nexport function isActiveElement(element: Element): boolean {\n\treturn getActiveElement() === element;\n}\n\n/**\n * Returns true if the focused window active element is contained in\n * `ancestor`. Falls back to the main window if no window has focus.\n */\nexport function isAncestorOfActiveElement(ancestor: Element): boolean {\n\treturn isAncestor(getActiveElement(), ancestor);\n}\n\n/**\n * Returns whether the element is in the active `document`. The active\n * document has focus or will be the main windows document.\n */\nexport function isActiveDocument(element: Element): boolean {\n\treturn element.ownerDocument === getActiveDocument();\n}\n\n/**\n * Returns the active document across main and child windows.\n * Prefers the window with focus, otherwise falls back to\n * the main windows document.\n */\nexport function getActiveDocument(): Document {\n\tif (getWindowsCount() <= 1) {\n\t\treturn mainWindow.document;\n\t}\n\n\tconst documents = Array.from(getWindows()).map(({ window }) => window.document);\n\treturn documents.find(doc => doc.hasFocus()) ?? mainWindow.document;\n}\n\n/**\n * Returns the active window across main and child windows.\n * Prefers the window with focus, otherwise falls back to\n * the main window.\n */\nexport function getActiveWindow(): CodeWindow {\n\tconst document = getActiveDocument();\n\treturn (document.defaultView?.window ?? mainWindow) as CodeWindow;\n}\n\nconst globalStylesheets = new Map<HTMLStyleElement /* main stylesheet */, Set<HTMLStyleElement /* aux window clones that track the main stylesheet */>>();\n\nexport function isGlobalStylesheet(node: Node): boolean {\n\treturn globalStylesheets.has(node as HTMLStyleElement);\n}\n\n/**\n * A version of createStyleSheet which has a unified API to initialize/set the style content.\n */\nexport function createStyleSheet2(): WrappedStyleElement {\n\treturn new WrappedStyleElement();\n}\n\nclass WrappedStyleElement {\n\tprivate _currentCssStyle = '';\n\tprivate _styleSheet: HTMLStyleElement | undefined = undefined;\n\n\tpublic setStyle(cssStyle: string): void {\n\t\tif (cssStyle === this._currentCssStyle) {\n\t\t\treturn;\n\t\t}\n\t\tthis._currentCssStyle = cssStyle;\n\n\t\tif (!this._styleSheet) {\n\t\t\tthis._styleSheet = createStyleSheet(mainWindow.document.head, (s) => s.innerText = cssStyle);\n\t\t} else {\n\t\t\tthis._styleSheet.innerText = cssStyle;\n\t\t}\n\t}\n\n\tpublic dispose(): void {\n\t\tif (this._styleSheet) {\n\t\t\tthis._styleSheet.remove();\n\t\t\tthis._styleSheet = undefined;\n\t\t}\n\t}\n}\n\nexport function createStyleSheet(container: HTMLElement = mainWindow.document.head, beforeAppend?: (style: HTMLStyleElement) => void, disposableStore?: DisposableStore): HTMLStyleElement {\n\tconst style = document.createElement('style');\n\tstyle.type = 'text/css';\n\tstyle.media = 'screen';\n\tbeforeAppend?.(style);\n\tcontainer.appendChild(style);\n\n\tif (disposableStore) {\n\t\tdisposableStore.add(toDisposable(() => style.remove()));\n\t}\n\n\t// With <head> as container, the stylesheet becomes global and is tracked\n\t// to support auxiliary windows to clone the stylesheet.\n\tif (container === mainWindow.document.head) {\n\t\tconst globalStylesheetClones = new Set<HTMLStyleElement>();\n\t\tglobalStylesheets.set(style, globalStylesheetClones);\n\n\t\tfor (const { window: targetWindow, disposables } of getWindows()) {\n\t\t\tif (targetWindow === mainWindow) {\n\t\t\t\tcontinue; // main window is already tracked\n\t\t\t}\n\n\t\t\tconst cloneDisposable = disposables.add(cloneGlobalStyleSheet(style, globalStylesheetClones, targetWindow));\n\t\t\tdisposableStore?.add(cloneDisposable);\n\t\t}\n\t}\n\n\treturn style;\n}\n\nexport function cloneGlobalStylesheets(targetWindow: Window): IDisposable {\n\tconst disposables = new DisposableStore();\n\n\tfor (const [globalStylesheet, clonedGlobalStylesheets] of globalStylesheets) {\n\t\tdisposables.add(cloneGlobalStyleSheet(globalStylesheet, clonedGlobalStylesheets, targetWindow));\n\t}\n\n\treturn disposables;\n}\n\nfunction cloneGlobalStyleSheet(globalStylesheet: HTMLStyleElement, globalStylesheetClones: Set<HTMLStyleElement>, targetWindow: Window): IDisposable {\n\tconst disposables = new DisposableStore();\n\n\tconst clone = globalStylesheet.cloneNode(true) as HTMLStyleElement;\n\ttargetWindow.document.head.appendChild(clone);\n\tdisposables.add(toDisposable(() => clone.remove()));\n\n\tfor (const rule of getDynamicStyleSheetRules(globalStylesheet)) {\n\t\tclone.sheet?.insertRule(rule.cssText, clone.sheet?.cssRules.length);\n\t}\n\n\tdisposables.add(sharedMutationObserver.observe(globalStylesheet, disposables, { childList: true })(() => {\n\t\tclone.textContent = globalStylesheet.textContent;\n\t}));\n\n\tglobalStylesheetClones.add(clone);\n\tdisposables.add(toDisposable(() => globalStylesheetClones.delete(clone)));\n\n\treturn disposables;\n}\n\ninterface IMutationObserver {\n\tusers: number;\n\treadonly observer: MutationObserver;\n\treadonly onDidMutate: event.Event<MutationRecord[]>;\n}\n\nexport const sharedMutationObserver = new class {\n\n\treadonly mutationObservers = new Map<Node, Map<number, IMutationObserver>>();\n\n\tobserve(target: Node, disposables: DisposableStore, options?: MutationObserverInit): event.Event<MutationRecord[]> {\n\t\tlet mutationObserversPerTarget = this.mutationObservers.get(target);\n\t\tif (!mutationObserversPerTarget) {\n\t\t\tmutationObserversPerTarget = new Map<number, IMutationObserver>();\n\t\t\tthis.mutationObservers.set(target, mutationObserversPerTarget);\n\t\t}\n\n\t\tconst optionsHash = hash(options);\n\t\tlet mutationObserverPerOptions = mutationObserversPerTarget.get(optionsHash);\n\t\tif (!mutationObserverPerOptions) {\n\t\t\tconst onDidMutate = new event.Emitter<MutationRecord[]>();\n\t\t\tconst observer = new MutationObserver(mutations => onDidMutate.fire(mutations));\n\t\t\tobserver.observe(target, options);\n\n\t\t\tconst resolvedMutationObserverPerOptions = mutationObserverPerOptions = {\n\t\t\t\tusers: 1,\n\t\t\t\tobserver,\n\t\t\t\tonDidMutate: onDidMutate.event\n\t\t\t};\n\n\t\t\tdisposables.add(toDisposable(() => {\n\t\t\t\tresolvedMutationObserverPerOptions.users -= 1;\n\n\t\t\t\tif (resolvedMutationObserverPerOptions.users === 0) {\n\t\t\t\t\tonDidMutate.dispose();\n\t\t\t\t\tobserver.disconnect();\n\n\t\t\t\t\tmutationObserversPerTarget?.delete(optionsHash);\n\t\t\t\t\tif (mutationObserversPerTarget?.size === 0) {\n\t\t\t\t\t\tthis.mutationObservers.delete(target);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\tmutationObserversPerTarget.set(optionsHash, mutationObserverPerOptions);\n\t\t} else {\n\t\t\tmutationObserverPerOptions.users += 1;\n\t\t}\n\n\t\treturn mutationObserverPerOptions.onDidMutate;\n\t}\n};\n\nexport function createMetaElement(container: HTMLElement = mainWindow.document.head): HTMLMetaElement {\n\treturn createHeadElement('meta', container) as HTMLMetaElement;\n}\n\nexport function createLinkElement(container: HTMLElement = mainWindow.document.head): HTMLLinkElement {\n\treturn createHeadElement('link', container) as HTMLLinkElement;\n}\n\nfunction createHeadElement(tagName: string, container: HTMLElement = mainWindow.document.head): HTMLElement {\n\tconst element = document.createElement(tagName);\n\tcontainer.appendChild(element);\n\treturn element;\n}\n\nlet _sharedStyleSheet: HTMLStyleElement | null = null;\nfunction getSharedStyleSheet(): HTMLStyleElement {\n\tif (!_sharedStyleSheet) {\n\t\t_sharedStyleSheet = createStyleSheet();\n\t}\n\treturn _sharedStyleSheet;\n}\n\nfunction getDynamicStyleSheetRules(style: HTMLStyleElement) {\n\tif (style?.sheet?.rules) {\n\t\t// Chrome, IE\n\t\treturn style.sheet.rules;\n\t}\n\tif (style?.sheet?.cssRules) {\n\t\t// FF\n\t\treturn style.sheet.cssRules;\n\t}\n\treturn [];\n}\n\nexport function createCSSRule(selector: string, cssText: string, style = getSharedStyleSheet()): void {\n\tif (!style || !cssText) {\n\t\treturn;\n\t}\n\n\tstyle.sheet?.insertRule(`${selector} {${cssText}}`, 0);\n\n\t// Apply rule also to all cloned global stylesheets\n\tfor (const clonedGlobalStylesheet of globalStylesheets.get(style) ?? []) {\n\t\tcreateCSSRule(selector, cssText, clonedGlobalStylesheet);\n\t}\n}\n\nexport function removeCSSRulesContainingSelector(ruleName: string, style = getSharedStyleSheet()): void {\n\tif (!style) {\n\t\treturn;\n\t}\n\n\tconst rules = getDynamicStyleSheetRules(style);\n\tconst toDelete: number[] = [];\n\tfor (let i = 0; i < rules.length; i++) {\n\t\tconst rule = rules[i];\n\t\tif (isCSSStyleRule(rule) && rule.selectorText.indexOf(ruleName) !== -1) {\n\t\t\ttoDelete.push(i);\n\t\t}\n\t}\n\n\tfor (let i = toDelete.length - 1; i >= 0; i--) {\n\t\tstyle.sheet?.deleteRule(toDelete[i]);\n\t}\n\n\t// Remove rules also from all cloned global stylesheets\n\tfor (const clonedGlobalStylesheet of globalStylesheets.get(style) ?? []) {\n\t\tremoveCSSRulesContainingSelector(ruleName, clonedGlobalStylesheet);\n\t}\n}\n\nfunction isCSSStyleRule(rule: CSSRule): rule is CSSStyleRule {\n\treturn typeof (rule as CSSStyleRule).selectorText === 'string';\n}\n\nexport function isHTMLElement(e: unknown): e is HTMLElement {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn e instanceof HTMLElement || e instanceof getWindow(e as Node).HTMLElement;\n}\n\nexport function isHTMLAnchorElement(e: unknown): e is HTMLAnchorElement {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn e instanceof HTMLAnchorElement || e instanceof getWindow(e as Node).HTMLAnchorElement;\n}\n\nexport function isHTMLSpanElement(e: unknown): e is HTMLSpanElement {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn e instanceof HTMLSpanElement || e instanceof getWindow(e as Node).HTMLSpanElement;\n}\n\nexport function isHTMLTextAreaElement(e: unknown): e is HTMLTextAreaElement {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn e instanceof HTMLTextAreaElement || e instanceof getWindow(e as Node).HTMLTextAreaElement;\n}\n\nexport function isHTMLInputElement(e: unknown): e is HTMLInputElement {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn e instanceof HTMLInputElement || e instanceof getWindow(e as Node).HTMLInputElement;\n}\n\nexport function isHTMLButtonElement(e: unknown): e is HTMLButtonElement {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn e instanceof HTMLButtonElement || e instanceof getWindow(e as Node).HTMLButtonElement;\n}\n\nexport function isHTMLDivElement(e: unknown): e is HTMLDivElement {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn e instanceof HTMLDivElement || e instanceof getWindow(e as Node).HTMLDivElement;\n}\n\nexport function isSVGElement(e: unknown): e is SVGElement {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn e instanceof SVGElement || e instanceof getWindow(e as Node).SVGElement;\n}\n\nexport function isMouseEvent(e: unknown): e is MouseEvent {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn e instanceof MouseEvent || e instanceof getWindow(e as UIEvent).MouseEvent;\n}\n\nexport function isKeyboardEvent(e: unknown): e is KeyboardEvent {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn e instanceof KeyboardEvent || e instanceof getWindow(e as UIEvent).KeyboardEvent;\n}\n\nexport function isPointerEvent(e: unknown): e is PointerEvent {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn e instanceof PointerEvent || e instanceof getWindow(e as UIEvent).PointerEvent;\n}\n\nexport function isDragEvent(e: unknown): e is DragEvent {\n\t// eslint-disable-next-line no-restricted-syntax\n\treturn e instanceof DragEvent || e instanceof getWindow(e as UIEvent).DragEvent;\n}\n\nexport const EventType = {\n\t// Mouse\n\tCLICK: 'click',\n\tAUXCLICK: 'auxclick',\n\tDBLCLICK: 'dblclick',\n\tMOUSE_UP: 'mouseup',\n\tMOUSE_DOWN: 'mousedown',\n\tMOUSE_OVER: 'mouseover',\n\tMOUSE_MOVE: 'mousemove',\n\tMOUSE_OUT: 'mouseout',\n\tMOUSE_ENTER: 'mouseenter',\n\tMOUSE_LEAVE: 'mouseleave',\n\tMOUSE_WHEEL: 'wheel',\n\tPOINTER_UP: 'pointerup',\n\tPOINTER_DOWN: 'pointerdown',\n\tPOINTER_MOVE: 'pointermove',\n\tPOINTER_LEAVE: 'pointerleave',\n\tCONTEXT_MENU: 'contextmenu',\n\tWHEEL: 'wheel',\n\t// Keyboard\n\tKEY_DOWN: 'keydown',\n\tKEY_PRESS: 'keypress',\n\tKEY_UP: 'keyup',\n\t// HTML Document\n\tLOAD: 'load',\n\tBEFORE_UNLOAD: 'beforeunload',\n\tUNLOAD: 'unload',\n\tPAGE_SHOW: 'pageshow',\n\tPAGE_HIDE: 'pagehide',\n\tPASTE: 'paste',\n\tABORT: 'abort',\n\tERROR: 'error',\n\tRESIZE: 'resize',\n\tSCROLL: 'scroll',\n\tFULLSCREEN_CHANGE: 'fullscreenchange',\n\tWK_FULLSCREEN_CHANGE: 'webkitfullscreenchange',\n\t// Form\n\tSELECT: 'select',\n\tCHANGE: 'change',\n\tSUBMIT: 'submit',\n\tRESET: 'reset',\n\tFOCUS: 'focus',\n\tFOCUS_IN: 'focusin',\n\tFOCUS_OUT: 'focusout',\n\tBLUR: 'blur',\n\tINPUT: 'input',\n\t// Local Storage\n\tSTORAGE: 'storage',\n\t// Drag\n\tDRAG_START: 'dragstart',\n\tDRAG: 'drag',\n\tDRAG_ENTER: 'dragenter',\n\tDRAG_LEAVE: 'dragleave',\n\tDRAG_OVER: 'dragover',\n\tDROP: 'drop',\n\tDRAG_END: 'dragend',\n\t// Animation\n\tANIMATION_START: browser.isWebKit ? 'webkitAnimationStart' : 'animationstart',\n\tANIMATION_END: browser.isWebKit ? 'webkitAnimationEnd' : 'animationend',\n\tANIMATION_ITERATION: browser.isWebKit ? 'webkitAnimationIteration' : 'animationiteration'\n} as const;\n\nexport interface EventLike {\n\tpreventDefault(): void;\n\tstopPropagation(): void;\n}\n\nexport function isEventLike(obj: unknown): obj is EventLike {\n\tconst candidate = obj as EventLike | undefined;\n\n\treturn !!(candidate && typeof candidate.preventDefault === 'function' && typeof candidate.stopPropagation === 'function');\n}\n\nexport const EventHelper = {\n\tstop: <T extends EventLike>(e: T, cancelBubble?: boolean): T => {\n\t\te.preventDefault();\n\t\tif (cancelBubble) {\n\t\t\te.stopPropagation();\n\t\t}\n\t\treturn e;\n\t}\n};\n\nexport interface IFocusTracker extends Disposable {\n\treadonly onDidFocus: event.Event<void>;\n\treadonly onDidBlur: event.Event<void>;\n\trefreshState(): void;\n}\n\nexport function saveParentsScrollTop(node: Element): number[] {\n\tconst r: number[] = [];\n\tfor (let i = 0; node && node.nodeType === node.ELEMENT_NODE; i++) {\n\t\tr[i] = node.scrollTop;\n\t\tnode = <Element>node.parentNode;\n\t}\n\treturn r;\n}\n\nexport function restoreParentsScrollTop(node: Element, state: number[]): void {\n\tfor (let i = 0; node && node.nodeType === node.ELEMENT_NODE; i++) {\n\t\tif (node.scrollTop !== state[i]) {\n\t\t\tnode.scrollTop = state[i];\n\t\t}\n\t\tnode = <Element>node.parentNode;\n\t}\n}\n\nclass FocusTracker extends Disposable implements IFocusTracker {\n\n\tprivate readonly _onDidFocus = this._register(new event.Emitter<void>());\n\treadonly onDidFocus = this._onDidFocus.event;\n\n\tprivate readonly _onDidBlur = this._register(new event.Emitter<void>());\n\treadonly onDidBlur = this._onDidBlur.event;\n\n\tprivate _refreshStateHandler: () => void;\n\n\tprivate static hasFocusWithin(element: HTMLElement | Window): boolean {\n\t\tif (isHTMLElement(element)) {\n\t\t\tconst shadowRoot = getShadowRoot(element);\n\t\t\tconst activeElement = (shadowRoot ? shadowRoot.activeElement : element.ownerDocument.activeElement);\n\t\t\treturn isAncestor(activeElement, element);\n\t\t} else {\n\t\t\tconst window = element;\n\t\t\treturn isAncestor(window.document.activeElement, window.document);\n\t\t}\n\t}\n\n\tconstructor(element: HTMLElement | Window) {\n\t\tsuper();\n\t\tlet hasFocus = FocusTracker.hasFocusWithin(element);\n\t\tlet loosingFocus = false;\n\n\t\tconst onFocus = () => {\n\t\t\tloosingFocus = false;\n\t\t\tif (!hasFocus) {\n\t\t\t\thasFocus = true;\n\t\t\t\tthis._onDidFocus.fire();\n\t\t\t}\n\t\t};\n\n\t\tconst onBlur = () => {\n\t\t\tif (hasFocus) {\n\t\t\t\tloosingFocus = true;\n\t\t\t\t(isHTMLElement(element) ? getWindow(element) : element).setTimeout(() => {\n\t\t\t\t\tif (loosingFocus) {\n\t\t\t\t\t\tloosingFocus = false;\n\t\t\t\t\t\thasFocus = false;\n\t\t\t\t\t\tthis._onDidBlur.fire();\n\t\t\t\t\t}\n\t\t\t\t}, 0);\n\t\t\t}\n\t\t};\n\n\t\tthis._refreshStateHandler = () => {\n\t\t\tconst currentNodeHasFocus = FocusTracker.hasFocusWithin(<HTMLElement>element);\n\t\t\tif (currentNodeHasFocus !== hasFocus) {\n\t\t\t\tif (hasFocus) {\n\t\t\t\t\tonBlur();\n\t\t\t\t} else {\n\t\t\t\t\tonFocus();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tthis._register(addDisposableListener(element, EventType.FOCUS, onFocus, true));\n\t\tthis._register(addDisposableListener(element, EventType.BLUR, onBlur, true));\n\t\tif (isHTMLElement(element)) {\n\t\t\tthis._register(addDisposableListener(element, EventType.FOCUS_IN, () => this._refreshStateHandler()));\n\t\t\tthis._register(addDisposableListener(element, EventType.FOCUS_OUT, () => this._refreshStateHandler()));\n\t\t}\n\n\t}\n\n\trefreshState() {\n\t\tthis._refreshStateHandler();\n\t}\n}\n\n/**\n * Creates a new `IFocusTracker` instance that tracks focus changes on the given `element` and its descendants.\n *\n * @param element The `HTMLElement` or `Window` to track focus changes on.\n * @returns An `IFocusTracker` instance.\n */\nexport function trackFocus(element: HTMLElement | Window): IFocusTracker {\n\treturn new FocusTracker(element);\n}\n\nexport function after<T extends Node>(sibling: HTMLElement, child: T): T {\n\tsibling.after(child);\n\treturn child;\n}\n\nexport function append<T extends Node>(parent: HTMLElement, child: T): T;\nexport function append<T extends Node>(parent: HTMLElement, ...children: (T | string)[]): void;\nexport function append<T extends Node>(parent: HTMLElement, ...children: (T | string)[]): T | void {\n\tparent.append(...children);\n\tif (children.length === 1 && typeof children[0] !== 'string') {\n\t\treturn <T>children[0];\n\t}\n}\n\nexport function prepend<T extends Node>(parent: HTMLElement, child: T): T {\n\tparent.insertBefore(child, parent.firstChild);\n\treturn child;\n}\n\n/**\n * Removes all children from `parent` and appends `children`\n */\nexport function reset(parent: HTMLElement, ...children: Array<Node | string>): void {\n\tparent.innerText = '';\n\tappend(parent, ...children);\n}\n\nconst SELECTOR_REGEX = /([\\w\\-]+)?(#([\\w\\-]+))?((\\.([\\w\\-]+))*)/;\n\nexport enum Namespace {\n\tHTML = 'http://www.w3.org/1999/xhtml',\n\tSVG = 'http://www.w3.org/2000/svg'\n}\n\nfunction _$<T extends Element>(namespace: Namespace, description: string, attrs?: { [key: string]: any }, ...children: Array<Node | string>): T {\n\tconst match = SELECTOR_REGEX.exec(description);\n\n\tif (!match) {\n\t\tthrow new Error('Bad use of emmet');\n\t}\n\n\tconst tagName = match[1] || 'div';\n\tlet result: T;\n\n\tif (namespace !== Namespace.HTML) {\n\t\tresult = document.createElementNS(namespace as string, tagName) as T;\n\t} else {\n\t\tresult = document.createElement(tagName) as unknown as T;\n\t}\n\n\tif (match[3]) {\n\t\tresult.id = match[3];\n\t}\n\tif (match[4]) {\n\t\tresult.className = match[4].replace(/\\./g, ' ').trim();\n\t}\n\n\tif (attrs) {\n\t\tObject.entries(attrs).forEach(([name, value]) => {\n\t\t\tif (typeof value === 'undefined') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (/^on\\w+$/.test(name)) {\n\t\t\t\t(<any>result)[name] = value;\n\t\t\t} else if (name === 'selected') {\n\t\t\t\tif (value) {\n\t\t\t\t\tresult.setAttribute(name, 'true');\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tresult.setAttribute(name, value);\n\t\t\t}\n\t\t});\n\t}\n\n\tresult.append(...children);\n\n\treturn result as T;\n}\n\nexport function $<T extends HTMLElement>(description: string, attrs?: { [key: string]: any }, ...children: Array<Node | string>): T {\n\treturn _$(Namespace.HTML, description, attrs, ...children);\n}\n\n$.SVG = function <T extends SVGElement>(description: string, attrs?: { [key: string]: any }, ...children: Array<Node | string>): T {\n\treturn _$(Namespace.SVG, description, attrs, ...children);\n};\n\nexport function join(nodes: Node[], separator: Node | string): Node[] {\n\tconst result: Node[] = [];\n\n\tnodes.forEach((node, index) => {\n\t\tif (index > 0) {\n\t\t\tif (separator instanceof Node) {\n\t\t\t\tresult.push(separator.cloneNode());\n\t\t\t} else {\n\t\t\t\tresult.push(document.createTextNode(separator));\n\t\t\t}\n\t\t}\n\n\t\tresult.push(node);\n\t});\n\n\treturn result;\n}\n\nexport function setVisibility(visible: boolean, ...elements: HTMLElement[]): void {\n\tif (visible) {\n\t\tshow(...elements);\n\t} else {\n\t\thide(...elements);\n\t}\n}\n\nexport function show(...elements: HTMLElement[]): void {\n\tfor (const element of elements) {\n\t\telement.style.display = '';\n\t\telement.removeAttribute('aria-hidden');\n\t}\n}\n\nexport function hide(...elements: HTMLElement[]): void {\n\tfor (const element of elements) {\n\t\telement.style.display = 'none';\n\t\telement.setAttribute('aria-hidden', 'true');\n\t}\n}\n\nfunction findParentWithAttribute(node: Node | null, attribute: string): HTMLElement | null {\n\twhile (node && node.nodeType === node.ELEMENT_NODE) {\n\t\tif (isHTMLElement(node) && node.hasAttribute(attribute)) {\n\t\t\treturn node;\n\t\t}\n\n\t\tnode = node.parentNode;\n\t}\n\n\treturn null;\n}\n\nexport function removeTabIndexAndUpdateFocus(node: HTMLElement): void {\n\tif (!node || !node.hasAttribute('tabIndex')) {\n\t\treturn;\n\t}\n\n\t// If we are the currently focused element and tabIndex is removed,\n\t// standard DOM behavior is to move focus to the <body> element. We\n\t// typically never want that, rather put focus to the closest element\n\t// in the hierarchy of the parent DOM nodes.\n\tif (node.ownerDocument.activeElement === node) {\n\t\tconst parentFocusable = findParentWithAttribute(node.parentElement, 'tabIndex');\n\t\tparentFocusable?.focus();\n\t}\n\n\tnode.removeAttribute('tabindex');\n}\n\nexport function finalHandler<T extends Event>(fn: (event: T) => any): (event: T) => any {\n\treturn e => {\n\t\te.preventDefault();\n\t\te.stopPropagation();\n\t\tfn(e);\n\t};\n}\n\nexport function domContentLoaded(targetWindow: Window): Promise<void> {\n\treturn new Promise<void>(resolve => {\n\t\tconst readyState = targetWindow.document.readyState;\n\t\tif (readyState === 'complete' || (targetWindow.document && targetWindow.document.body !== null)) {\n\t\t\tresolve(undefined);\n\t\t} else {\n\t\t\tconst listener = () => {\n\t\t\t\ttargetWindow.window.removeEventListener('DOMContentLoaded', listener, false);\n\t\t\t\tresolve();\n\t\t\t};\n\n\t\t\ttargetWindow.window.addEventListener('DOMContentLoaded', listener, false);\n\t\t}\n\t});\n}\n\n/**\n * Find a value usable for a dom node size such that the likelihood that it would be\n * displayed with constant screen pixels size is as high as possible.\n *\n * e.g. We would desire for the cursors to be 2px (CSS px) wide. Under a devicePixelRatio\n * of 1.25, the cursor will be 2.5 screen pixels wide. Depending on how the dom node aligns/\"snaps\"\n * with the screen pixels, it will sometimes be rendered with 2 screen pixels, and sometimes with 3 screen pixels.\n */\nexport function computeScreenAwareSize(window: Window, cssPx: number): number {\n\tconst screenPx = window.devicePixelRatio * cssPx;\n\treturn Math.max(1, Math.floor(screenPx)) / window.devicePixelRatio;\n}\n\n/**\n * Open safely a new window. This is the best way to do so, but you cannot tell\n * if the window was opened or if it was blocked by the browser's popup blocker.\n * If you want to tell if the browser blocked the new window, use {@link windowOpenWithSuccess}.\n *\n * See https://github.com/microsoft/monaco-editor/issues/601\n * To protect against malicious code in the linked site, particularly phishing attempts,\n * the window.opener should be set to null to prevent the linked site from having access\n * to change the location of the current page.\n * See https://mathiasbynens.github.io/rel-noopener/\n */\nexport function windowOpenNoOpener(url: string): void {\n\t// By using 'noopener' in the `windowFeatures` argument, the newly created window will\n\t// not be able to use `window.opener` to reach back to the current page.\n\t// See https://stackoverflow.com/a/46958731\n\t// See https://developer.mozilla.org/en-US/docs/Web/API/Window/open#noopener\n\t// However, this also doesn't allow us to realize if the browser blocked\n\t// the creation of the window.\n\tmainWindow.open(url, '_blank', 'noopener');\n}\n\n/**\n * Open a new window in a popup. This is the best way to do so, but you cannot tell\n * if the window was opened or if it was blocked by the browser's popup blocker.\n * If you want to tell if the browser blocked the new window, use {@link windowOpenWithSuccess}.\n *\n * Note: this does not set {@link window.opener} to null. This is to allow the opened popup to\n * be able to use {@link window.close} to close itself. Because of this, you should only use\n * this function on urls that you trust.\n *\n * In otherwords, you should almost always use {@link windowOpenNoOpener} instead of this function.\n */\nconst popupWidth = 780, popupHeight = 640;\nexport function windowOpenPopup(url: string): void {\n\tconst left = Math.floor(mainWindow.screenLeft + mainWindow.innerWidth / 2 - popupWidth / 2);\n\tconst top = Math.floor(mainWindow.screenTop + mainWindow.innerHeight / 2 - popupHeight / 2);\n\tmainWindow.open(\n\t\turl,\n\t\t'_blank',\n\t\t`width=${popupWidth},height=${popupHeight},top=${top},left=${left}`\n\t);\n}\n\n/**\n * Attempts to open a window and returns whether it succeeded. This technique is\n * not appropriate in certain contexts, like for example when the JS context is\n * executing inside a sandboxed iframe. If it is not necessary to know if the\n * browser blocked the new window, use {@link windowOpenNoOpener}.\n *\n * See https://github.com/microsoft/monaco-editor/issues/601\n * See https://github.com/microsoft/monaco-editor/issues/2474\n * See https://mathiasbynens.github.io/rel-noopener/\n *\n * @param url the url to open\n * @param noOpener whether or not to set the {@link window.opener} to null. You should leave the default\n * (true) unless you trust the url that is being opened.\n * @returns boolean indicating if the {@link window.open} call succeeded\n */\nexport function windowOpenWithSuccess(url: string, noOpener = true): boolean {\n\tconst newTab = mainWindow.open();\n\tif (newTab) {\n\t\tif (noOpener) {\n\t\t\t// see `windowOpenNoOpener` for details on why this is important\n\t\t\t(newTab as any).opener = null;\n\t\t}\n\t\tnewTab.location.href = url;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nexport function animate(targetWindow: Window, fn: () => void): IDisposable {\n\tconst step = () => {\n\t\tfn();\n\t\tstepDisposable = scheduleAtNextAnimationFrame(targetWindow, step);\n\t};\n\n\tlet stepDisposable = scheduleAtNextAnimationFrame(targetWindow, step);\n\treturn toDisposable(() => stepDisposable.dispose());\n}\n\nexport function asCSSPropertyValue(value: string) {\n\treturn `'${value.replace(/'/g, '%27')}'`;\n}\n\nexport function asCssValueWithDefault(cssPropertyValue: string | undefined, dflt: string): string {\n\tif (cssPropertyValue !== undefined) {\n\t\tconst variableMatch = cssPropertyValue.match(/^\\s*var\\((.+)\\)$/);\n\t\tif (variableMatch) {\n\t\t\tconst varArguments = variableMatch[1].split(',', 2);\n\t\t\tif (varArguments.length === 2) {\n\t\t\t\tdflt = asCssValueWithDefault(varArguments[1].trim(), dflt);\n\t\t\t}\n\t\t\treturn `var(${varArguments[0]}, ${dflt})`;\n\t\t}\n\t\treturn cssPropertyValue;\n\t}\n\treturn dflt;\n}\n\nexport enum DetectedFullscreenMode {\n\n\t/**\n\t * The document is fullscreen, e.g. because an element\n\t * in the document requested to be fullscreen.\n\t */\n\tDOCUMENT = 1,\n\n\t/**\n\t * The browser is fullscreen, e.g. because the user enabled\n\t * native window fullscreen for it.\n\t */\n\tBROWSER\n}\n\nexport interface IDetectedFullscreen {\n\n\t/**\n\t * Figure out if the document is fullscreen or the browser.\n\t */\n\tmode: DetectedFullscreenMode;\n\n\t/**\n\t * Whether we know for sure that we are in fullscreen mode or\n\t * it is a guess.\n\t */\n\tguess: boolean;\n}\n\nexport function detectFullscreen(targetWindow: Window): IDetectedFullscreen | null {\n\n\t// Browser fullscreen: use DOM APIs to detect\n\tif (targetWindow.document.fullscreenElement || (<any>targetWindow.document).webkitFullscreenElement || (<any>targetWindow.document).webkitIsFullScreen) {\n\t\treturn { mode: DetectedFullscreenMode.DOCUMENT, guess: false };\n\t}\n\n\t// There is no standard way to figure out if the browser\n\t// is using native fullscreen. Via checking on screen\n\t// height and comparing that to window height, we can guess\n\t// it though.\n\n\tif (targetWindow.innerHeight === targetWindow.screen.height) {\n\t\t// if the height of the window matches the screen height, we can\n\t\t// safely assume that the browser is fullscreen because no browser\n\t\t// chrome is taking height away (e.g. like toolbars).\n\t\treturn { mode: DetectedFullscreenMode.BROWSER, guess: false };\n\t}\n\n\tif (platform.isMacintosh || platform.isLinux) {\n\t\t// macOS and Linux do not properly report `innerHeight`, only Windows does\n\t\tif (targetWindow.outerHeight === targetWindow.screen.height && targetWindow.outerWidth === targetWindow.screen.width) {\n\t\t\t// if the height of the browser matches the screen height, we can\n\t\t\t// only guess that we are in fullscreen. It is also possible that\n\t\t\t// the user has turned off taskbars in the OS and the browser is\n\t\t\t// simply able to span the entire size of the screen.\n\t\t\treturn { mode: DetectedFullscreenMode.BROWSER, guess: true };\n\t\t}\n\t}\n\n\t// Not in fullscreen\n\treturn null;\n}\n\n/**\n * Convert a Unicode string to a string in which each 16-bit unit occupies only one byte\n *\n * From https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/btoa\n */\nfunction toBinary(str: string): string {\n\tconst codeUnits = new Uint16Array(str.length);\n\tfor (let i = 0; i < codeUnits.length; i++) {\n\t\tcodeUnits[i] = str.charCodeAt(i);\n\t}\n\tlet binary = '';\n\tconst uint8array = new Uint8Array(codeUnits.buffer);\n\tfor (let i = 0; i < uint8array.length; i++) {\n\t\tbinary += String.fromCharCode(uint8array[i]);\n\t}\n\treturn binary;\n}\n\n/**\n * Version of the global `btoa` function that handles multi-byte characters instead\n * of throwing an exception.\n */\nexport function multibyteAwareBtoa(str: string): string {\n\treturn btoa(toBinary(str));\n}\n\ntype ModifierKey = 'alt' | 'ctrl' | 'shift' | 'meta';\n\nexport interface IModifierKeyStatus {\n\taltKey: boolean;\n\tshiftKey: boolean;\n\tctrlKey: boolean;\n\tmetaKey: boolean;\n\tlastKeyPressed?: ModifierKey;\n\tlastKeyReleased?: ModifierKey;\n\tevent?: KeyboardEvent;\n}\n\nexport class ModifierKeyEmitter extends event.Emitter<IModifierKeyStatus> {\n\n\tprivate readonly _subscriptions = new DisposableStore();\n\tprivate _keyStatus: IModifierKeyStatus;\n\tprivate static instance: ModifierKeyEmitter;\n\n\tprivate constructor() {\n\t\tsuper();\n\n\t\tthis._keyStatus = {\n\t\t\taltKey: false,\n\t\t\tshiftKey: false,\n\t\t\tctrlKey: false,\n\t\t\tmetaKey: false\n\t\t};\n\n\t\tthis._subscriptions.add(event.Event.runAndSubscribe(onDidRegisterWindow, ({ window, disposables }) => this.registerListeners(window, disposables), { window: mainWindow, disposables: this._subscriptions }));\n\t}\n\n\tprivate registerListeners(window: Window, disposables: DisposableStore): void {\n\t\tdisposables.add(addDisposableListener(window, 'keydown', e => {\n\t\t\tif (e.defaultPrevented) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst event = new StandardKeyboardEvent(e);\n\t\t\t// If Alt-key keydown event is repeated, ignore it #112347\n\t\t\t// Only known to be necessary for Alt-Key at the moment #115810\n\t\t\tif (event.keyCode === KeyCode.Alt && e.repeat) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (e.altKey && !this._keyStatus.altKey) {\n\t\t\t\tthis._keyStatus.lastKeyPressed = 'alt';\n\t\t\t} else if (e.ctrlKey && !this._keyStatus.ctrlKey) {\n\t\t\t\tthis._keyStatus.lastKeyPressed = 'ctrl';\n\t\t\t} else if (e.metaKey && !this._keyStatus.metaKey) {\n\t\t\t\tthis._keyStatus.lastKeyPressed = 'meta';\n\t\t\t} else if (e.shiftKey && !this._keyStatus.shiftKey) {\n\t\t\t\tthis._keyStatus.lastKeyPressed = 'shift';\n\t\t\t} else if (event.keyCode !== KeyCode.Alt) {\n\t\t\t\tthis._keyStatus.lastKeyPressed = undefined;\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._keyStatus.altKey = e.altKey;\n\t\t\tthis._keyStatus.ctrlKey = e.ctrlKey;\n\t\t\tthis._keyStatus.metaKey = e.metaKey;\n\t\t\tthis._keyStatus.shiftKey = e.shiftKey;\n\n\t\t\tif (this._keyStatus.lastKeyPressed) {\n\t\t\t\tthis._keyStatus.event = e;\n\t\t\t\tthis.fire(this._keyStatus);\n\t\t\t}\n\t\t}, true));\n\n\t\tdisposables.add(addDisposableListener(window, 'keyup', e => {\n\t\t\tif (e.defaultPrevented) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!e.altKey && this._keyStatus.altKey) {\n\t\t\t\tthis._keyStatus.lastKeyReleased = 'alt';\n\t\t\t} else if (!e.ctrlKey && this._keyStatus.ctrlKey) {\n\t\t\t\tthis._keyStatus.lastKeyReleased = 'ctrl';\n\t\t\t} else if (!e.metaKey && this._keyStatus.metaKey) {\n\t\t\t\tthis._keyStatus.lastKeyReleased = 'meta';\n\t\t\t} else if (!e.shiftKey && this._keyStatus.shiftKey) {\n\t\t\t\tthis._keyStatus.lastKeyReleased = 'shift';\n\t\t\t} else {\n\t\t\t\tthis._keyStatus.lastKeyReleased = undefined;\n\t\t\t}\n\n\t\t\tif (this._keyStatus.lastKeyPressed !== this._keyStatus.lastKeyReleased) {\n\t\t\t\tthis._keyStatus.lastKeyPressed = undefined;\n\t\t\t}\n\n\t\t\tthis._keyStatus.altKey = e.altKey;\n\t\t\tthis._keyStatus.ctrlKey = e.ctrlKey;\n\t\t\tthis._keyStatus.metaKey = e.metaKey;\n\t\t\tthis._keyStatus.shiftKey = e.shiftKey;\n\n\t\t\tif (this._keyStatus.lastKeyReleased) {\n\t\t\t\tthis._keyStatus.event = e;\n\t\t\t\tthis.fire(this._keyStatus);\n\t\t\t}\n\t\t}, true));\n\n\t\tdisposables.add(addDisposableListener(window.document.body, 'mousedown', () => {\n\t\t\tthis._keyStatus.lastKeyPressed = undefined;\n\t\t}, true));\n\n\t\tdisposables.add(addDisposableListener(window.document.body, 'mouseup', () => {\n\t\t\tthis._keyStatus.lastKeyPressed = undefined;\n\t\t}, true));\n\n\t\tdisposables.add(addDisposableListener(window.document.body, 'mousemove', e => {\n\t\t\tif (e.buttons) {\n\t\t\t\tthis._keyStatus.lastKeyPressed = undefined;\n\t\t\t}\n\t\t}, true));\n\n\t\tdisposables.add(addDisposableListener(window, 'blur', () => {\n\t\t\tthis.resetKeyStatus();\n\t\t}));\n\t}\n\n\tget keyStatus(): IModifierKeyStatus {\n\t\treturn this._keyStatus;\n\t}\n\n\tget isModifierPressed(): boolean {\n\t\treturn this._keyStatus.altKey || this._keyStatus.ctrlKey || this._keyStatus.metaKey || this._keyStatus.shiftKey;\n\t}\n\n\t/**\n\t * Allows to explicitly reset the key status based on more knowledge (#109062)\n\t */\n\tresetKeyStatus(): void {\n\t\tthis.doResetKeyStatus();\n\t\tthis.fire(this._keyStatus);\n\t}\n\n\tprivate doResetKeyStatus(): void {\n\t\tthis._keyStatus = {\n\t\t\taltKey: false,\n\t\t\tshiftKey: false,\n\t\t\tctrlKey: false,\n\t\t\tmetaKey: false\n\t\t};\n\t}\n\n\tstatic getInstance() {\n\t\tif (!ModifierKeyEmitter.instance) {\n\t\t\tModifierKeyEmitter.instance = new ModifierKeyEmitter();\n\t\t}\n\n\t\treturn ModifierKeyEmitter.instance;\n\t}\n\n\toverride dispose() {\n\t\tsuper.dispose();\n\t\tthis._subscriptions.dispose();\n\t}\n}\n\nexport function getCookieValue(name: string): string | undefined {\n\tconst match = document.cookie.match('(^|[^;]+)\\\\s*' + name + '\\\\s*=\\\\s*([^;]+)'); // See https://stackoverflow.com/a/25490531\n\n\treturn match ? match.pop() : undefined;\n}\n\nexport interface IDragAndDropObserverCallbacks {\n\treadonly onDragEnter?: (e: DragEvent) => void;\n\treadonly onDragLeave?: (e: DragEvent) => void;\n\treadonly onDrop?: (e: DragEvent) => void;\n\treadonly onDragEnd?: (e: DragEvent) => void;\n\treadonly onDragStart?: (e: DragEvent) => void;\n\treadonly onDrag?: (e: DragEvent) => void;\n\treadonly onDragOver?: (e: DragEvent, dragDuration: number) => void;\n}\n\nexport class DragAndDropObserver extends Disposable {\n\n\t// A helper to fix issues with repeated DRAG_ENTER / DRAG_LEAVE\n\t// calls see https://github.com/microsoft/vscode/issues/14470\n\t// when the element has child elements where the events are fired\n\t// repeadedly.\n\tprivate counter: number = 0;\n\n\t// Allows to measure the duration of the drag operation.\n\tprivate dragStartTime = 0;\n\n\tconstructor(private readonly element: HTMLElement, private readonly callbacks: IDragAndDropObserverCallbacks) {\n\t\tsuper();\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\t\tif (this.callbacks.onDragStart) {\n\t\t\tthis._register(addDisposableListener(this.element, EventType.DRAG_START, (e: DragEvent) => {\n\t\t\t\tthis.callbacks.onDragStart?.(e);\n\t\t\t}));\n\t\t}\n\n\t\tif (this.callbacks.onDrag) {\n\t\t\tthis._register(addDisposableListener(this.element, EventType.DRAG, (e: DragEvent) => {\n\t\t\t\tthis.callbacks.onDrag?.(e);\n\t\t\t}));\n\t\t}\n\n\t\tthis._register(addDisposableListener(this.element, EventType.DRAG_ENTER, (e: DragEvent) => {\n\t\t\tthis.counter++;\n\t\t\tthis.dragStartTime = e.timeStamp;\n\n\t\t\tthis.callbacks.onDragEnter?.(e);\n\t\t}));\n\n\t\tthis._register(addDisposableListener(this.element, EventType.DRAG_OVER, (e: DragEvent) => {\n\t\t\te.preventDefault(); // needed so that the drop event fires (https://stackoverflow.com/questions/21339924/drop-event-not-firing-in-chrome)\n\n\t\t\tthis.callbacks.onDragOver?.(e, e.timeStamp - this.dragStartTime);\n\t\t}));\n\n\t\tthis._register(addDisposableListener(this.element, EventType.DRAG_LEAVE, (e: DragEvent) => {\n\t\t\tthis.counter--;\n\n\t\t\tif (this.counter === 0) {\n\t\t\t\tthis.dragStartTime = 0;\n\n\t\t\t\tthis.callbacks.onDragLeave?.(e);\n\t\t\t}\n\t\t}));\n\n\t\tthis._register(addDisposableListener(this.element, EventType.DRAG_END, (e: DragEvent) => {\n\t\t\tthis.counter = 0;\n\t\t\tthis.dragStartTime = 0;\n\n\t\t\tthis.callbacks.onDragEnd?.(e);\n\t\t}));\n\n\t\tthis._register(addDisposableListener(this.element, EventType.DROP, (e: DragEvent) => {\n\t\t\tthis.counter = 0;\n\t\t\tthis.dragStartTime = 0;\n\n\t\t\tthis.callbacks.onDrop?.(e);\n\t\t}));\n\t}\n}\n\ntype HTMLElementAttributeKeys<T> = Partial<{ [K in keyof T]: T[K] extends Function ? never : T[K] extends object ? HTMLElementAttributeKeys<T[K]> : T[K] }>;\ntype ElementAttributes<T> = HTMLElementAttributeKeys<T> & Record<string, any>;\ntype RemoveHTMLElement<T> = T extends HTMLElement ? never : T;\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;\ntype ArrayToObj<T extends readonly any[]> = UnionToIntersection<RemoveHTMLElement<T[number]>>;\ntype HHTMLElementTagNameMap = HTMLElementTagNameMap & { '': HTMLDivElement };\n\ntype TagToElement<T> = T extends `${infer TStart}#${string}`\n\t? TStart extends keyof HHTMLElementTagNameMap\n\t? HHTMLElementTagNameMap[TStart]\n\t: HTMLElement\n\t: T extends `${infer TStart}.${string}`\n\t? TStart extends keyof HHTMLElementTagNameMap\n\t? HHTMLElementTagNameMap[TStart]\n\t: HTMLElement\n\t: T extends keyof HTMLElementTagNameMap\n\t? HTMLElementTagNameMap[T]\n\t: HTMLElement;\n\ntype TagToElementAndId<TTag> = TTag extends `${infer TTag}@${infer TId}`\n\t? { element: TagToElement<TTag>; id: TId }\n\t: { element: TagToElement<TTag>; id: 'root' };\n\ntype TagToRecord<TTag> = TagToElementAndId<TTag> extends { element: infer TElement; id: infer TId }\n\t? Record<(TId extends string ? TId : never) | 'root', TElement>\n\t: never;\n\ntype Child = HTMLElement | string | Record<string, HTMLElement>;\n\nconst H_REGEX = /(?<tag>[\\w\\-]+)?(?:#(?<id>[\\w\\-]+))?(?<class>(?:\\.(?:[\\w\\-]+))*)(?:@(?<name>(?:[\\w\\_])+))?/;\n\n/**\n * A helper function to create nested dom nodes.\n *\n *\n * ```ts\n * const elements = h('div.code-view', [\n * \th('div.title@title'),\n * \th('div.container', [\n * \t\th('div.gutter@gutterDiv'),\n * \t\th('div@editor'),\n * \t]),\n * ]);\n * const editor = createEditor(elements.editor);\n * ```\n*/\nexport function h<TTag extends string>\n\t(tag: TTag):\n\tTagToRecord<TTag> extends infer Y ? { [TKey in keyof Y]: Y[TKey] } : never;\n\nexport function h<TTag extends string, T extends Child[]>\n\t(tag: TTag, children: [...T]):\n\t(ArrayToObj<T> & TagToRecord<TTag>) extends infer Y ? { [TKey in keyof Y]: Y[TKey] } : never;\n\nexport function h<TTag extends string>\n\t(tag: TTag, attributes: Partial<ElementAttributes<TagToElement<TTag>>>):\n\tTagToRecord<TTag> extends infer Y ? { [TKey in keyof Y]: Y[TKey] } : never;\n\nexport function h<TTag extends string, T extends Child[]>\n\t(tag: TTag, attributes: Partial<ElementAttributes<TagToElement<TTag>>>, children: [...T]):\n\t(ArrayToObj<T> & TagToRecord<TTag>) extends infer Y ? { [TKey in keyof Y]: Y[TKey] } : never;\n\nexport function h(tag: string, ...args: [] | [attributes: { $: string } & Partial<ElementAttributes<HTMLElement>> | Record<string, any>, children?: any[]] | [children: any[]]): Record<string, HTMLElement> {\n\tlet attributes: { $?: string } & Partial<ElementAttributes<HTMLElement>>;\n\tlet children: (Record<string, HTMLElement> | HTMLElement)[] | undefined;\n\n\tif (Array.isArray(args[0])) {\n\t\tattributes = {};\n\t\tchildren = args[0];\n\t} else {\n\t\tattributes = args[0] as any || {};\n\t\tchildren = args[1];\n\t}\n\n\tconst match = H_REGEX.exec(tag);\n\n\tif (!match || !match.groups) {\n\t\tthrow new Error('Bad use of h');\n\t}\n\n\tconst tagName = match.groups['tag'] || 'div';\n\tconst el = document.createElement(tagName);\n\n\tif (match.groups['id']) {\n\t\tel.id = match.groups['id'];\n\t}\n\n\tconst classNames = [];\n\tif (match.groups['class']) {\n\t\tfor (const className of match.groups['class'].split('.')) {\n\t\t\tif (className !== '') {\n\t\t\t\tclassNames.push(className);\n\t\t\t}\n\t\t}\n\t}\n\tif (attributes.className !== undefined) {\n\t\tfor (const className of attributes.className.split('.')) {\n\t\t\tif (className !== '') {\n\t\t\t\tclassNames.push(className);\n\t\t\t}\n\t\t}\n\t}\n\tif (classNames.length > 0) {\n\t\tel.className = classNames.join(' ');\n\t}\n\n\tconst result: Record<string, HTMLElement> = {};\n\n\tif (match.groups['name']) {\n\t\tresult[match.groups['name']] = el;\n\t}\n\n\tif (children) {\n\t\tfor (const c of children) {\n\t\t\tif (isHTMLElement(c)) {\n\t\t\t\tel.appendChild(c);\n\t\t\t} else if (typeof c === 'string') {\n\t\t\t\tel.append(c);\n\t\t\t} else if ('root' in c) {\n\t\t\t\tObject.assign(result, c);\n\t\t\t\tel.appendChild(c.root);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (const [key, value] of Object.entries(attributes)) {\n\t\tif (key === 'className') {\n\t\t\tcontinue;\n\t\t} else if (key === 'style') {\n\t\t\tfor (const [cssKey, cssValue] of Object.entries(value)) {\n\t\t\t\tel.style.setProperty(\n\t\t\t\t\tcamelCaseToHyphenCase(cssKey),\n\t\t\t\t\ttypeof cssValue === 'number' ? cssValue + 'px' : '' + cssValue\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (key === 'tabIndex') {\n\t\t\tel.tabIndex = value;\n\t\t} else {\n\t\t\tel.setAttribute(camelCaseToHyphenCase(key), value.toString());\n\t\t}\n\t}\n\n\tresult['root'] = el;\n\n\treturn result;\n}\n\nexport function svgElem<TTag extends string>\n\t(tag: TTag):\n\tTagToRecord<TTag> extends infer Y ? { [TKey in keyof Y]: Y[TKey] } : never;\n\nexport function svgElem<TTag extends string, T extends Child[]>\n\t(tag: TTag, children: [...T]):\n\t(ArrayToObj<T> & TagToRecord<TTag>) extends infer Y ? { [TKey in keyof Y]: Y[TKey] } : never;\n\nexport function svgElem<TTag extends string>\n\t(tag: TTag, attributes: Partial<ElementAttributes<TagToElement<TTag>>>):\n\tTagToRecord<TTag> extends infer Y ? { [TKey in keyof Y]: Y[TKey] } : never;\n\nexport function svgElem<TTag extends string, T extends Child[]>\n\t(tag: TTag, attributes: Partial<ElementAttributes<TagToElement<TTag>>>, children: [...T]):\n\t(ArrayToObj<T> & TagToRecord<TTag>) extends infer Y ? { [TKey in keyof Y]: Y[TKey] } : never;\n\nexport function svgElem(tag: string, ...args: [] | [attributes: { $: string } & Partial<ElementAttributes<HTMLElement>> | Record<string, any>, children?: any[]] | [children: any[]]): Record<string, HTMLElement> {\n\tlet attributes: { $?: string } & Partial<ElementAttributes<HTMLElement>>;\n\tlet children: (Record<string, HTMLElement> | HTMLElement)[] | undefined;\n\n\tif (Array.isArray(args[0])) {\n\t\tattributes = {};\n\t\tchildren = args[0];\n\t} else {\n\t\tattributes = args[0] as any || {};\n\t\tchildren = args[1];\n\t}\n\n\tconst match = H_REGEX.exec(tag);\n\n\tif (!match || !match.groups) {\n\t\tthrow new Error('Bad use of h');\n\t}\n\n\tconst tagName = match.groups['tag'] || 'div';\n\tconst el = document.createElementNS('http://www.w3.org/2000/svg', tagName) as any as HTMLElement;\n\n\tif (match.groups['id']) {\n\t\tel.id = match.groups['id'];\n\t}\n\n\tconst classNames = [];\n\tif (match.groups['class']) {\n\t\tfor (const className of match.groups['class'].split('.')) {\n\t\t\tif (className !== '') {\n\t\t\t\tclassNames.push(className);\n\t\t\t}\n\t\t}\n\t}\n\tif (attributes.className !== undefined) {\n\t\tfor (const className of attributes.className.split('.')) {\n\t\t\tif (className !== '') {\n\t\t\t\tclassNames.push(className);\n\t\t\t}\n\t\t}\n\t}\n\tif (classNames.length > 0) {\n\t\tel.className = classNames.join(' ');\n\t}\n\n\tconst result: Record<string, HTMLElement> = {};\n\n\tif (match.groups['name']) {\n\t\tresult[match.groups['name']] = el;\n\t}\n\n\tif (children) {\n\t\tfor (const c of children) {\n\t\t\tif (isHTMLElement(c)) {\n\t\t\t\tel.appendChild(c);\n\t\t\t} else if (typeof c === 'string') {\n\t\t\t\tel.append(c);\n\t\t\t} else if ('root' in c) {\n\t\t\t\tObject.assign(result, c);\n\t\t\t\tel.appendChild(c.root);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (const [key, value] of Object.entries(attributes)) {\n\t\tif (key === 'className') {\n\t\t\tcontinue;\n\t\t} else if (key === 'style') {\n\t\t\tfor (const [cssKey, cssValue] of Object.entries(value)) {\n\t\t\t\tel.style.setProperty(\n\t\t\t\t\tcamelCaseToHyphenCase(cssKey),\n\t\t\t\t\ttypeof cssValue === 'number' ? cssValue + 'px' : '' + cssValue\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (key === 'tabIndex') {\n\t\t\tel.tabIndex = value;\n\t\t} else {\n\t\t\tel.setAttribute(camelCaseToHyphenCase(key), value.toString());\n\t\t}\n\t}\n\n\tresult['root'] = el;\n\n\treturn result;\n}\n\nfunction camelCaseToHyphenCase(str: string) {\n\treturn str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n}\n\nexport function copyAttributes(from: Element, to: Element, filter?: string[]): void {\n\tfor (const { name, value } of from.attributes) {\n\t\tif (!filter || filter.includes(name)) {\n\t\t\tto.setAttribute(name, value);\n\t\t}\n\t}\n}\n\nfunction copyAttribute(from: Element, to: Element, name: string): void {\n\tconst value = from.getAttribute(name);\n\tif (value) {\n\t\tto.setAttribute(name, value);\n\t} else {\n\t\tto.removeAttribute(name);\n\t}\n}\n\nexport function trackAttributes(from: Element, to: Element, filter?: string[]): IDisposable {\n\tcopyAttributes(from, to, filter);\n\n\tconst disposables = new DisposableStore();\n\n\tdisposables.add(sharedMutationObserver.observe(from, disposables, { attributes: true, attributeFilter: filter })(mutations => {\n\t\tfor (const mutation of mutations) {\n\t\t\tif (mutation.type === 'attributes' && mutation.attributeName) {\n\t\t\t\tcopyAttribute(from, to, mutation.attributeName);\n\t\t\t}\n\t\t}\n\t}));\n\n\treturn disposables;\n}\n\n/**\n * Helper for calculating the \"safe triangle\" occluded by hovers to avoid early dismissal.\n * @see https://www.smashingmagazine.com/2023/08/better-context-menus-safe-triangles/ for example\n */\nexport class SafeTriangle {\n\t// 4 triangles, 2 points (x, y) stored for each\n\tprivate triangles: number[] = [];\n\n\tconstructor(\n\t\tprivate readonly originX: number,\n\t\tprivate readonly originY: number,\n\t\ttarget: HTMLElement\n\t) {\n\t\tconst { top, left, right, bottom } = target.getBoundingClientRect();\n\t\tconst t = this.triangles;\n\t\tlet i = 0;\n\n\t\tt[i++] = left;\n\t\tt[i++] = top;\n\t\tt[i++] = right;\n\t\tt[i++] = top;\n\n\t\tt[i++] = left;\n\t\tt[i++] = top;\n\t\tt[i++] = left;\n\t\tt[i++] = bottom;\n\n\t\tt[i++] = right;\n\t\tt[i++] = top;\n\t\tt[i++] = right;\n\t\tt[i++] = bottom;\n\n\t\tt[i++] = left;\n\t\tt[i++] = bottom;\n\t\tt[i++] = right;\n\t\tt[i++] = bottom;\n\t}\n\n\tpublic contains(x: number, y: number) {\n\t\tconst { triangles, originX, originY } = this;\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tif (isPointWithinTriangle(x, y, originX, originY, triangles[2 * i], triangles[2 * i + 1], triangles[2 * i + 2], triangles[2 * i + 3])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport class FastDomNode<T extends HTMLElement> {\n\n\tprivate _maxWidth: string = '';\n\tprivate _width: string = '';\n\tprivate _height: string = '';\n\tprivate _top: string = '';\n\tprivate _left: string = '';\n\tprivate _bottom: string = '';\n\tprivate _right: string = '';\n\tprivate _paddingTop: string = '';\n\tprivate _paddingLeft: string = '';\n\tprivate _paddingBottom: string = '';\n\tprivate _paddingRight: string = '';\n\tprivate _fontFamily: string = '';\n\tprivate _fontWeight: string = '';\n\tprivate _fontSize: string = '';\n\tprivate _fontStyle: string = '';\n\tprivate _fontFeatureSettings: string = '';\n\tprivate _fontVariationSettings: string = '';\n\tprivate _textDecoration: string = '';\n\tprivate _lineHeight: string = '';\n\tprivate _letterSpacing: string = '';\n\tprivate _className: string = '';\n\tprivate _display: string = '';\n\tprivate _position: string = '';\n\tprivate _visibility: string = '';\n\tprivate _color: string = '';\n\tprivate _backgroundColor: string = '';\n\tprivate _layerHint: boolean = false;\n\tprivate _contain: 'none' | 'strict' | 'content' | 'size' | 'layout' | 'style' | 'paint' = 'none';\n\tprivate _boxShadow: string = '';\n\n\tconstructor(\n\t\tpublic readonly domNode: T\n\t) { }\n\n\tpublic setMaxWidth(_maxWidth: number | string): void {\n\t\tconst maxWidth = numberAsPixels(_maxWidth);\n\t\tif (this._maxWidth === maxWidth) {\n\t\t\treturn;\n\t\t}\n\t\tthis._maxWidth = maxWidth;\n\t\tthis.domNode.style.maxWidth = this._maxWidth;\n\t}\n\n\tpublic setWidth(_width: number | string): void {\n\t\tconst width = numberAsPixels(_width);\n\t\tif (this._width === width) {\n\t\t\treturn;\n\t\t}\n\t\tthis._width = width;\n\t\tthis.domNode.style.width = this._width;\n\t}\n\n\tpublic setHeight(_height: number | string): void {\n\t\tconst height = numberAsPixels(_height);\n\t\tif (this._height === height) {\n\t\t\treturn;\n\t\t}\n\t\tthis._height = height;\n\t\tthis.domNode.style.height = this._height;\n\t}\n\n\tpublic setTop(_top: number | string): void {\n\t\tconst top = numberAsPixels(_top);\n\t\tif (this._top === top) {\n\t\t\treturn;\n\t\t}\n\t\tthis._top = top;\n\t\tthis.domNode.style.top = this._top;\n\t}\n\n\tpublic setLeft(_left: number | string): void {\n\t\tconst left = numberAsPixels(_left);\n\t\tif (this._left === left) {\n\t\t\treturn;\n\t\t}\n\t\tthis._left = left;\n\t\tthis.domNode.style.left = this._left;\n\t}\n\n\tpublic setBottom(_bottom: number | string): void {\n\t\tconst bottom = numberAsPixels(_bottom);\n\t\tif (this._bottom === bottom) {\n\t\t\treturn;\n\t\t}\n\t\tthis._bottom = bottom;\n\t\tthis.domNode.style.bottom = this._bottom;\n\t}\n\n\tpublic setRight(_right: number | string): void {\n\t\tconst right = numberAsPixels(_right);\n\t\tif (this._right === right) {\n\t\t\treturn;\n\t\t}\n\t\tthis._right = right;\n\t\tthis.domNode.style.right = this._right;\n\t}\n\n\tpublic setPaddingTop(_paddingTop: number | string): void {\n\t\tconst paddingTop = numberAsPixels(_paddingTop);\n\t\tif (this._paddingTop === paddingTop) {\n\t\t\treturn;\n\t\t}\n\t\tthis._paddingTop = paddingTop;\n\t\tthis.domNode.style.paddingTop = this._paddingTop;\n\t}\n\n\tpublic setPaddingLeft(_paddingLeft: number | string): void {\n\t\tconst paddingLeft = numberAsPixels(_paddingLeft);\n\t\tif (this._paddingLeft === paddingLeft) {\n\t\t\treturn;\n\t\t}\n\t\tthis._paddingLeft = paddingLeft;\n\t\tthis.domNode.style.paddingLeft = this._paddingLeft;\n\t}\n\n\tpublic setPaddingBottom(_paddingBottom: number | string): void {\n\t\tconst paddingBottom = numberAsPixels(_paddingBottom);\n\t\tif (this._paddingBottom === paddingBottom) {\n\t\t\treturn;\n\t\t}\n\t\tthis._paddingBottom = paddingBottom;\n\t\tthis.domNode.style.paddingBottom = this._paddingBottom;\n\t}\n\n\tpublic setPaddingRight(_paddingRight: number | string): void {\n\t\tconst paddingRight = numberAsPixels(_paddingRight);\n\t\tif (this._paddingRight === paddingRight) {\n\t\t\treturn;\n\t\t}\n\t\tthis._paddingRight = paddingRight;\n\t\tthis.domNode.style.paddingRight = this._paddingRight;\n\t}\n\n\tpublic setFontFamily(fontFamily: string): void {\n\t\tif (this._fontFamily === fontFamily) {\n\t\t\treturn;\n\t\t}\n\t\tthis._fontFamily = fontFamily;\n\t\tthis.domNode.style.fontFamily = this._fontFamily;\n\t}\n\n\tpublic setFontWeight(fontWeight: string): void {\n\t\tif (this._fontWeight === fontWeight) {\n\t\t\treturn;\n\t\t}\n\t\tthis._fontWeight = fontWeight;\n\t\tthis.domNode.style.fontWeight = this._fontWeight;\n\t}\n\n\tpublic setFontSize(_fontSize: number | string): void {\n\t\tconst fontSize = numberAsPixels(_fontSize);\n\t\tif (this._fontSize === fontSize) {\n\t\t\treturn;\n\t\t}\n\t\tthis._fontSize = fontSize;\n\t\tthis.domNode.style.fontSize = this._fontSize;\n\t}\n\n\tpublic setFontStyle(fontStyle: string): void {\n\t\tif (this._fontStyle === fontStyle) {\n\t\t\treturn;\n\t\t}\n\t\tthis._fontStyle = fontStyle;\n\t\tthis.domNode.style.fontStyle = this._fontStyle;\n\t}\n\n\tpublic setFontFeatureSettings(fontFeatureSettings: string): void {\n\t\tif (this._fontFeatureSettings === fontFeatureSettings) {\n\t\t\treturn;\n\t\t}\n\t\tthis._fontFeatureSettings = fontFeatureSettings;\n\t\tthis.domNode.style.fontFeatureSettings = this._fontFeatureSettings;\n\t}\n\n\tpublic setFontVariationSettings(fontVariationSettings: string): void {\n\t\tif (this._fontVariationSettings === fontVariationSettings) {\n\t\t\treturn;\n\t\t}\n\t\tthis._fontVariationSettings = fontVariationSettings;\n\t\tthis.domNode.style.fontVariationSettings = this._fontVariationSettings;\n\t}\n\n\tpublic setTextDecoration(textDecoration: string): void {\n\t\tif (this._textDecoration === textDecoration) {\n\t\t\treturn;\n\t\t}\n\t\tthis._textDecoration = textDecoration;\n\t\tthis.domNode.style.textDecoration = this._textDecoration;\n\t}\n\n\tpublic setLineHeight(_lineHeight: number | string): void {\n\t\tconst lineHeight = numberAsPixels(_lineHeight);\n\t\tif (this._lineHeight === lineHeight) {\n\t\t\treturn;\n\t\t}\n\t\tthis._lineHeight = lineHeight;\n\t\tthis.domNode.style.lineHeight = this._lineHeight;\n\t}\n\n\tpublic setLetterSpacing(_letterSpacing: number | string): void {\n\t\tconst letterSpacing = numberAsPixels(_letterSpacing);\n\t\tif (this._letterSpacing === letterSpacing) {\n\t\t\treturn;\n\t\t}\n\t\tthis._letterSpacing = letterSpacing;\n\t\tthis.domNode.style.letterSpacing = this._letterSpacing;\n\t}\n\n\tpublic setClassName(className: string): void {\n\t\tif (this._className === className) {\n\t\t\treturn;\n\t\t}\n\t\tthis._className = className;\n\t\tthis.domNode.className = this._className;\n\t}\n\n\tpublic toggleClassName(className: string, shouldHaveIt?: boolean): void {\n\t\tthis.domNode.classList.toggle(className, shouldHaveIt);\n\t\tthis._className = this.domNode.className;\n\t}\n\n\tpublic setDisplay(display: string): void {\n\t\tif (this._display === display) {\n\t\t\treturn;\n\t\t}\n\t\tthis._display = display;\n\t\tthis.domNode.style.display = this._display;\n\t}\n\n\tpublic setPosition(position: string): void {\n\t\tif (this._position === position) {\n\t\t\treturn;\n\t\t}\n\t\tthis._position = position;\n\t\tthis.domNode.style.position = this._position;\n\t}\n\n\tpublic setVisibility(visibility: string): void {\n\t\tif (this._visibility === visibility) {\n\t\t\treturn;\n\t\t}\n\t\tthis._visibility = visibility;\n\t\tthis.domNode.style.visibility = this._visibility;\n\t}\n\n\tpublic setColor(color: string): void {\n\t\tif (this._color === color) {\n\t\t\treturn;\n\t\t}\n\t\tthis._color = color;\n\t\tthis.domNode.style.color = this._color;\n\t}\n\n\tpublic setBackgroundColor(backgroundColor: string): void {\n\t\tif (this._backgroundColor === backgroundColor) {\n\t\t\treturn;\n\t\t}\n\t\tthis._backgroundColor = backgroundColor;\n\t\tthis.domNode.style.backgroundColor = this._backgroundColor;\n\t}\n\n\tpublic setLayerHinting(layerHint: boolean): void {\n\t\tif (this._layerHint === layerHint) {\n\t\t\treturn;\n\t\t}\n\t\tthis._layerHint = layerHint;\n\t\tthis.domNode.style.transform = this._layerHint ? 'translate3d(0px, 0px, 0px)' : '';\n\t}\n\n\tpublic setBoxShadow(boxShadow: string): void {\n\t\tif (this._boxShadow === boxShadow) {\n\t\t\treturn;\n\t\t}\n\t\tthis._boxShadow = boxShadow;\n\t\tthis.domNode.style.boxShadow = boxShadow;\n\t}\n\n\tpublic setContain(contain: 'none' | 'strict' | 'content' | 'size' | 'layout' | 'style' | 'paint'): void {\n\t\tif (this._contain === contain) {\n\t\t\treturn;\n\t\t}\n\t\tthis._contain = contain;\n\t\t(<any>this.domNode.style).contain = this._contain;\n\t}\n\n\tpublic setAttribute(name: string, value: string): void {\n\t\tthis.domNode.setAttribute(name, value);\n\t}\n\n\tpublic removeAttribute(name: string): void {\n\t\tthis.domNode.removeAttribute(name);\n\t}\n\n\tpublic appendChild(child: FastDomNode<T>): void {\n\t\tthis.domNode.appendChild(child.domNode);\n\t}\n\n\tpublic removeChild(child: FastDomNode<T>): void {\n\t\tthis.domNode.removeChild(child.domNode);\n\t}\n}\n\nfunction numberAsPixels(value: number | string): string {\n\treturn (typeof value === 'number' ? `${value}px` : value);\n}\n\nexport function createFastDomNode<T extends HTMLElement>(domNode: T): FastDomNode<T> {\n\treturn new FastDomNode(domNode);\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as dom from 'vs/base/browser/dom';\nimport { DisposableStore, IDisposable, toDisposable } from 'vs/base/common/lifecycle';\n\nexport interface IPointerMoveCallback {\n\t(event: PointerEvent): void;\n}\n\nexport interface IOnStopCallback {\n\t(browserEvent?: PointerEvent | KeyboardEvent): void;\n}\n\nexport class GlobalPointerMoveMonitor implements IDisposable {\n\n\tprivate readonly _hooks = new DisposableStore();\n\tprivate _pointerMoveCallback: IPointerMoveCallback | null = null;\n\tprivate _onStopCallback: IOnStopCallback | null = null;\n\n\tpublic dispose(): void {\n\t\tthis.stopMonitoring(false);\n\t\tthis._hooks.dispose();\n\t}\n\n\tpublic stopMonitoring(invokeStopCallback: boolean, browserEvent?: PointerEvent | KeyboardEvent): void {\n\t\tif (!this.isMonitoring()) {\n\t\t\t// Not monitoring\n\t\t\treturn;\n\t\t}\n\n\t\t// Unhook\n\t\tthis._hooks.clear();\n\t\tthis._pointerMoveCallback = null;\n\t\tconst onStopCallback = this._onStopCallback;\n\t\tthis._onStopCallback = null;\n\n\t\tif (invokeStopCallback && onStopCallback) {\n\t\t\tonStopCallback(browserEvent);\n\t\t}\n\t}\n\n\tpublic isMonitoring(): boolean {\n\t\treturn !!this._pointerMoveCallback;\n\t}\n\n\tpublic startMonitoring(\n\t\tinitialElement: Element,\n\t\tpointerId: number,\n\t\tinitialButtons: number,\n\t\tpointerMoveCallback: IPointerMoveCallback,\n\t\tonStopCallback: IOnStopCallback\n\t): void {\n\t\tif (this.isMonitoring()) {\n\t\t\tthis.stopMonitoring(false);\n\t\t}\n\t\tthis._pointerMoveCallback = pointerMoveCallback;\n\t\tthis._onStopCallback = onStopCallback;\n\n\t\tlet eventSource: Element | Window = initialElement;\n\n\t\ttry {\n\t\t\tinitialElement.setPointerCapture(pointerId);\n\t\t\tthis._hooks.add(toDisposable(() => {\n\t\t\t\ttry {\n\t\t\t\t\tinitialElement.releasePointerCapture(pointerId);\n\t\t\t\t} catch (err) {\n\t\t\t\t\t// See https://github.com/microsoft/vscode/issues/161731\n\t\t\t\t\t//\n\t\t\t\t\t// `releasePointerCapture` sometimes fails when being invoked with the exception:\n\t\t\t\t\t//     DOMException: Failed to execute 'releasePointerCapture' on 'Element':\n\t\t\t\t\t//     No active pointer with the given id is found.\n\t\t\t\t\t//\n\t\t\t\t\t// There's no need to do anything in case of failure\n\t\t\t\t}\n\t\t\t}));\n\t\t} catch (err) {\n\t\t\t// See https://github.com/microsoft/vscode/issues/144584\n\t\t\t// See https://github.com/microsoft/vscode/issues/146947\n\t\t\t// `setPointerCapture` sometimes fails when being invoked\n\t\t\t// from a `mousedown` listener on macOS and Windows\n\t\t\t// and it always fails on Linux with the exception:\n\t\t\t//     DOMException: Failed to execute 'setPointerCapture' on 'Element':\n\t\t\t//     No active pointer with the given id is found.\n\t\t\t// In case of failure, we bind the listeners on the window\n\t\t\teventSource = dom.getWindow(initialElement);\n\t\t}\n\n\t\tthis._hooks.add(dom.addDisposableListener(\n\t\t\teventSource,\n\t\t\tdom.EventType.POINTER_MOVE,\n\t\t\t(e) => {\n\t\t\t\tif (e.buttons !== initialButtons) {\n\t\t\t\t\t// Buttons state has changed in the meantime\n\t\t\t\t\tthis.stopMonitoring(true);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\te.preventDefault();\n\t\t\t\tthis._pointerMoveCallback!(e);\n\t\t\t}\n\t\t));\n\n\t\tthis._hooks.add(dom.addDisposableListener(\n\t\t\teventSource,\n\t\t\tdom.EventType.POINTER_UP,\n\t\t\t(e: PointerEvent) => this.stopMonitoring(true)\n\t\t));\n\t}\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nfunction createDecorator(mapFn: (fn: Function, key: string) => Function): Function {\n\treturn (target: any, key: string, descriptor: any) => {\n\t\tlet fnKey: string | null = null;\n\t\tlet fn: Function | null = null;\n\n\t\tif (typeof descriptor.value === 'function') {\n\t\t\tfnKey = 'value';\n\t\t\tfn = descriptor.value;\n\t\t} else if (typeof descriptor.get === 'function') {\n\t\t\tfnKey = 'get';\n\t\t\tfn = descriptor.get;\n\t\t}\n\n\t\tif (!fn) {\n\t\t\tthrow new Error('not supported');\n\t\t}\n\n\t\tdescriptor[fnKey!] = mapFn(fn, key);\n\t};\n}\n\nexport function memoize(_target: any, key: string, descriptor: any) {\n\tlet fnKey: string | null = null;\n\tlet fn: Function | null = null;\n\n\tif (typeof descriptor.value === 'function') {\n\t\tfnKey = 'value';\n\t\tfn = descriptor.value;\n\n\t\tif (fn!.length !== 0) {\n\t\t\tconsole.warn('Memoize should only be used in functions with zero parameters');\n\t\t}\n\t} else if (typeof descriptor.get === 'function') {\n\t\tfnKey = 'get';\n\t\tfn = descriptor.get;\n\t}\n\n\tif (!fn) {\n\t\tthrow new Error('not supported');\n\t}\n\n\tconst memoizeKey = `$memoize$${key}`;\n\tdescriptor[fnKey!] = function (...args: any[]) {\n\t\tif (!this.hasOwnProperty(memoizeKey)) {\n\t\t\tObject.defineProperty(this, memoizeKey, {\n\t\t\t\tconfigurable: false,\n\t\t\t\tenumerable: false,\n\t\t\t\twritable: false,\n\t\t\t\tvalue: fn.apply(this, args)\n\t\t\t});\n\t\t}\n\n\t\treturn this[memoizeKey];\n\t};\n}\n\nexport interface IDebounceReducer<T> {\n\t(previousValue: T, ...args: any[]): T;\n}\n\nexport function debounce<T>(delay: number, reducer?: IDebounceReducer<T>, initialValueProvider?: () => T): Function {\n\treturn createDecorator((fn, key) => {\n\t\tconst timerKey = `$debounce$${key}`;\n\t\tconst resultKey = `$debounce$result$${key}`;\n\n\t\treturn function (this: any, ...args: any[]) {\n\t\t\tif (!this[resultKey]) {\n\t\t\t\tthis[resultKey] = initialValueProvider ? initialValueProvider() : undefined;\n\t\t\t}\n\n\t\t\tclearTimeout(this[timerKey]);\n\n\t\t\tif (reducer) {\n\t\t\t\tthis[resultKey] = reducer(this[resultKey], ...args);\n\t\t\t\targs = [this[resultKey]];\n\t\t\t}\n\n\t\t\tthis[timerKey] = setTimeout(() => {\n\t\t\t\tfn.apply(this, args);\n\t\t\t\tthis[resultKey] = initialValueProvider ? initialValueProvider() : undefined;\n\t\t\t}, delay);\n\t\t};\n\t});\n}\n\nexport function throttle<T>(delay: number, reducer?: IDebounceReducer<T>, initialValueProvider?: () => T): Function {\n\treturn createDecorator((fn, key) => {\n\t\tconst timerKey = `$throttle$timer$${key}`;\n\t\tconst resultKey = `$throttle$result$${key}`;\n\t\tconst lastRunKey = `$throttle$lastRun$${key}`;\n\t\tconst pendingKey = `$throttle$pending$${key}`;\n\n\t\treturn function (this: any, ...args: any[]) {\n\t\t\tif (!this[resultKey]) {\n\t\t\t\tthis[resultKey] = initialValueProvider ? initialValueProvider() : undefined;\n\t\t\t}\n\t\t\tif (this[lastRunKey] === null || this[lastRunKey] === undefined) {\n\t\t\t\tthis[lastRunKey] = -Number.MAX_VALUE;\n\t\t\t}\n\n\t\t\tif (reducer) {\n\t\t\t\tthis[resultKey] = reducer(this[resultKey], ...args);\n\t\t\t}\n\n\t\t\tif (this[pendingKey]) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst nextTime = this[lastRunKey] + delay;\n\t\t\tif (nextTime <= Date.now()) {\n\t\t\t\tthis[lastRunKey] = Date.now();\n\t\t\t\tfn.apply(this, [this[resultKey]]);\n\t\t\t\tthis[resultKey] = initialValueProvider ? initialValueProvider() : undefined;\n\t\t\t} else {\n\t\t\t\tthis[pendingKey] = true;\n\t\t\t\tthis[timerKey] = setTimeout(() => {\n\t\t\t\t\tthis[pendingKey] = false;\n\t\t\t\t\tthis[lastRunKey] = Date.now();\n\t\t\t\t\tfn.apply(this, [this[resultKey]]);\n\t\t\t\t\tthis[resultKey] = initialValueProvider ? initialValueProvider() : undefined;\n\t\t\t\t}, nextTime - Date.now());\n\t\t\t}\n\t\t};\n\t});\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as DomUtils from 'vs/base/browser/dom';\nimport { mainWindow } from 'vs/base/browser/window';\nimport * as arrays from 'vs/base/common/arrays';\nimport { memoize } from 'vs/base/common/decorators';\nimport { Event as EventUtils } from 'vs/base/common/event';\nimport { Disposable, IDisposable, markAsSingleton, toDisposable } from 'vs/base/common/lifecycle';\nimport { LinkedList } from 'vs/base/common/linkedList';\n\nexport namespace EventType {\n\texport const Tap = '-xterm-gesturetap';\n\texport const Change = '-xterm-gesturechange';\n\texport const Start = '-xterm-gesturestart';\n\texport const End = '-xterm-gesturesend';\n\texport const Contextmenu = '-xterm-gesturecontextmenu';\n}\n\ninterface TouchData {\n\tid: number;\n\tinitialTarget: EventTarget;\n\tinitialTimeStamp: number;\n\tinitialPageX: number;\n\tinitialPageY: number;\n\trollingTimestamps: number[];\n\trollingPageX: number[];\n\trollingPageY: number[];\n}\n\nexport interface GestureEvent extends MouseEvent {\n\tinitialTarget: EventTarget | undefined;\n\ttranslationX: number;\n\ttranslationY: number;\n\tpageX: number;\n\tpageY: number;\n\ttapCount: number;\n}\n\ninterface Touch {\n\tidentifier: number;\n\tscreenX: number;\n\tscreenY: number;\n\tclientX: number;\n\tclientY: number;\n\tpageX: number;\n\tpageY: number;\n\tradiusX: number;\n\tradiusY: number;\n\trotationAngle: number;\n\tforce: number;\n\ttarget: Element;\n}\n\ninterface TouchList {\n\t[i: number]: Touch;\n\tlength: number;\n\titem(index: number): Touch;\n\tidentifiedTouch(id: number): Touch;\n}\n\ninterface TouchEvent extends Event {\n\ttouches: TouchList;\n\ttargetTouches: TouchList;\n\tchangedTouches: TouchList;\n}\n\nexport class Gesture extends Disposable {\n\n\tprivate static readonly SCROLL_FRICTION = -0.005;\n\tprivate static INSTANCE: Gesture;\n\tprivate static readonly HOLD_DELAY = 700;\n\n\tprivate dispatched = false;\n\tprivate readonly targets = new LinkedList<HTMLElement>();\n\tprivate readonly ignoreTargets = new LinkedList<HTMLElement>();\n\tprivate handle: IDisposable | null;\n\n\tprivate readonly activeTouches: { [id: number]: TouchData };\n\n\tprivate _lastSetTapCountTime: number;\n\n\tprivate static readonly CLEAR_TAP_COUNT_TIME = 400; // ms\n\n\n\tprivate constructor() {\n\t\tsuper();\n\n\t\tthis.activeTouches = {};\n\t\tthis.handle = null;\n\t\tthis._lastSetTapCountTime = 0;\n\n\t\tthis._register(EventUtils.runAndSubscribe(DomUtils.onDidRegisterWindow, ({ window, disposables }) => {\n\t\t\tdisposables.add(DomUtils.addDisposableListener(window.document, 'touchstart', (e: TouchEvent) => this.onTouchStart(e), { passive: false }));\n\t\t\tdisposables.add(DomUtils.addDisposableListener(window.document, 'touchend', (e: TouchEvent) => this.onTouchEnd(window, e)));\n\t\t\tdisposables.add(DomUtils.addDisposableListener(window.document, 'touchmove', (e: TouchEvent) => this.onTouchMove(e), { passive: false }));\n\t\t}, { window: mainWindow, disposables: this._store }));\n\t}\n\n\tpublic static addTarget(element: HTMLElement): IDisposable {\n\t\tif (!Gesture.isTouchDevice()) {\n\t\t\treturn Disposable.None;\n\t\t}\n\t\tif (!Gesture.INSTANCE) {\n\t\t\tGesture.INSTANCE = markAsSingleton(new Gesture());\n\t\t}\n\n\t\tconst remove = Gesture.INSTANCE.targets.push(element);\n\t\treturn toDisposable(remove);\n\t}\n\n\tpublic static ignoreTarget(element: HTMLElement): IDisposable {\n\t\tif (!Gesture.isTouchDevice()) {\n\t\t\treturn Disposable.None;\n\t\t}\n\t\tif (!Gesture.INSTANCE) {\n\t\t\tGesture.INSTANCE = markAsSingleton(new Gesture());\n\t\t}\n\n\t\tconst remove = Gesture.INSTANCE.ignoreTargets.push(element);\n\t\treturn toDisposable(remove);\n\t}\n\n\t@memoize\n\tstatic isTouchDevice(): boolean {\n\t\t// `'ontouchstart' in window` always evaluates to true with typescript's modern typings. This causes `window` to be\n\t\t// `never` later in `window.navigator`. That's why we need the explicit `window as Window` cast\n\t\treturn 'ontouchstart' in mainWindow || navigator.maxTouchPoints > 0;\n\t}\n\n\tpublic override dispose(): void {\n\t\tif (this.handle) {\n\t\t\tthis.handle.dispose();\n\t\t\tthis.handle = null;\n\t\t}\n\n\t\tsuper.dispose();\n\t}\n\n\tprivate onTouchStart(e: TouchEvent): void {\n\t\tconst timestamp = Date.now(); // use Date.now() because on FF e.timeStamp is not epoch based.\n\n\t\tif (this.handle) {\n\t\t\tthis.handle.dispose();\n\t\t\tthis.handle = null;\n\t\t}\n\n\t\tfor (let i = 0, len = e.targetTouches.length; i < len; i++) {\n\t\t\tconst touch = e.targetTouches.item(i);\n\n\t\t\tthis.activeTouches[touch.identifier] = {\n\t\t\t\tid: touch.identifier,\n\t\t\t\tinitialTarget: touch.target,\n\t\t\t\tinitialTimeStamp: timestamp,\n\t\t\t\tinitialPageX: touch.pageX,\n\t\t\t\tinitialPageY: touch.pageY,\n\t\t\t\trollingTimestamps: [timestamp],\n\t\t\t\trollingPageX: [touch.pageX],\n\t\t\t\trollingPageY: [touch.pageY]\n\t\t\t};\n\n\t\t\tconst evt = this.newGestureEvent(EventType.Start, touch.target);\n\t\t\tevt.pageX = touch.pageX;\n\t\t\tevt.pageY = touch.pageY;\n\t\t\tthis.dispatchEvent(evt);\n\t\t}\n\n\t\tif (this.dispatched) {\n\t\t\te.preventDefault();\n\t\t\te.stopPropagation();\n\t\t\tthis.dispatched = false;\n\t\t}\n\t}\n\n\tprivate onTouchEnd(targetWindow: Window, e: TouchEvent): void {\n\t\tconst timestamp = Date.now(); // use Date.now() because on FF e.timeStamp is not epoch based.\n\n\t\tconst activeTouchCount = Object.keys(this.activeTouches).length;\n\n\t\tfor (let i = 0, len = e.changedTouches.length; i < len; i++) {\n\n\t\t\tconst touch = e.changedTouches.item(i);\n\n\t\t\tif (!this.activeTouches.hasOwnProperty(String(touch.identifier))) {\n\t\t\t\tconsole.warn('move of an UNKNOWN touch', touch);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst data = this.activeTouches[touch.identifier],\n\t\t\t\tholdTime = Date.now() - data.initialTimeStamp;\n\n\t\t\tif (holdTime < Gesture.HOLD_DELAY\n\t\t\t\t&& Math.abs(data.initialPageX - arrays.tail(data.rollingPageX)!) < 30\n\t\t\t\t&& Math.abs(data.initialPageY - arrays.tail(data.rollingPageY)!) < 30) {\n\n\t\t\t\tconst evt = this.newGestureEvent(EventType.Tap, data.initialTarget);\n\t\t\t\tevt.pageX = arrays.tail(data.rollingPageX)!;\n\t\t\t\tevt.pageY = arrays.tail(data.rollingPageY)!;\n\t\t\t\tthis.dispatchEvent(evt);\n\n\t\t\t} else if (holdTime >= Gesture.HOLD_DELAY\n\t\t\t\t&& Math.abs(data.initialPageX - arrays.tail(data.rollingPageX)!) < 30\n\t\t\t\t&& Math.abs(data.initialPageY - arrays.tail(data.rollingPageY)!) < 30) {\n\n\t\t\t\tconst evt = this.newGestureEvent(EventType.Contextmenu, data.initialTarget);\n\t\t\t\tevt.pageX = arrays.tail(data.rollingPageX)!;\n\t\t\t\tevt.pageY = arrays.tail(data.rollingPageY)!;\n\t\t\t\tthis.dispatchEvent(evt);\n\n\t\t\t} else if (activeTouchCount === 1) {\n\t\t\t\tconst finalX = arrays.tail(data.rollingPageX)!;\n\t\t\t\tconst finalY = arrays.tail(data.rollingPageY)!;\n\n\t\t\t\tconst deltaT = arrays.tail(data.rollingTimestamps)! - data.rollingTimestamps[0];\n\t\t\t\tconst deltaX = finalX - data.rollingPageX[0];\n\t\t\t\tconst deltaY = finalY - data.rollingPageY[0];\n\n\t\t\t\t// We need to get all the dispatch targets on the start of the inertia event\n\t\t\t\tconst dispatchTo = [...this.targets].filter(t => data.initialTarget instanceof Node && t.contains(data.initialTarget));\n\t\t\t\tthis.inertia(targetWindow, dispatchTo, timestamp,\t// time now\n\t\t\t\t\tMath.abs(deltaX) / deltaT,\t\t\t\t\t\t// speed\n\t\t\t\t\tdeltaX > 0 ? 1 : -1,\t\t\t\t\t\t\t// x direction\n\t\t\t\t\tfinalX,\t\t\t\t\t\t\t\t\t\t\t// x now\n\t\t\t\t\tMath.abs(deltaY) / deltaT,  \t\t\t\t\t// y speed\n\t\t\t\t\tdeltaY > 0 ? 1 : -1,\t\t\t\t\t\t\t// y direction\n\t\t\t\t\tfinalY\t\t\t\t\t\t\t\t\t\t\t// y now\n\t\t\t\t);\n\t\t\t}\n\n\n\t\t\tthis.dispatchEvent(this.newGestureEvent(EventType.End, data.initialTarget));\n\t\t\t// forget about this touch\n\t\t\tdelete this.activeTouches[touch.identifier];\n\t\t}\n\n\t\tif (this.dispatched) {\n\t\t\te.preventDefault();\n\t\t\te.stopPropagation();\n\t\t\tthis.dispatched = false;\n\t\t}\n\t}\n\n\tprivate newGestureEvent(type: string, initialTarget?: EventTarget): GestureEvent {\n\t\tconst event = document.createEvent('CustomEvent') as unknown as GestureEvent;\n\t\tevent.initEvent(type, false, true);\n\t\tevent.initialTarget = initialTarget;\n\t\tevent.tapCount = 0;\n\t\treturn event;\n\t}\n\n\tprivate dispatchEvent(event: GestureEvent): void {\n\t\tif (event.type === EventType.Tap) {\n\t\t\tconst currentTime = (new Date()).getTime();\n\t\t\tlet setTapCount = 0;\n\t\t\tif (currentTime - this._lastSetTapCountTime > Gesture.CLEAR_TAP_COUNT_TIME) {\n\t\t\t\tsetTapCount = 1;\n\t\t\t} else {\n\t\t\t\tsetTapCount = 2;\n\t\t\t}\n\n\t\t\tthis._lastSetTapCountTime = currentTime;\n\t\t\tevent.tapCount = setTapCount;\n\t\t} else if (event.type === EventType.Change || event.type === EventType.Contextmenu) {\n\t\t\t// tap is canceled by scrolling or context menu\n\t\t\tthis._lastSetTapCountTime = 0;\n\t\t}\n\n\t\tif (event.initialTarget instanceof Node) {\n\t\t\tfor (const ignoreTarget of this.ignoreTargets) {\n\t\t\t\tif (ignoreTarget.contains(event.initialTarget)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst targets: [number, HTMLElement][] = [];\n\t\t\tfor (const target of this.targets) {\n\t\t\t\tif (target.contains(event.initialTarget)) {\n\t\t\t\t\tlet depth = 0;\n\t\t\t\t\tlet now: Node | null = event.initialTarget;\n\t\t\t\t\twhile (now && now !== target) {\n\t\t\t\t\t\tdepth++;\n\t\t\t\t\t\tnow = now.parentElement;\n\t\t\t\t\t}\n\t\t\t\t\ttargets.push([depth, target]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttargets.sort((a, b) => a[0] - b[0]);\n\n\t\t\tfor (const [_, target] of targets) {\n\t\t\t\ttarget.dispatchEvent(event);\n\t\t\t\tthis.dispatched = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate inertia(targetWindow: Window, dispatchTo: readonly EventTarget[], t1: number, vX: number, dirX: number, x: number, vY: number, dirY: number, y: number): void {\n\t\tthis.handle = DomUtils.scheduleAtNextAnimationFrame(targetWindow, () => {\n\t\t\tconst now = Date.now();\n\n\t\t\t// velocity: old speed + accel_over_time\n\t\t\tconst deltaT = now - t1;\n\t\t\tlet delta_pos_x = 0, delta_pos_y = 0;\n\t\t\tlet stopped = true;\n\n\t\t\tvX += Gesture.SCROLL_FRICTION * deltaT;\n\t\t\tvY += Gesture.SCROLL_FRICTION * deltaT;\n\n\t\t\tif (vX > 0) {\n\t\t\t\tstopped = false;\n\t\t\t\tdelta_pos_x = dirX * vX * deltaT;\n\t\t\t}\n\n\t\t\tif (vY > 0) {\n\t\t\t\tstopped = false;\n\t\t\t\tdelta_pos_y = dirY * vY * deltaT;\n\t\t\t}\n\n\t\t\t// dispatch translation event\n\t\t\tconst evt = this.newGestureEvent(EventType.Change);\n\t\t\tevt.translationX = delta_pos_x;\n\t\t\tevt.translationY = delta_pos_y;\n\t\t\tdispatchTo.forEach(d => d.dispatchEvent(evt));\n\n\t\t\tif (!stopped) {\n\t\t\t\tthis.inertia(targetWindow, dispatchTo, now, vX, dirX, x + delta_pos_x, vY, dirY, y + delta_pos_y);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate onTouchMove(e: TouchEvent): void {\n\t\tconst timestamp = Date.now(); // use Date.now() because on FF e.timeStamp is not epoch based.\n\n\t\tfor (let i = 0, len = e.changedTouches.length; i < len; i++) {\n\n\t\t\tconst touch = e.changedTouches.item(i);\n\n\t\t\tif (!this.activeTouches.hasOwnProperty(String(touch.identifier))) {\n\t\t\t\tconsole.warn('end of an UNKNOWN touch', touch);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst data = this.activeTouches[touch.identifier];\n\n\t\t\tconst evt = this.newGestureEvent(EventType.Change, data.initialTarget);\n\t\t\tevt.translationX = touch.pageX - arrays.tail(data.rollingPageX)!;\n\t\t\tevt.translationY = touch.pageY - arrays.tail(data.rollingPageY)!;\n\t\t\tevt.pageX = touch.pageX;\n\t\t\tevt.pageY = touch.pageY;\n\t\t\tthis.dispatchEvent(evt);\n\n\t\t\t// only keep a few data points, to average the final speed\n\t\t\tif (data.rollingPageX.length > 3) {\n\t\t\t\tdata.rollingPageX.shift();\n\t\t\t\tdata.rollingPageY.shift();\n\t\t\t\tdata.rollingTimestamps.shift();\n\t\t\t}\n\n\t\t\tdata.rollingPageX.push(touch.pageX);\n\t\t\tdata.rollingPageY.push(touch.pageY);\n\t\t\tdata.rollingTimestamps.push(timestamp);\n\t\t}\n\n\t\tif (this.dispatched) {\n\t\t\te.preventDefault();\n\t\t\te.stopPropagation();\n\t\t\tthis.dispatched = false;\n\t\t}\n\t}\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as dom from 'vs/base/browser/dom';\nimport { IKeyboardEvent, StandardKeyboardEvent } from 'vs/base/browser/keyboardEvent';\nimport { IMouseEvent, StandardMouseEvent } from 'vs/base/browser/mouseEvent';\nimport { Gesture } from 'vs/base/browser/touch';\nimport { Disposable, IDisposable } from 'vs/base/common/lifecycle';\n\nexport abstract class Widget extends Disposable {\n\n\tprotected onclick(domNode: HTMLElement, listener: (e: IMouseEvent) => void): void {\n\t\tthis._register(dom.addDisposableListener(domNode, dom.EventType.CLICK, (e: MouseEvent) => listener(new StandardMouseEvent(dom.getWindow(domNode), e))));\n\t}\n\n\tprotected onmousedown(domNode: HTMLElement, listener: (e: IMouseEvent) => void): void {\n\t\tthis._register(dom.addDisposableListener(domNode, dom.EventType.MOUSE_DOWN, (e: MouseEvent) => listener(new StandardMouseEvent(dom.getWindow(domNode), e))));\n\t}\n\n\tprotected onmouseover(domNode: HTMLElement, listener: (e: IMouseEvent) => void): void {\n\t\tthis._register(dom.addDisposableListener(domNode, dom.EventType.MOUSE_OVER, (e: MouseEvent) => listener(new StandardMouseEvent(dom.getWindow(domNode), e))));\n\t}\n\n\tprotected onmouseleave(domNode: HTMLElement, listener: (e: IMouseEvent) => void): void {\n\t\tthis._register(dom.addDisposableListener(domNode, dom.EventType.MOUSE_LEAVE, (e: MouseEvent) => listener(new StandardMouseEvent(dom.getWindow(domNode), e))));\n\t}\n\n\tprotected onkeydown(domNode: HTMLElement, listener: (e: IKeyboardEvent) => void): void {\n\t\tthis._register(dom.addDisposableListener(domNode, dom.EventType.KEY_DOWN, (e: KeyboardEvent) => listener(new StandardKeyboardEvent(e))));\n\t}\n\n\tprotected onkeyup(domNode: HTMLElement, listener: (e: IKeyboardEvent) => void): void {\n\t\tthis._register(dom.addDisposableListener(domNode, dom.EventType.KEY_UP, (e: KeyboardEvent) => listener(new StandardKeyboardEvent(e))));\n\t}\n\n\tprotected oninput(domNode: HTMLElement, listener: (e: Event) => void): void {\n\t\tthis._register(dom.addDisposableListener(domNode, dom.EventType.INPUT, listener));\n\t}\n\n\tprotected onblur(domNode: HTMLElement, listener: (e: Event) => void): void {\n\t\tthis._register(dom.addDisposableListener(domNode, dom.EventType.BLUR, listener));\n\t}\n\n\tprotected onfocus(domNode: HTMLElement, listener: (e: Event) => void): void {\n\t\tthis._register(dom.addDisposableListener(domNode, dom.EventType.FOCUS, listener));\n\t}\n\n\tprotected onchange(domNode: HTMLElement, listener: (e: Event) => void): void {\n\t\tthis._register(dom.addDisposableListener(domNode, dom.EventType.CHANGE, listener));\n\t}\n\n\tprotected ignoreGesture(domNode: HTMLElement): IDisposable {\n\t\treturn Gesture.ignoreTarget(domNode);\n\t}\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { GlobalPointerMoveMonitor } from 'vs/base/browser/globalPointerMoveMonitor';\nimport { Widget } from 'vs/base/browser/ui/widget';\nimport { TimeoutTimer } from 'vs/base/common/async';\nimport * as dom from 'vs/base/browser/dom';\n\n/**\n * The arrow image size.\n */\nexport const ARROW_IMG_SIZE = 11;\n\nexport interface ScrollbarArrowOptions {\n\tonActivate: () => void;\n\tclassName: string;\n\t// icon: ThemeIcon;\n\n\tbgWidth: number;\n\tbgHeight: number;\n\n\ttop?: number;\n\tleft?: number;\n\tbottom?: number;\n\tright?: number;\n}\n\nexport class ScrollbarArrow extends Widget {\n\n\tprivate _onActivate: () => void;\n\tpublic bgDomNode: HTMLElement;\n\tpublic domNode: HTMLElement;\n\tprivate _pointerdownRepeatTimer: dom.WindowIntervalTimer;\n\tprivate _pointerdownScheduleRepeatTimer: TimeoutTimer;\n\tprivate _pointerMoveMonitor: GlobalPointerMoveMonitor;\n\n\tconstructor(opts: ScrollbarArrowOptions) {\n\t\tsuper();\n\t\tthis._onActivate = opts.onActivate;\n\n\t\tthis.bgDomNode = document.createElement('div');\n\t\tthis.bgDomNode.className = 'arrow-background';\n\t\tthis.bgDomNode.style.position = 'absolute';\n\t\tthis.bgDomNode.style.width = opts.bgWidth + 'px';\n\t\tthis.bgDomNode.style.height = opts.bgHeight + 'px';\n\t\tif (typeof opts.top !== 'undefined') {\n\t\t\tthis.bgDomNode.style.top = '0px';\n\t\t}\n\t\tif (typeof opts.left !== 'undefined') {\n\t\t\tthis.bgDomNode.style.left = '0px';\n\t\t}\n\t\tif (typeof opts.bottom !== 'undefined') {\n\t\t\tthis.bgDomNode.style.bottom = '0px';\n\t\t}\n\t\tif (typeof opts.right !== 'undefined') {\n\t\t\tthis.bgDomNode.style.right = '0px';\n\t\t}\n\n\t\tthis.domNode = document.createElement('div');\n\t\tthis.domNode.className = opts.className;\n\t\t// this.domNode.classList.add(...ThemeIcon.asClassNameArray(opts.icon));\n\n\t\tthis.domNode.style.position = 'absolute';\n\t\tthis.domNode.style.width = ARROW_IMG_SIZE + 'px';\n\t\tthis.domNode.style.height = ARROW_IMG_SIZE + 'px';\n\t\tif (typeof opts.top !== 'undefined') {\n\t\t\tthis.domNode.style.top = opts.top + 'px';\n\t\t}\n\t\tif (typeof opts.left !== 'undefined') {\n\t\t\tthis.domNode.style.left = opts.left + 'px';\n\t\t}\n\t\tif (typeof opts.bottom !== 'undefined') {\n\t\t\tthis.domNode.style.bottom = opts.bottom + 'px';\n\t\t}\n\t\tif (typeof opts.right !== 'undefined') {\n\t\t\tthis.domNode.style.right = opts.right + 'px';\n\t\t}\n\n\t\tthis._pointerMoveMonitor = this._register(new GlobalPointerMoveMonitor());\n\t\tthis._register(dom.addStandardDisposableListener(this.bgDomNode, dom.EventType.POINTER_DOWN, (e) => this._arrowPointerDown(e)));\n\t\tthis._register(dom.addStandardDisposableListener(this.domNode, dom.EventType.POINTER_DOWN, (e) => this._arrowPointerDown(e)));\n\n\t\tthis._pointerdownRepeatTimer = this._register(new dom.WindowIntervalTimer());\n\t\tthis._pointerdownScheduleRepeatTimer = this._register(new TimeoutTimer());\n\t}\n\n\tprivate _arrowPointerDown(e: PointerEvent): void {\n\t\tif (!e.target || !(e.target instanceof Element)) {\n\t\t\treturn;\n\t\t}\n\t\tconst scheduleRepeater = () => {\n\t\t\tthis._pointerdownRepeatTimer.cancelAndSet(() => this._onActivate(), 1000 / 24, dom.getWindow(e));\n\t\t};\n\n\t\tthis._onActivate();\n\t\tthis._pointerdownRepeatTimer.cancel();\n\t\tthis._pointerdownScheduleRepeatTimer.cancelAndSet(scheduleRepeater, 200);\n\n\t\tthis._pointerMoveMonitor.startMonitoring(\n\t\t\te.target,\n\t\t\te.pointerId,\n\t\t\te.buttons,\n\t\t\t(pointerMoveData) => { /* Intentional empty */ },\n\t\t\t() => {\n\t\t\t\tthis._pointerdownRepeatTimer.cancel();\n\t\t\t\tthis._pointerdownScheduleRepeatTimer.cancel();\n\t\t\t}\n\t\t);\n\n\t\te.preventDefault();\n\t}\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { Disposable, IDisposable } from 'vs/base/common/lifecycle';\n\nexport const enum ScrollbarVisibility {\n\tAuto = 1,\n\tHidden = 2,\n\tVisible = 3\n}\n\nexport interface ScrollEvent {\n\tinSmoothScrolling: boolean;\n\n\toldWidth: number;\n\toldScrollWidth: number;\n\toldScrollLeft: number;\n\n\twidth: number;\n\tscrollWidth: number;\n\tscrollLeft: number;\n\n\toldHeight: number;\n\toldScrollHeight: number;\n\toldScrollTop: number;\n\n\theight: number;\n\tscrollHeight: number;\n\tscrollTop: number;\n\n\twidthChanged: boolean;\n\tscrollWidthChanged: boolean;\n\tscrollLeftChanged: boolean;\n\n\theightChanged: boolean;\n\tscrollHeightChanged: boolean;\n\tscrollTopChanged: boolean;\n}\n\nexport class ScrollState implements IScrollDimensions, IScrollPosition {\n\t_scrollStateBrand: void = undefined;\n\n\tpublic readonly rawScrollLeft: number;\n\tpublic readonly rawScrollTop: number;\n\n\tpublic readonly width: number;\n\tpublic readonly scrollWidth: number;\n\tpublic readonly scrollLeft: number;\n\tpublic readonly height: number;\n\tpublic readonly scrollHeight: number;\n\tpublic readonly scrollTop: number;\n\n\tconstructor(\n\t\tprivate readonly _forceIntegerValues: boolean,\n\t\twidth: number,\n\t\tscrollWidth: number,\n\t\tscrollLeft: number,\n\t\theight: number,\n\t\tscrollHeight: number,\n\t\tscrollTop: number\n\t) {\n\t\tif (this._forceIntegerValues) {\n\t\t\twidth = width | 0;\n\t\t\tscrollWidth = scrollWidth | 0;\n\t\t\tscrollLeft = scrollLeft | 0;\n\t\t\theight = height | 0;\n\t\t\tscrollHeight = scrollHeight | 0;\n\t\t\tscrollTop = scrollTop | 0;\n\t\t}\n\n\t\tthis.rawScrollLeft = scrollLeft; // before validation\n\t\tthis.rawScrollTop = scrollTop; // before validation\n\n\t\tif (width < 0) {\n\t\t\twidth = 0;\n\t\t}\n\t\tif (scrollLeft + width > scrollWidth) {\n\t\t\tscrollLeft = scrollWidth - width;\n\t\t}\n\t\tif (scrollLeft < 0) {\n\t\t\tscrollLeft = 0;\n\t\t}\n\n\t\tif (height < 0) {\n\t\t\theight = 0;\n\t\t}\n\t\tif (scrollTop + height > scrollHeight) {\n\t\t\tscrollTop = scrollHeight - height;\n\t\t}\n\t\tif (scrollTop < 0) {\n\t\t\tscrollTop = 0;\n\t\t}\n\n\t\tthis.width = width;\n\t\tthis.scrollWidth = scrollWidth;\n\t\tthis.scrollLeft = scrollLeft;\n\t\tthis.height = height;\n\t\tthis.scrollHeight = scrollHeight;\n\t\tthis.scrollTop = scrollTop;\n\t}\n\n\tpublic equals(other: ScrollState): boolean {\n\t\treturn (\n\t\t\tthis.rawScrollLeft === other.rawScrollLeft\n\t\t\t&& this.rawScrollTop === other.rawScrollTop\n\t\t\t&& this.width === other.width\n\t\t\t&& this.scrollWidth === other.scrollWidth\n\t\t\t&& this.scrollLeft === other.scrollLeft\n\t\t\t&& this.height === other.height\n\t\t\t&& this.scrollHeight === other.scrollHeight\n\t\t\t&& this.scrollTop === other.scrollTop\n\t\t);\n\t}\n\n\tpublic withScrollDimensions(update: INewScrollDimensions, useRawScrollPositions: boolean): ScrollState {\n\t\treturn new ScrollState(\n\t\t\tthis._forceIntegerValues,\n\t\t\t(typeof update.width !== 'undefined' ? update.width : this.width),\n\t\t\t(typeof update.scrollWidth !== 'undefined' ? update.scrollWidth : this.scrollWidth),\n\t\t\tuseRawScrollPositions ? this.rawScrollLeft : this.scrollLeft,\n\t\t\t(typeof update.height !== 'undefined' ? update.height : this.height),\n\t\t\t(typeof update.scrollHeight !== 'undefined' ? update.scrollHeight : this.scrollHeight),\n\t\t\tuseRawScrollPositions ? this.rawScrollTop : this.scrollTop\n\t\t);\n\t}\n\n\tpublic withScrollPosition(update: INewScrollPosition): ScrollState {\n\t\treturn new ScrollState(\n\t\t\tthis._forceIntegerValues,\n\t\t\tthis.width,\n\t\t\tthis.scrollWidth,\n\t\t\t(typeof update.scrollLeft !== 'undefined' ? update.scrollLeft : this.rawScrollLeft),\n\t\t\tthis.height,\n\t\t\tthis.scrollHeight,\n\t\t\t(typeof update.scrollTop !== 'undefined' ? update.scrollTop : this.rawScrollTop)\n\t\t);\n\t}\n\n\tpublic createScrollEvent(previous: ScrollState, inSmoothScrolling: boolean): ScrollEvent {\n\t\tconst widthChanged = (this.width !== previous.width);\n\t\tconst scrollWidthChanged = (this.scrollWidth !== previous.scrollWidth);\n\t\tconst scrollLeftChanged = (this.scrollLeft !== previous.scrollLeft);\n\n\t\tconst heightChanged = (this.height !== previous.height);\n\t\tconst scrollHeightChanged = (this.scrollHeight !== previous.scrollHeight);\n\t\tconst scrollTopChanged = (this.scrollTop !== previous.scrollTop);\n\n\t\treturn {\n\t\t\tinSmoothScrolling: inSmoothScrolling,\n\t\t\toldWidth: previous.width,\n\t\t\toldScrollWidth: previous.scrollWidth,\n\t\t\toldScrollLeft: previous.scrollLeft,\n\n\t\t\twidth: this.width,\n\t\t\tscrollWidth: this.scrollWidth,\n\t\t\tscrollLeft: this.scrollLeft,\n\n\t\t\toldHeight: previous.height,\n\t\t\toldScrollHeight: previous.scrollHeight,\n\t\t\toldScrollTop: previous.scrollTop,\n\n\t\t\theight: this.height,\n\t\t\tscrollHeight: this.scrollHeight,\n\t\t\tscrollTop: this.scrollTop,\n\n\t\t\twidthChanged: widthChanged,\n\t\t\tscrollWidthChanged: scrollWidthChanged,\n\t\t\tscrollLeftChanged: scrollLeftChanged,\n\n\t\t\theightChanged: heightChanged,\n\t\t\tscrollHeightChanged: scrollHeightChanged,\n\t\t\tscrollTopChanged: scrollTopChanged,\n\t\t};\n\t}\n\n}\n\nexport interface IScrollDimensions {\n\treadonly width: number;\n\treadonly scrollWidth: number;\n\treadonly height: number;\n\treadonly scrollHeight: number;\n}\nexport interface INewScrollDimensions {\n\twidth?: number;\n\tscrollWidth?: number;\n\theight?: number;\n\tscrollHeight?: number;\n}\n\nexport interface IScrollPosition {\n\treadonly scrollLeft: number;\n\treadonly scrollTop: number;\n}\nexport interface ISmoothScrollPosition {\n\treadonly scrollLeft: number;\n\treadonly scrollTop: number;\n\n\treadonly width: number;\n\treadonly height: number;\n}\nexport interface INewScrollPosition {\n\tscrollLeft?: number;\n\tscrollTop?: number;\n}\n\nexport interface IScrollableOptions {\n\t/**\n\t * Define if the scroll values should always be integers.\n\t */\n\tforceIntegerValues: boolean;\n\t/**\n\t * Set the duration (ms) used for smooth scroll animations.\n\t */\n\tsmoothScrollDuration: number;\n\t/**\n\t * A function to schedule an update at the next frame (used for smooth scroll animations).\n\t */\n\tscheduleAtNextAnimationFrame: (callback: () => void) => IDisposable;\n}\n\nexport class Scrollable extends Disposable {\n\n\t_scrollableBrand: void = undefined;\n\n\tprivate _smoothScrollDuration: number;\n\tprivate readonly _scheduleAtNextAnimationFrame: (callback: () => void) => IDisposable;\n\tprivate _state: ScrollState;\n\tprivate _smoothScrolling: SmoothScrollingOperation | null;\n\n\tprivate _onScroll = this._register(new Emitter<ScrollEvent>());\n\tpublic readonly onScroll: Event<ScrollEvent> = this._onScroll.event;\n\n\tconstructor(options: IScrollableOptions) {\n\t\tsuper();\n\n\t\tthis._smoothScrollDuration = options.smoothScrollDuration;\n\t\tthis._scheduleAtNextAnimationFrame = options.scheduleAtNextAnimationFrame;\n\t\tthis._state = new ScrollState(options.forceIntegerValues, 0, 0, 0, 0, 0, 0);\n\t\tthis._smoothScrolling = null;\n\t}\n\n\tpublic override dispose(): void {\n\t\tif (this._smoothScrolling) {\n\t\t\tthis._smoothScrolling.dispose();\n\t\t\tthis._smoothScrolling = null;\n\t\t}\n\t\tsuper.dispose();\n\t}\n\n\tpublic setSmoothScrollDuration(smoothScrollDuration: number): void {\n\t\tthis._smoothScrollDuration = smoothScrollDuration;\n\t}\n\n\tpublic validateScrollPosition(scrollPosition: INewScrollPosition): IScrollPosition {\n\t\treturn this._state.withScrollPosition(scrollPosition);\n\t}\n\n\tpublic getScrollDimensions(): IScrollDimensions {\n\t\treturn this._state;\n\t}\n\n\tpublic setScrollDimensions(dimensions: INewScrollDimensions, useRawScrollPositions: boolean): void {\n\t\tconst newState = this._state.withScrollDimensions(dimensions, useRawScrollPositions);\n\t\tthis._setState(newState, Boolean(this._smoothScrolling));\n\n\t\t// Validate outstanding animated scroll position target\n\t\tthis._smoothScrolling?.acceptScrollDimensions(this._state);\n\t}\n\n\t/**\n\t * Returns the final scroll position that the instance will have once the smooth scroll animation concludes.\n\t * If no scroll animation is occurring, it will return the current scroll position instead.\n\t */\n\tpublic getFutureScrollPosition(): IScrollPosition {\n\t\tif (this._smoothScrolling) {\n\t\t\treturn this._smoothScrolling.to;\n\t\t}\n\t\treturn this._state;\n\t}\n\n\t/**\n\t * Returns the current scroll position.\n\t * Note: This result might be an intermediate scroll position, as there might be an ongoing smooth scroll animation.\n\t */\n\tpublic getCurrentScrollPosition(): IScrollPosition {\n\t\treturn this._state;\n\t}\n\n\tpublic setScrollPositionNow(update: INewScrollPosition): void {\n\t\t// no smooth scrolling requested\n\t\tconst newState = this._state.withScrollPosition(update);\n\n\t\t// Terminate any outstanding smooth scrolling\n\t\tif (this._smoothScrolling) {\n\t\t\tthis._smoothScrolling.dispose();\n\t\t\tthis._smoothScrolling = null;\n\t\t}\n\n\t\tthis._setState(newState, false);\n\t}\n\n\tpublic setScrollPositionSmooth(update: INewScrollPosition, reuseAnimation?: boolean): void {\n\t\tif (this._smoothScrollDuration === 0) {\n\t\t\t// Smooth scrolling not supported.\n\t\t\treturn this.setScrollPositionNow(update);\n\t\t}\n\n\t\tif (this._smoothScrolling) {\n\t\t\t// Combine our pending scrollLeft/scrollTop with incoming scrollLeft/scrollTop\n\t\t\tupdate = {\n\t\t\t\tscrollLeft: (typeof update.scrollLeft === 'undefined' ? this._smoothScrolling.to.scrollLeft : update.scrollLeft),\n\t\t\t\tscrollTop: (typeof update.scrollTop === 'undefined' ? this._smoothScrolling.to.scrollTop : update.scrollTop)\n\t\t\t};\n\n\t\t\t// Validate `update`\n\t\t\tconst validTarget = this._state.withScrollPosition(update);\n\n\t\t\tif (this._smoothScrolling.to.scrollLeft === validTarget.scrollLeft && this._smoothScrolling.to.scrollTop === validTarget.scrollTop) {\n\t\t\t\t// No need to interrupt or extend the current animation since we're going to the same place\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlet newSmoothScrolling: SmoothScrollingOperation;\n\t\t\tif (reuseAnimation) {\n\t\t\t\tnewSmoothScrolling = new SmoothScrollingOperation(this._smoothScrolling.from, validTarget, this._smoothScrolling.startTime, this._smoothScrolling.duration);\n\t\t\t} else {\n\t\t\t\tnewSmoothScrolling = this._smoothScrolling.combine(this._state, validTarget, this._smoothScrollDuration);\n\t\t\t}\n\t\t\tthis._smoothScrolling.dispose();\n\t\t\tthis._smoothScrolling = newSmoothScrolling;\n\t\t} else {\n\t\t\t// Validate `update`\n\t\t\tconst validTarget = this._state.withScrollPosition(update);\n\n\t\t\tthis._smoothScrolling = SmoothScrollingOperation.start(this._state, validTarget, this._smoothScrollDuration);\n\t\t}\n\n\t\t// Begin smooth scrolling animation\n\t\tthis._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(() => {\n\t\t\tif (!this._smoothScrolling) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._smoothScrolling.animationFrameDisposable = null;\n\t\t\tthis._performSmoothScrolling();\n\t\t});\n\t}\n\n\tpublic hasPendingScrollAnimation(): boolean {\n\t\treturn Boolean(this._smoothScrolling);\n\t}\n\n\tprivate _performSmoothScrolling(): void {\n\t\tif (!this._smoothScrolling) {\n\t\t\treturn;\n\t\t}\n\t\tconst update = this._smoothScrolling.tick();\n\t\tconst newState = this._state.withScrollPosition(update);\n\n\t\tthis._setState(newState, true);\n\n\t\tif (!this._smoothScrolling) {\n\t\t\t// Looks like someone canceled the smooth scrolling\n\t\t\t// from the scroll event handler\n\t\t\treturn;\n\t\t}\n\n\t\tif (update.isDone) {\n\t\t\tthis._smoothScrolling.dispose();\n\t\t\tthis._smoothScrolling = null;\n\t\t\treturn;\n\t\t}\n\n\t\t// Continue smooth scrolling animation\n\t\tthis._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(() => {\n\t\t\tif (!this._smoothScrolling) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._smoothScrolling.animationFrameDisposable = null;\n\t\t\tthis._performSmoothScrolling();\n\t\t});\n\t}\n\n\tprivate _setState(newState: ScrollState, inSmoothScrolling: boolean): void {\n\t\tconst oldState = this._state;\n\t\tif (oldState.equals(newState)) {\n\t\t\t// no change\n\t\t\treturn;\n\t\t}\n\t\tthis._state = newState;\n\t\tthis._onScroll.fire(this._state.createScrollEvent(oldState, inSmoothScrolling));\n\t}\n}\n\nexport class SmoothScrollingUpdate {\n\n\tpublic readonly scrollLeft: number;\n\tpublic readonly scrollTop: number;\n\tpublic readonly isDone: boolean;\n\n\tconstructor(scrollLeft: number, scrollTop: number, isDone: boolean) {\n\t\tthis.scrollLeft = scrollLeft;\n\t\tthis.scrollTop = scrollTop;\n\t\tthis.isDone = isDone;\n\t}\n\n}\n\ninterface IAnimation {\n\t(completion: number): number;\n}\n\nfunction createEaseOutCubic(from: number, to: number): IAnimation {\n\tconst delta = to - from;\n\treturn function (completion: number): number {\n\t\treturn from + delta * easeOutCubic(completion);\n\t};\n}\n\nfunction createComposed(a: IAnimation, b: IAnimation, cut: number): IAnimation {\n\treturn function (completion: number): number {\n\t\tif (completion < cut) {\n\t\t\treturn a(completion / cut);\n\t\t}\n\t\treturn b((completion - cut) / (1 - cut));\n\t};\n}\n\nexport class SmoothScrollingOperation {\n\n\tpublic readonly from: ISmoothScrollPosition;\n\tpublic to: ISmoothScrollPosition;\n\tpublic readonly duration: number;\n\tpublic readonly startTime: number;\n\tpublic animationFrameDisposable: IDisposable | null;\n\n\tprivate scrollLeft!: IAnimation;\n\tprivate scrollTop!: IAnimation;\n\n\tconstructor(from: ISmoothScrollPosition, to: ISmoothScrollPosition, startTime: number, duration: number) {\n\t\tthis.from = from;\n\t\tthis.to = to;\n\t\tthis.duration = duration;\n\t\tthis.startTime = startTime;\n\n\t\tthis.animationFrameDisposable = null;\n\n\t\tthis._initAnimations();\n\t}\n\n\tprivate _initAnimations(): void {\n\t\tthis.scrollLeft = this._initAnimation(this.from.scrollLeft, this.to.scrollLeft, this.to.width);\n\t\tthis.scrollTop = this._initAnimation(this.from.scrollTop, this.to.scrollTop, this.to.height);\n\t}\n\n\tprivate _initAnimation(from: number, to: number, viewportSize: number): IAnimation {\n\t\tconst delta = Math.abs(from - to);\n\t\tif (delta > 2.5 * viewportSize) {\n\t\t\tlet stop1: number, stop2: number;\n\t\t\tif (from < to) {\n\t\t\t\t// scroll to 75% of the viewportSize\n\t\t\t\tstop1 = from + 0.75 * viewportSize;\n\t\t\t\tstop2 = to - 0.75 * viewportSize;\n\t\t\t} else {\n\t\t\t\tstop1 = from - 0.75 * viewportSize;\n\t\t\t\tstop2 = to + 0.75 * viewportSize;\n\t\t\t}\n\t\t\treturn createComposed(createEaseOutCubic(from, stop1), createEaseOutCubic(stop2, to), 0.33);\n\t\t}\n\t\treturn createEaseOutCubic(from, to);\n\t}\n\n\tpublic dispose(): void {\n\t\tif (this.animationFrameDisposable !== null) {\n\t\t\tthis.animationFrameDisposable.dispose();\n\t\t\tthis.animationFrameDisposable = null;\n\t\t}\n\t}\n\n\tpublic acceptScrollDimensions(state: ScrollState): void {\n\t\tthis.to = state.withScrollPosition(this.to);\n\t\tthis._initAnimations();\n\t}\n\n\tpublic tick(): SmoothScrollingUpdate {\n\t\treturn this._tick(Date.now());\n\t}\n\n\tprotected _tick(now: number): SmoothScrollingUpdate {\n\t\tconst completion = (now - this.startTime) / this.duration;\n\n\t\tif (completion < 1) {\n\t\t\tconst newScrollLeft = this.scrollLeft(completion);\n\t\t\tconst newScrollTop = this.scrollTop(completion);\n\t\t\treturn new SmoothScrollingUpdate(newScrollLeft, newScrollTop, false);\n\t\t}\n\n\t\treturn new SmoothScrollingUpdate(this.to.scrollLeft, this.to.scrollTop, true);\n\t}\n\n\tpublic combine(from: ISmoothScrollPosition, to: ISmoothScrollPosition, duration: number): SmoothScrollingOperation {\n\t\treturn SmoothScrollingOperation.start(from, to, duration);\n\t}\n\n\tpublic static start(from: ISmoothScrollPosition, to: ISmoothScrollPosition, duration: number): SmoothScrollingOperation {\n\t\t// +10 / -10 : pretend the animation already started for a quicker response to a scroll request\n\t\tduration = duration + 10;\n\t\tconst startTime = Date.now() - 10;\n\n\t\treturn new SmoothScrollingOperation(from, to, startTime, duration);\n\t}\n}\n\nfunction easeInCubic(t: number) {\n\treturn Math.pow(t, 3);\n}\n\nfunction easeOutCubic(t: number) {\n\treturn 1 - easeInCubic(1 - t);\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { FastDomNode } from 'vs/base/browser/fastDomNode';\nimport { TimeoutTimer } from 'vs/base/common/async';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { ScrollbarVisibility } from 'vs/base/common/scrollable';\n\nexport class ScrollbarVisibilityController extends Disposable {\n\tprivate _visibility: ScrollbarVisibility;\n\tprivate _visibleClassName: string;\n\tprivate _invisibleClassName: string;\n\tprivate _domNode: FastDomNode<HTMLElement> | null;\n\tprivate _rawShouldBeVisible: boolean;\n\tprivate _shouldBeVisible: boolean;\n\tprivate _isNeeded: boolean;\n\tprivate _isVisible: boolean;\n\tprivate _revealTimer: TimeoutTimer;\n\n\tconstructor(visibility: ScrollbarVisibility, visibleClassName: string, invisibleClassName: string) {\n\t\tsuper();\n\t\tthis._visibility = visibility;\n\t\tthis._visibleClassName = visibleClassName;\n\t\tthis._invisibleClassName = invisibleClassName;\n\t\tthis._domNode = null;\n\t\tthis._isVisible = false;\n\t\tthis._isNeeded = false;\n\t\tthis._rawShouldBeVisible = false;\n\t\tthis._shouldBeVisible = false;\n\t\tthis._revealTimer = this._register(new TimeoutTimer());\n\t}\n\n\tpublic setVisibility(visibility: ScrollbarVisibility): void {\n\t\tif (this._visibility !== visibility) {\n\t\t\tthis._visibility = visibility;\n\t\t\tthis._updateShouldBeVisible();\n\t\t}\n\t}\n\n\t// ----------------- Hide / Reveal\n\n\tpublic setShouldBeVisible(rawShouldBeVisible: boolean): void {\n\t\tthis._rawShouldBeVisible = rawShouldBeVisible;\n\t\tthis._updateShouldBeVisible();\n\t}\n\n\tprivate _applyVisibilitySetting(): boolean {\n\t\tif (this._visibility === ScrollbarVisibility.Hidden) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this._visibility === ScrollbarVisibility.Visible) {\n\t\t\treturn true;\n\t\t}\n\t\treturn this._rawShouldBeVisible;\n\t}\n\n\tprivate _updateShouldBeVisible(): void {\n\t\tconst shouldBeVisible = this._applyVisibilitySetting();\n\n\t\tif (this._shouldBeVisible !== shouldBeVisible) {\n\t\t\tthis._shouldBeVisible = shouldBeVisible;\n\t\t\tthis.ensureVisibility();\n\t\t}\n\t}\n\n\tpublic setIsNeeded(isNeeded: boolean): void {\n\t\tif (this._isNeeded !== isNeeded) {\n\t\t\tthis._isNeeded = isNeeded;\n\t\t\tthis.ensureVisibility();\n\t\t}\n\t}\n\n\tpublic setDomNode(domNode: FastDomNode<HTMLElement>): void {\n\t\tthis._domNode = domNode;\n\t\tthis._domNode.setClassName(this._invisibleClassName);\n\n\t\t// Now that the flags & the dom node are in a consistent state, ensure the Hidden/Visible configuration\n\t\tthis.setShouldBeVisible(false);\n\t}\n\n\tpublic ensureVisibility(): void {\n\n\t\tif (!this._isNeeded) {\n\t\t\t// Nothing to be rendered\n\t\t\tthis._hide(false);\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._shouldBeVisible) {\n\t\t\tthis._reveal();\n\t\t} else {\n\t\t\tthis._hide(true);\n\t\t}\n\t}\n\n\tprivate _reveal(): void {\n\t\tif (this._isVisible) {\n\t\t\treturn;\n\t\t}\n\t\tthis._isVisible = true;\n\n\t\t// The CSS animation doesn't play otherwise\n\t\tthis._revealTimer.setIfNotSet(() => {\n\t\t\tthis._domNode?.setClassName(this._visibleClassName);\n\t\t}, 0);\n\t}\n\n\tprivate _hide(withFadeAway: boolean): void {\n\t\tthis._revealTimer.cancel();\n\t\tif (!this._isVisible) {\n\t\t\treturn;\n\t\t}\n\t\tthis._isVisible = false;\n\t\tthis._domNode?.setClassName(this._invisibleClassName + (withFadeAway ? ' fade' : ''));\n\t}\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as dom from 'vs/base/browser/dom';\nimport { createFastDomNode, FastDomNode } from 'vs/base/browser/fastDomNode';\nimport { GlobalPointerMoveMonitor } from 'vs/base/browser/globalPointerMoveMonitor';\nimport { StandardWheelEvent } from 'vs/base/browser/mouseEvent';\nimport { ScrollbarArrow, ScrollbarArrowOptions } from 'vs/base/browser/ui/scrollbar/scrollbarArrow';\nimport { ScrollbarState } from 'vs/base/browser/ui/scrollbar/scrollbarState';\nimport { ScrollbarVisibilityController } from 'vs/base/browser/ui/scrollbar/scrollbarVisibilityController';\nimport { Widget } from 'vs/base/browser/ui/widget';\nimport * as platform from 'vs/base/common/platform';\nimport { INewScrollPosition, Scrollable, ScrollbarVisibility } from 'vs/base/common/scrollable';\n\n/**\n * The orthogonal distance to the slider at which dragging \"resets\". This implements \"snapping\"\n */\nconst POINTER_DRAG_RESET_DISTANCE = 140;\n\nexport interface ISimplifiedPointerEvent {\n\tbuttons: number;\n\tpageX: number;\n\tpageY: number;\n}\n\nexport interface ScrollbarHost {\n\tonMouseWheel(mouseWheelEvent: StandardWheelEvent): void;\n\tonDragStart(): void;\n\tonDragEnd(): void;\n}\n\nexport interface AbstractScrollbarOptions {\n\tlazyRender: boolean;\n\thost: ScrollbarHost;\n\tscrollbarState: ScrollbarState;\n\tvisibility: ScrollbarVisibility;\n\textraScrollbarClassName: string;\n\tscrollable: Scrollable;\n\tscrollByPage: boolean;\n}\n\nexport abstract class AbstractScrollbar extends Widget {\n\n\tprotected _host: ScrollbarHost;\n\tprotected _scrollable: Scrollable;\n\tprotected _scrollByPage: boolean;\n\tprivate _lazyRender: boolean;\n\tprotected _scrollbarState: ScrollbarState;\n\tprotected _visibilityController: ScrollbarVisibilityController;\n\tprivate _pointerMoveMonitor: GlobalPointerMoveMonitor;\n\n\tpublic domNode: FastDomNode<HTMLElement>;\n\tpublic slider!: FastDomNode<HTMLElement>;\n\n\tprotected _shouldRender: boolean;\n\n\tconstructor(opts: AbstractScrollbarOptions) {\n\t\tsuper();\n\t\tthis._lazyRender = opts.lazyRender;\n\t\tthis._host = opts.host;\n\t\tthis._scrollable = opts.scrollable;\n\t\tthis._scrollByPage = opts.scrollByPage;\n\t\tthis._scrollbarState = opts.scrollbarState;\n\t\tthis._visibilityController = this._register(new ScrollbarVisibilityController(opts.visibility, 'visible scrollbar ' + opts.extraScrollbarClassName, 'invisible scrollbar ' + opts.extraScrollbarClassName));\n\t\tthis._visibilityController.setIsNeeded(this._scrollbarState.isNeeded());\n\t\tthis._pointerMoveMonitor = this._register(new GlobalPointerMoveMonitor());\n\t\tthis._shouldRender = true;\n\t\tthis.domNode = createFastDomNode(document.createElement('div'));\n\t\tthis.domNode.setAttribute('role', 'presentation');\n\t\tthis.domNode.setAttribute('aria-hidden', 'true');\n\n\t\tthis._visibilityController.setDomNode(this.domNode);\n\t\tthis.domNode.setPosition('absolute');\n\n\t\tthis._register(dom.addDisposableListener(this.domNode.domNode, dom.EventType.POINTER_DOWN, (e: PointerEvent) => this._domNodePointerDown(e)));\n\t}\n\n\t// ----------------- creation\n\n\t/**\n\t * Creates the dom node for an arrow & adds it to the container\n\t */\n\tprotected _createArrow(opts: ScrollbarArrowOptions): void {\n\t\tconst arrow = this._register(new ScrollbarArrow(opts));\n\t\tthis.domNode.domNode.appendChild(arrow.bgDomNode);\n\t\tthis.domNode.domNode.appendChild(arrow.domNode);\n\t}\n\n\t/**\n\t * Creates the slider dom node, adds it to the container & hooks up the events\n\t */\n\tprotected _createSlider(top: number, left: number, width: number | undefined, height: number | undefined): void {\n\t\tthis.slider = createFastDomNode(document.createElement('div'));\n\t\tthis.slider.setClassName('slider');\n\t\tthis.slider.setPosition('absolute');\n\t\tthis.slider.setTop(top);\n\t\tthis.slider.setLeft(left);\n\t\tif (typeof width === 'number') {\n\t\t\tthis.slider.setWidth(width);\n\t\t}\n\t\tif (typeof height === 'number') {\n\t\t\tthis.slider.setHeight(height);\n\t\t}\n\t\tthis.slider.setLayerHinting(true);\n\t\tthis.slider.setContain('strict');\n\n\t\tthis.domNode.domNode.appendChild(this.slider.domNode);\n\n\t\tthis._register(dom.addDisposableListener(\n\t\t\tthis.slider.domNode,\n\t\t\tdom.EventType.POINTER_DOWN,\n\t\t\t(e: PointerEvent) => {\n\t\t\t\tif (e.button === 0) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\tthis._sliderPointerDown(e);\n\t\t\t\t}\n\t\t\t}\n\t\t));\n\n\t\tthis.onclick(this.slider.domNode, e => {\n\t\t\tif (e.leftButton) {\n\t\t\t\te.stopPropagation();\n\t\t\t}\n\t\t});\n\t}\n\n\t// ----------------- Update state\n\n\tprotected _onElementSize(visibleSize: number): boolean {\n\t\tif (this._scrollbarState.setVisibleSize(visibleSize)) {\n\t\t\tthis._visibilityController.setIsNeeded(this._scrollbarState.isNeeded());\n\t\t\tthis._shouldRender = true;\n\t\t\tif (!this._lazyRender) {\n\t\t\t\tthis.render();\n\t\t\t}\n\t\t}\n\t\treturn this._shouldRender;\n\t}\n\n\tprotected _onElementScrollSize(elementScrollSize: number): boolean {\n\t\tif (this._scrollbarState.setScrollSize(elementScrollSize)) {\n\t\t\tthis._visibilityController.setIsNeeded(this._scrollbarState.isNeeded());\n\t\t\tthis._shouldRender = true;\n\t\t\tif (!this._lazyRender) {\n\t\t\t\tthis.render();\n\t\t\t}\n\t\t}\n\t\treturn this._shouldRender;\n\t}\n\n\tprotected _onElementScrollPosition(elementScrollPosition: number): boolean {\n\t\tif (this._scrollbarState.setScrollPosition(elementScrollPosition)) {\n\t\t\tthis._visibilityController.setIsNeeded(this._scrollbarState.isNeeded());\n\t\t\tthis._shouldRender = true;\n\t\t\tif (!this._lazyRender) {\n\t\t\t\tthis.render();\n\t\t\t}\n\t\t}\n\t\treturn this._shouldRender;\n\t}\n\n\t// ----------------- rendering\n\n\tpublic beginReveal(): void {\n\t\tthis._visibilityController.setShouldBeVisible(true);\n\t}\n\n\tpublic beginHide(): void {\n\t\tthis._visibilityController.setShouldBeVisible(false);\n\t}\n\n\tpublic render(): void {\n\t\tif (!this._shouldRender) {\n\t\t\treturn;\n\t\t}\n\t\tthis._shouldRender = false;\n\n\t\tthis._renderDomNode(this._scrollbarState.getRectangleLargeSize(), this._scrollbarState.getRectangleSmallSize());\n\t\tthis._updateSlider(this._scrollbarState.getSliderSize(), this._scrollbarState.getArrowSize() + this._scrollbarState.getSliderPosition());\n\t}\n\t// ----------------- DOM events\n\n\tprivate _domNodePointerDown(e: PointerEvent): void {\n\t\tif (e.target !== this.domNode.domNode) {\n\t\t\treturn;\n\t\t}\n\t\tthis._onPointerDown(e);\n\t}\n\n\tpublic delegatePointerDown(e: PointerEvent): void {\n\t\tconst domTop = this.domNode.domNode.getClientRects()[0].top;\n\t\tconst sliderStart = domTop + this._scrollbarState.getSliderPosition();\n\t\tconst sliderStop = domTop + this._scrollbarState.getSliderPosition() + this._scrollbarState.getSliderSize();\n\t\tconst pointerPos = this._sliderPointerPosition(e);\n\t\tif (sliderStart <= pointerPos && pointerPos <= sliderStop) {\n\t\t\t// Act as if it was a pointer down on the slider\n\t\t\tif (e.button === 0) {\n\t\t\t\te.preventDefault();\n\t\t\t\tthis._sliderPointerDown(e);\n\t\t\t}\n\t\t} else {\n\t\t\t// Act as if it was a pointer down on the scrollbar\n\t\t\tthis._onPointerDown(e);\n\t\t}\n\t}\n\n\tprivate _onPointerDown(e: PointerEvent): void {\n\t\tlet offsetX: number;\n\t\tlet offsetY: number;\n\t\tif (e.target === this.domNode.domNode && typeof e.offsetX === 'number' && typeof e.offsetY === 'number') {\n\t\t\toffsetX = e.offsetX;\n\t\t\toffsetY = e.offsetY;\n\t\t} else {\n\t\t\tconst domNodePosition = dom.getDomNodePagePosition(this.domNode.domNode);\n\t\t\toffsetX = e.pageX - domNodePosition.left;\n\t\t\toffsetY = e.pageY - domNodePosition.top;\n\t\t}\n\n\t\tconst offset = this._pointerDownRelativePosition(offsetX, offsetY);\n\t\tthis._setDesiredScrollPositionNow(\n\t\t\tthis._scrollByPage\n\t\t\t\t? this._scrollbarState.getDesiredScrollPositionFromOffsetPaged(offset)\n\t\t\t\t: this._scrollbarState.getDesiredScrollPositionFromOffset(offset)\n\t\t);\n\n\t\tif (e.button === 0) {\n\t\t\t// left button\n\t\t\te.preventDefault();\n\t\t\tthis._sliderPointerDown(e);\n\t\t}\n\t}\n\n\tprivate _sliderPointerDown(e: PointerEvent): void {\n\t\tif (!e.target || !(e.target instanceof Element)) {\n\t\t\treturn;\n\t\t}\n\t\tconst initialPointerPosition = this._sliderPointerPosition(e);\n\t\tconst initialPointerOrthogonalPosition = this._sliderOrthogonalPointerPosition(e);\n\t\tconst initialScrollbarState = this._scrollbarState.clone();\n\t\tthis.slider.toggleClassName('active', true);\n\n\t\tthis._pointerMoveMonitor.startMonitoring(\n\t\t\te.target,\n\t\t\te.pointerId,\n\t\t\te.buttons,\n\t\t\t(pointerMoveData: PointerEvent) => {\n\t\t\t\tconst pointerOrthogonalPosition = this._sliderOrthogonalPointerPosition(pointerMoveData);\n\t\t\t\tconst pointerOrthogonalDelta = Math.abs(pointerOrthogonalPosition - initialPointerOrthogonalPosition);\n\n\t\t\t\tif (platform.isWindows && pointerOrthogonalDelta > POINTER_DRAG_RESET_DISTANCE) {\n\t\t\t\t\t// The pointer has wondered away from the scrollbar => reset dragging\n\t\t\t\t\tthis._setDesiredScrollPositionNow(initialScrollbarState.getScrollPosition());\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst pointerPosition = this._sliderPointerPosition(pointerMoveData);\n\t\t\t\tconst pointerDelta = pointerPosition - initialPointerPosition;\n\t\t\t\tthis._setDesiredScrollPositionNow(initialScrollbarState.getDesiredScrollPositionFromDelta(pointerDelta));\n\t\t\t},\n\t\t\t() => {\n\t\t\t\tthis.slider.toggleClassName('active', false);\n\t\t\t\tthis._host.onDragEnd();\n\t\t\t}\n\t\t);\n\n\t\tthis._host.onDragStart();\n\t}\n\n\tprivate _setDesiredScrollPositionNow(_desiredScrollPosition: number): void {\n\n\t\tconst desiredScrollPosition: INewScrollPosition = {};\n\t\tthis.writeScrollPosition(desiredScrollPosition, _desiredScrollPosition);\n\n\t\tthis._scrollable.setScrollPositionNow(desiredScrollPosition);\n\t}\n\n\tpublic updateScrollbarSize(scrollbarSize: number): void {\n\t\tthis._updateScrollbarSize(scrollbarSize);\n\t\tthis._scrollbarState.setScrollbarSize(scrollbarSize);\n\t\tthis._shouldRender = true;\n\t\tif (!this._lazyRender) {\n\t\t\tthis.render();\n\t\t}\n\t}\n\n\tpublic isNeeded(): boolean {\n\t\treturn this._scrollbarState.isNeeded();\n\t}\n\n\t// ----------------- Overwrite these\n\n\tprotected abstract _renderDomNode(largeSize: number, smallSize: number): void;\n\tprotected abstract _updateSlider(sliderSize: number, sliderPosition: number): void;\n\n\tprotected abstract _pointerDownRelativePosition(offsetX: number, offsetY: number): number;\n\tprotected abstract _sliderPointerPosition(e: ISimplifiedPointerEvent): number;\n\tprotected abstract _sliderOrthogonalPointerPosition(e: ISimplifiedPointerEvent): number;\n\tprotected abstract _updateScrollbarSize(size: number): void;\n\n\tpublic abstract writeScrollPosition(target: INewScrollPosition, scrollPosition: number): void;\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * The minimal size of the slider (such that it can still be clickable) -- it is artificially enlarged.\n */\nconst MINIMUM_SLIDER_SIZE = 20;\n\nexport class ScrollbarState {\n\n\t/**\n\t * For the vertical scrollbar: the width.\n\t * For the horizontal scrollbar: the height.\n\t */\n\tprivate _scrollbarSize: number;\n\n\t/**\n\t * For the vertical scrollbar: the height of the pair horizontal scrollbar.\n\t * For the horizontal scrollbar: the width of the pair vertical scrollbar.\n\t */\n\tprivate _oppositeScrollbarSize: number;\n\n\t/**\n\t * For the vertical scrollbar: the height of the scrollbar's arrows.\n\t * For the horizontal scrollbar: the width of the scrollbar's arrows.\n\t */\n\tprivate readonly _arrowSize: number;\n\n\t// --- variables\n\t/**\n\t * For the vertical scrollbar: the viewport height.\n\t * For the horizontal scrollbar: the viewport width.\n\t */\n\tprivate _visibleSize: number;\n\n\t/**\n\t * For the vertical scrollbar: the scroll height.\n\t * For the horizontal scrollbar: the scroll width.\n\t */\n\tprivate _scrollSize: number;\n\n\t/**\n\t * For the vertical scrollbar: the scroll top.\n\t * For the horizontal scrollbar: the scroll left.\n\t */\n\tprivate _scrollPosition: number;\n\n\t// --- computed variables\n\n\t/**\n\t * `visibleSize` - `oppositeScrollbarSize`\n\t */\n\tprivate _computedAvailableSize: number;\n\t/**\n\t * (`scrollSize` > 0 && `scrollSize` > `visibleSize`)\n\t */\n\tprivate _computedIsNeeded: boolean;\n\n\tprivate _computedSliderSize: number;\n\tprivate _computedSliderRatio: number;\n\tprivate _computedSliderPosition: number;\n\n\tconstructor(arrowSize: number, scrollbarSize: number, oppositeScrollbarSize: number, visibleSize: number, scrollSize: number, scrollPosition: number) {\n\t\tthis._scrollbarSize = Math.round(scrollbarSize);\n\t\tthis._oppositeScrollbarSize = Math.round(oppositeScrollbarSize);\n\t\tthis._arrowSize = Math.round(arrowSize);\n\n\t\tthis._visibleSize = visibleSize;\n\t\tthis._scrollSize = scrollSize;\n\t\tthis._scrollPosition = scrollPosition;\n\n\t\tthis._computedAvailableSize = 0;\n\t\tthis._computedIsNeeded = false;\n\t\tthis._computedSliderSize = 0;\n\t\tthis._computedSliderRatio = 0;\n\t\tthis._computedSliderPosition = 0;\n\n\t\tthis._refreshComputedValues();\n\t}\n\n\tpublic clone(): ScrollbarState {\n\t\treturn new ScrollbarState(this._arrowSize, this._scrollbarSize, this._oppositeScrollbarSize, this._visibleSize, this._scrollSize, this._scrollPosition);\n\t}\n\n\tpublic setVisibleSize(visibleSize: number): boolean {\n\t\tconst iVisibleSize = Math.round(visibleSize);\n\t\tif (this._visibleSize !== iVisibleSize) {\n\t\t\tthis._visibleSize = iVisibleSize;\n\t\t\tthis._refreshComputedValues();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic setScrollSize(scrollSize: number): boolean {\n\t\tconst iScrollSize = Math.round(scrollSize);\n\t\tif (this._scrollSize !== iScrollSize) {\n\t\t\tthis._scrollSize = iScrollSize;\n\t\t\tthis._refreshComputedValues();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic setScrollPosition(scrollPosition: number): boolean {\n\t\tconst iScrollPosition = Math.round(scrollPosition);\n\t\tif (this._scrollPosition !== iScrollPosition) {\n\t\t\tthis._scrollPosition = iScrollPosition;\n\t\t\tthis._refreshComputedValues();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic setScrollbarSize(scrollbarSize: number): void {\n\t\tthis._scrollbarSize = Math.round(scrollbarSize);\n\t}\n\n\tpublic setOppositeScrollbarSize(oppositeScrollbarSize: number): void {\n\t\tthis._oppositeScrollbarSize = Math.round(oppositeScrollbarSize);\n\t}\n\n\tprivate static _computeValues(oppositeScrollbarSize: number, arrowSize: number, visibleSize: number, scrollSize: number, scrollPosition: number) {\n\t\tconst computedAvailableSize = Math.max(0, visibleSize - oppositeScrollbarSize);\n\t\tconst computedRepresentableSize = Math.max(0, computedAvailableSize - 2 * arrowSize);\n\t\tconst computedIsNeeded = (scrollSize > 0 && scrollSize > visibleSize);\n\n\t\tif (!computedIsNeeded) {\n\t\t\t// There is no need for a slider\n\t\t\treturn {\n\t\t\t\tcomputedAvailableSize: Math.round(computedAvailableSize),\n\t\t\t\tcomputedIsNeeded: computedIsNeeded,\n\t\t\t\tcomputedSliderSize: Math.round(computedRepresentableSize),\n\t\t\t\tcomputedSliderRatio: 0,\n\t\t\t\tcomputedSliderPosition: 0,\n\t\t\t};\n\t\t}\n\n\t\t// We must artificially increase the size of the slider if needed, since the slider would be too small to grab with the mouse otherwise\n\t\tconst computedSliderSize = Math.round(Math.max(MINIMUM_SLIDER_SIZE, Math.floor(visibleSize * computedRepresentableSize / scrollSize)));\n\n\t\t// The slider can move from 0 to `computedRepresentableSize` - `computedSliderSize`\n\t\t// in the same way `scrollPosition` can move from 0 to `scrollSize` - `visibleSize`.\n\t\tconst computedSliderRatio = (computedRepresentableSize - computedSliderSize) / (scrollSize - visibleSize);\n\t\tconst computedSliderPosition = (scrollPosition * computedSliderRatio);\n\n\t\treturn {\n\t\t\tcomputedAvailableSize: Math.round(computedAvailableSize),\n\t\t\tcomputedIsNeeded: computedIsNeeded,\n\t\t\tcomputedSliderSize: Math.round(computedSliderSize),\n\t\t\tcomputedSliderRatio: computedSliderRatio,\n\t\t\tcomputedSliderPosition: Math.round(computedSliderPosition),\n\t\t};\n\t}\n\n\tprivate _refreshComputedValues(): void {\n\t\tconst r = ScrollbarState._computeValues(this._oppositeScrollbarSize, this._arrowSize, this._visibleSize, this._scrollSize, this._scrollPosition);\n\t\tthis._computedAvailableSize = r.computedAvailableSize;\n\t\tthis._computedIsNeeded = r.computedIsNeeded;\n\t\tthis._computedSliderSize = r.computedSliderSize;\n\t\tthis._computedSliderRatio = r.computedSliderRatio;\n\t\tthis._computedSliderPosition = r.computedSliderPosition;\n\t}\n\n\tpublic getArrowSize(): number {\n\t\treturn this._arrowSize;\n\t}\n\n\tpublic getScrollPosition(): number {\n\t\treturn this._scrollPosition;\n\t}\n\n\tpublic getRectangleLargeSize(): number {\n\t\treturn this._computedAvailableSize;\n\t}\n\n\tpublic getRectangleSmallSize(): number {\n\t\treturn this._scrollbarSize;\n\t}\n\n\tpublic isNeeded(): boolean {\n\t\treturn this._computedIsNeeded;\n\t}\n\n\tpublic getSliderSize(): number {\n\t\treturn this._computedSliderSize;\n\t}\n\n\tpublic getSliderPosition(): number {\n\t\treturn this._computedSliderPosition;\n\t}\n\n\t/**\n\t * Compute a desired `scrollPosition` such that `offset` ends up in the center of the slider.\n\t * `offset` is based on the same coordinate system as the `sliderPosition`.\n\t */\n\tpublic getDesiredScrollPositionFromOffset(offset: number): number {\n\t\tif (!this._computedIsNeeded) {\n\t\t\t// no need for a slider\n\t\t\treturn 0;\n\t\t}\n\n\t\tconst desiredSliderPosition = offset - this._arrowSize - this._computedSliderSize / 2;\n\t\treturn Math.round(desiredSliderPosition / this._computedSliderRatio);\n\t}\n\n\t/**\n\t * Compute a desired `scrollPosition` from if offset is before or after the slider position.\n\t * If offset is before slider, treat as a page up (or left).  If after, page down (or right).\n\t * `offset` and `_computedSliderPosition` are based on the same coordinate system.\n\t * `_visibleSize` corresponds to a \"page\" of lines in the returned coordinate system.\n\t */\n\tpublic getDesiredScrollPositionFromOffsetPaged(offset: number): number {\n\t\tif (!this._computedIsNeeded) {\n\t\t\t// no need for a slider\n\t\t\treturn 0;\n\t\t}\n\n\t\tconst correctedOffset = offset - this._arrowSize;  // compensate if has arrows\n\t\tlet desiredScrollPosition = this._scrollPosition;\n\t\tif (correctedOffset < this._computedSliderPosition) {\n\t\t\tdesiredScrollPosition -= this._visibleSize;  // page up/left\n\t\t} else {\n\t\t\tdesiredScrollPosition += this._visibleSize;  // page down/right\n\t\t}\n\t\treturn desiredScrollPosition;\n\t}\n\n\t/**\n\t * Compute a desired `scrollPosition` such that the slider moves by `delta`.\n\t */\n\tpublic getDesiredScrollPositionFromDelta(delta: number): number {\n\t\tif (!this._computedIsNeeded) {\n\t\t\t// no need for a slider\n\t\t\treturn 0;\n\t\t}\n\n\t\tconst desiredSliderPosition = this._computedSliderPosition + delta;\n\t\treturn Math.round(desiredSliderPosition / this._computedSliderRatio);\n\t}\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { AbstractScrollbar, ISimplifiedPointerEvent, ScrollbarHost } from 'vs/base/browser/ui/scrollbar/abstractScrollbar';\nimport { ScrollableElementResolvedOptions } from 'vs/base/browser/ui/scrollbar/scrollableElementOptions';\nimport { ScrollbarState } from 'vs/base/browser/ui/scrollbar/scrollbarState';\nimport { INewScrollPosition, Scrollable, ScrollbarVisibility, ScrollEvent } from 'vs/base/common/scrollable';\n\n\n\n\nexport class HorizontalScrollbar extends AbstractScrollbar {\n\n\tconstructor(scrollable: Scrollable, options: ScrollableElementResolvedOptions, host: ScrollbarHost) {\n\t\tconst scrollDimensions = scrollable.getScrollDimensions();\n\t\tconst scrollPosition = scrollable.getCurrentScrollPosition();\n\t\tsuper({\n\t\t\tlazyRender: options.lazyRender,\n\t\t\thost: host,\n\t\t\tscrollbarState: new ScrollbarState(\n\t\t\t\t(options.horizontalHasArrows ? options.arrowSize : 0),\n\t\t\t\t(options.horizontal === ScrollbarVisibility.Hidden ? 0 : options.horizontalScrollbarSize),\n\t\t\t\t(options.vertical === ScrollbarVisibility.Hidden ? 0 : options.verticalScrollbarSize),\n\t\t\t\tscrollDimensions.width,\n\t\t\t\tscrollDimensions.scrollWidth,\n\t\t\t\tscrollPosition.scrollLeft\n\t\t\t),\n\t\t\tvisibility: options.horizontal,\n\t\t\textraScrollbarClassName: 'horizontal',\n\t\t\tscrollable: scrollable,\n\t\t\tscrollByPage: options.scrollByPage\n\t\t});\n\n\t\tif (options.horizontalHasArrows) {\n      throw new Error('horizontalHasArrows is not supported in xterm.js');\n\t\t\t// const arrowDelta = (options.arrowSize - ARROW_IMG_SIZE) / 2;\n\t\t\t// const scrollbarDelta = (options.horizontalScrollbarSize - ARROW_IMG_SIZE) / 2;\n\n\t\t\t// this._createArrow({\n\t\t\t// \tclassName: 'scra',\n\t\t\t// \ticon: Codicon.scrollbarButtonLeft,\n\t\t\t// \ttop: scrollbarDelta,\n\t\t\t// \tleft: arrowDelta,\n\t\t\t// \tbottom: undefined,\n\t\t\t// \tright: undefined,\n\t\t\t// \tbgWidth: options.arrowSize,\n\t\t\t// \tbgHeight: options.horizontalScrollbarSize,\n\t\t\t// \tonActivate: () => this._host.onMouseWheel(new StandardWheelEvent(null, 1, 0)),\n\t\t\t// });\n\n\t\t\t// this._createArrow({\n\t\t\t// \tclassName: 'scra',\n\t\t\t// \ticon: Codicon.scrollbarButtonRight,\n\t\t\t// \ttop: scrollbarDelta,\n\t\t\t// \tleft: undefined,\n\t\t\t// \tbottom: undefined,\n\t\t\t// \tright: arrowDelta,\n\t\t\t// \tbgWidth: options.arrowSize,\n\t\t\t// \tbgHeight: options.horizontalScrollbarSize,\n\t\t\t// \tonActivate: () => this._host.onMouseWheel(new StandardWheelEvent(null, -1, 0)),\n\t\t\t// });\n\t\t}\n\n\t\tthis._createSlider(Math.floor((options.horizontalScrollbarSize - options.horizontalSliderSize) / 2), 0, undefined, options.horizontalSliderSize);\n\t}\n\n\tprotected _updateSlider(sliderSize: number, sliderPosition: number): void {\n\t\tthis.slider.setWidth(sliderSize);\n\t\tthis.slider.setLeft(sliderPosition);\n\t}\n\n\tprotected _renderDomNode(largeSize: number, smallSize: number): void {\n\t\tthis.domNode.setWidth(largeSize);\n\t\tthis.domNode.setHeight(smallSize);\n\t\tthis.domNode.setLeft(0);\n\t\tthis.domNode.setBottom(0);\n\t}\n\n\tpublic onDidScroll(e: ScrollEvent): boolean {\n\t\tthis._shouldRender = this._onElementScrollSize(e.scrollWidth) || this._shouldRender;\n\t\tthis._shouldRender = this._onElementScrollPosition(e.scrollLeft) || this._shouldRender;\n\t\tthis._shouldRender = this._onElementSize(e.width) || this._shouldRender;\n\t\treturn this._shouldRender;\n\t}\n\n\tprotected _pointerDownRelativePosition(offsetX: number, offsetY: number): number {\n\t\treturn offsetX;\n\t}\n\n\tprotected _sliderPointerPosition(e: ISimplifiedPointerEvent): number {\n\t\treturn e.pageX;\n\t}\n\n\tprotected _sliderOrthogonalPointerPosition(e: ISimplifiedPointerEvent): number {\n\t\treturn e.pageY;\n\t}\n\n\tprotected _updateScrollbarSize(size: number): void {\n\t\tthis.slider.setHeight(size);\n\t}\n\n\tpublic writeScrollPosition(target: INewScrollPosition, scrollPosition: number): void {\n\t\ttarget.scrollLeft = scrollPosition;\n\t}\n\n\tpublic updateOptions(options: ScrollableElementResolvedOptions): void {\n\t\tthis.updateScrollbarSize(options.horizontal === ScrollbarVisibility.Hidden ? 0 : options.horizontalScrollbarSize);\n\t\tthis._scrollbarState.setOppositeScrollbarSize(options.vertical === ScrollbarVisibility.Hidden ? 0 : options.verticalScrollbarSize);\n\t\tthis._visibilityController.setVisibility(options.horizontal);\n\t\tthis._scrollByPage = options.scrollByPage;\n\t}\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { AbstractScrollbar, ISimplifiedPointerEvent, ScrollbarHost } from 'vs/base/browser/ui/scrollbar/abstractScrollbar';\nimport { ScrollableElementResolvedOptions } from 'vs/base/browser/ui/scrollbar/scrollableElementOptions';\nimport { ScrollbarState } from 'vs/base/browser/ui/scrollbar/scrollbarState';\nimport { INewScrollPosition, Scrollable, ScrollbarVisibility, ScrollEvent } from 'vs/base/common/scrollable';\n\n\n\nexport class VerticalScrollbar extends AbstractScrollbar {\n\n\tconstructor(scrollable: Scrollable, options: ScrollableElementResolvedOptions, host: ScrollbarHost) {\n\t\tconst scrollDimensions = scrollable.getScrollDimensions();\n\t\tconst scrollPosition = scrollable.getCurrentScrollPosition();\n\t\tsuper({\n\t\t\tlazyRender: options.lazyRender,\n\t\t\thost: host,\n\t\t\tscrollbarState: new ScrollbarState(\n\t\t\t\t(options.verticalHasArrows ? options.arrowSize : 0),\n\t\t\t\t(options.vertical === ScrollbarVisibility.Hidden ? 0 : options.verticalScrollbarSize),\n\t\t\t\t// give priority to vertical scroll bar over horizontal and let it scroll all the way to the bottom\n\t\t\t\t0,\n\t\t\t\tscrollDimensions.height,\n\t\t\t\tscrollDimensions.scrollHeight,\n\t\t\t\tscrollPosition.scrollTop\n\t\t\t),\n\t\t\tvisibility: options.vertical,\n\t\t\textraScrollbarClassName: 'vertical',\n\t\t\tscrollable: scrollable,\n\t\t\tscrollByPage: options.scrollByPage\n\t\t});\n\n\t\tif (options.verticalHasArrows) {\n      throw new Error('horizontalHasArrows is not supported in xterm.js');\n\t\t\t// const arrowDelta = (options.arrowSize - ARROW_IMG_SIZE) / 2;\n\t\t\t// const scrollbarDelta = (options.verticalScrollbarSize - ARROW_IMG_SIZE) / 2;\n\n\t\t\t// this._createArrow({\n\t\t\t// \tclassName: 'scra',\n\t\t\t// \ticon: Codicon.scrollbarButtonUp,\n\t\t\t// \ttop: arrowDelta,\n\t\t\t// \tleft: scrollbarDelta,\n\t\t\t// \tbottom: undefined,\n\t\t\t// \tright: undefined,\n\t\t\t// \tbgWidth: options.verticalScrollbarSize,\n\t\t\t// \tbgHeight: options.arrowSize,\n\t\t\t// \tonActivate: () => this._host.onMouseWheel(new StandardWheelEvent(null, 0, 1)),\n\t\t\t// });\n\n\t\t\t// this._createArrow({\n\t\t\t// \tclassName: 'scra',\n\t\t\t// \ticon: Codicon.scrollbarButtonDown,\n\t\t\t// \ttop: undefined,\n\t\t\t// \tleft: scrollbarDelta,\n\t\t\t// \tbottom: arrowDelta,\n\t\t\t// \tright: undefined,\n\t\t\t// \tbgWidth: options.verticalScrollbarSize,\n\t\t\t// \tbgHeight: options.arrowSize,\n\t\t\t// \tonActivate: () => this._host.onMouseWheel(new StandardWheelEvent(null, 0, -1)),\n\t\t\t// });\n\t\t}\n\n\t\tthis._createSlider(0, Math.floor((options.verticalScrollbarSize - options.verticalSliderSize) / 2), options.verticalSliderSize, undefined);\n\t}\n\n\tprotected _updateSlider(sliderSize: number, sliderPosition: number): void {\n\t\tthis.slider.setHeight(sliderSize);\n\t\tthis.slider.setTop(sliderPosition);\n\t}\n\n\tprotected _renderDomNode(largeSize: number, smallSize: number): void {\n\t\tthis.domNode.setWidth(smallSize);\n\t\tthis.domNode.setHeight(largeSize);\n\t\tthis.domNode.setRight(0);\n\t\tthis.domNode.setTop(0);\n\t}\n\n\tpublic onDidScroll(e: ScrollEvent): boolean {\n\t\tthis._shouldRender = this._onElementScrollSize(e.scrollHeight) || this._shouldRender;\n\t\tthis._shouldRender = this._onElementScrollPosition(e.scrollTop) || this._shouldRender;\n\t\tthis._shouldRender = this._onElementSize(e.height) || this._shouldRender;\n\t\treturn this._shouldRender;\n\t}\n\n\tprotected _pointerDownRelativePosition(offsetX: number, offsetY: number): number {\n\t\treturn offsetY;\n\t}\n\n\tprotected _sliderPointerPosition(e: ISimplifiedPointerEvent): number {\n\t\treturn e.pageY;\n\t}\n\n\tprotected _sliderOrthogonalPointerPosition(e: ISimplifiedPointerEvent): number {\n\t\treturn e.pageX;\n\t}\n\n\tprotected _updateScrollbarSize(size: number): void {\n\t\tthis.slider.setWidth(size);\n\t}\n\n\tpublic writeScrollPosition(target: INewScrollPosition, scrollPosition: number): void {\n\t\ttarget.scrollTop = scrollPosition;\n\t}\n\n\tpublic updateOptions(options: ScrollableElementResolvedOptions): void {\n\t\tthis.updateScrollbarSize(options.vertical === ScrollbarVisibility.Hidden ? 0 : options.verticalScrollbarSize);\n\t\t// give priority to vertical scroll bar over horizontal and let it scroll all the way to the bottom\n\t\tthis._scrollbarState.setOppositeScrollbarSize(0);\n\t\tthis._visibilityController.setVisibility(options.vertical);\n\t\tthis._scrollByPage = options.scrollByPage;\n\t}\n\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { getZoomFactor, isChrome } from 'vs/base/browser/browser';\nimport * as dom from 'vs/base/browser/dom';\nimport { FastDomNode, createFastDomNode } from 'vs/base/browser/fastDomNode';\nimport { IMouseEvent, IMouseWheelEvent, StandardWheelEvent } from 'vs/base/browser/mouseEvent';\nimport { ScrollbarHost } from 'vs/base/browser/ui/scrollbar/abstractScrollbar';\nimport { HorizontalScrollbar } from 'vs/base/browser/ui/scrollbar/horizontalScrollbar';\nimport { ScrollableElementChangeOptions, ScrollableElementCreationOptions, ScrollableElementResolvedOptions } from 'vs/base/browser/ui/scrollbar/scrollableElementOptions';\nimport { VerticalScrollbar } from 'vs/base/browser/ui/scrollbar/verticalScrollbar';\nimport { Widget } from 'vs/base/browser/ui/widget';\nimport { TimeoutTimer } from 'vs/base/common/async';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { IDisposable, dispose } from 'vs/base/common/lifecycle';\nimport * as platform from 'vs/base/common/platform';\nimport { INewScrollDimensions, INewScrollPosition, IScrollDimensions, IScrollPosition, ScrollEvent, Scrollable, ScrollbarVisibility } from 'vs/base/common/scrollable';\n// import 'vs/css!./media/scrollbars';\n\nconst HIDE_TIMEOUT = 500;\nconst SCROLL_WHEEL_SENSITIVITY = 50;\nconst SCROLL_WHEEL_SMOOTH_SCROLL_ENABLED = true;\n\nexport interface IOverviewRulerLayoutInfo {\n\tparent: HTMLElement;\n\tinsertBefore: HTMLElement;\n}\n\nclass MouseWheelClassifierItem {\n\tpublic timestamp: number;\n\tpublic deltaX: number;\n\tpublic deltaY: number;\n\tpublic score: number;\n\n\tconstructor(timestamp: number, deltaX: number, deltaY: number) {\n\t\tthis.timestamp = timestamp;\n\t\tthis.deltaX = deltaX;\n\t\tthis.deltaY = deltaY;\n\t\tthis.score = 0;\n\t}\n}\n\nexport class MouseWheelClassifier {\n\n\tpublic static readonly INSTANCE = new MouseWheelClassifier();\n\n\tprivate readonly _capacity: number;\n\tprivate _memory: MouseWheelClassifierItem[];\n\tprivate _front: number;\n\tprivate _rear: number;\n\n\tconstructor() {\n\t\tthis._capacity = 5;\n\t\tthis._memory = [];\n\t\tthis._front = -1;\n\t\tthis._rear = -1;\n\t}\n\n\tpublic isPhysicalMouseWheel(): boolean {\n\t\tif (this._front === -1 && this._rear === -1) {\n\t\t\t// no elements\n\t\t\treturn false;\n\t\t}\n\n\t\t// 0.5 * last + 0.25 * 2nd last + 0.125 * 3rd last + ...\n\t\tlet remainingInfluence = 1;\n\t\tlet score = 0;\n\t\tlet iteration = 1;\n\n\t\tlet index = this._rear;\n\t\tdo {\n\t\t\tconst influence = (index === this._front ? remainingInfluence : Math.pow(2, -iteration));\n\t\t\tremainingInfluence -= influence;\n\t\t\tscore += this._memory[index].score * influence;\n\n\t\t\tif (index === this._front) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tindex = (this._capacity + index - 1) % this._capacity;\n\t\t\titeration++;\n\t\t} while (true);\n\n\t\treturn (score <= 0.5);\n\t}\n\n\tpublic acceptStandardWheelEvent(e: StandardWheelEvent): void {\n\t\tif (isChrome) {\n\t\t\tconst targetWindow = dom.getWindow(e.browserEvent);\n\t\t\tconst pageZoomFactor = getZoomFactor(targetWindow);\n\t\t\t// On Chrome, the incoming delta events are multiplied with the OS zoom factor.\n\t\t\t// The OS zoom factor can be reverse engineered by using the device pixel ratio and the configured zoom factor into account.\n\t\t\tthis.accept(Date.now(), e.deltaX * pageZoomFactor, e.deltaY * pageZoomFactor);\n\t\t} else {\n\t\t\tthis.accept(Date.now(), e.deltaX, e.deltaY);\n\t\t}\n\t}\n\n\tpublic accept(timestamp: number, deltaX: number, deltaY: number): void {\n\t\tlet previousItem = null;\n\t\tconst item = new MouseWheelClassifierItem(timestamp, deltaX, deltaY);\n\n\t\tif (this._front === -1 && this._rear === -1) {\n\t\t\tthis._memory[0] = item;\n\t\t\tthis._front = 0;\n\t\t\tthis._rear = 0;\n\t\t} else {\n\t\t\tpreviousItem = this._memory[this._rear];\n\n\t\t\tthis._rear = (this._rear + 1) % this._capacity;\n\t\t\tif (this._rear === this._front) {\n\t\t\t\t// Drop oldest\n\t\t\t\tthis._front = (this._front + 1) % this._capacity;\n\t\t\t}\n\t\t\tthis._memory[this._rear] = item;\n\t\t}\n\n\t\titem.score = this._computeScore(item, previousItem);\n\t}\n\n\t/**\n\t * A score between 0 and 1 for `item`.\n\t *  - a score towards 0 indicates that the source appears to be a physical mouse wheel\n\t *  - a score towards 1 indicates that the source appears to be a touchpad or magic mouse, etc.\n\t */\n\tprivate _computeScore(item: MouseWheelClassifierItem, previousItem: MouseWheelClassifierItem | null): number {\n\n\t\tif (Math.abs(item.deltaX) > 0 && Math.abs(item.deltaY) > 0) {\n\t\t\t// both axes exercis