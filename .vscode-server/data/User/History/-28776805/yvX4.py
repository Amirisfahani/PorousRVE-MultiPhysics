from mpi4py import MPI
from petsc4py import PETSc
import numpy as np

from dolfinx import mesh, fem, io
import ufl
import meshio
import os

# ---------------------------------------------------------
# 0. User inputs: path to your generated XDMF mesh
# ---------------------------------------------------------
# Example: mesh file generated by your script in rve_output/
mesh_file = "rve_output/rve_quad_mesh_Lx1.00_phi30.xdmf"  # <-- change to your file

if not os.path.exists(mesh_file):
    raise FileNotFoundError(f"Cannot find mesh file: {mesh_file}")

# ---------------------------------------------------------
# 1. Read mesh in dolfinx
# ---------------------------------------------------------
with io.XDMFFile(MPI.COMM_WORLD, mesh_file, "r") as xdmf:
    # Most meshio-generated XDMF files use the default grid name "Grid"
    msh = xdmf.read_mesh(name="Grid")
    msh.name = "RVE_mesh"


# Shortcut to dimension etc.
tdim = msh.topology.dim

print(f"[INFO] Mesh: {msh.geometry.x.shape[0]} nodes, "
      f"{msh.topology.index_map(tdim).size_local} cells, dim={tdim}")

# ---------------------------------------------------------
# 2. Read cell-wise damage from the same XDMF via meshio
# ---------------------------------------------------------
# We use meshio just to read the cell_data array "damage" we wrote earlier
mio = meshio.read(mesh_file)
# For a quad mesh, cell type is usually "quad"
# When we wrote the mesh, we used: cell_data={"damage": [cell_damage]}
damage_cells = None
for ctype, cdata in mio.cell_data_dict.items():
    # cdata is a dict: name -> array, we look for "damage"
    if "damage" in cdata:
        damage_cells = cdata["damage"]
        print(f"[INFO] Found damage for cell type '{ctype}' with shape {damage_cells.shape}")
        break

if damage_cells is None:
    raise RuntimeError("Could not find 'damage' cell_data in the XDMF file.")

# Flatten in case it's 2D
damage_cells = np.asarray(damage_cells).ravel()

num_cells = msh.topology.index_map(tdim).size_local
if damage_cells.size != num_cells:
    print(f"[WARNING] damage_cells.size = {damage_cells.size}, num_cells = {num_cells}")
    print("          Assuming same ordering (our generator + meshio + dolfinx are consistent).")

print(f"[INFO] Damage stats: min={damage_cells.min():.3f}, "
      f"max={damage_cells.max():.3f}, mean={damage_cells.mean():.3f}")

# ---------------------------------------------------------
# 3. Create a DG0 function for damage, and then E_eff, lambda, mu
# ---------------------------------------------------------
V0 = fem.FunctionSpace(msh, ("DG", 0))   # one value per cell

damage_fn = fem.Function(V0)
# Assign array directly (assumes cell ordering agrees)
damage_fn.x.array[:] = damage_cells

# Material parameters
E0 = 1.0e9   # Young's modulus of solid (Pa) - arbitrary here
nu = 0.3     # Poisson's ratio
p  = 2.0     # exponent for damage -> E mapping
Emin_ratio = 1e-3   # minimum relative stiffness for "void-ish" regions

E_eff_cells = (1.0 - damage_cells) ** p * E0
E_eff_cells = np.maximum(E_eff_cells, Emin_ratio * E0)

# Convert to Lamé parameters lambda, mu per cell
lambda_cells = (E_eff_cells * nu) / ((1 + nu) * (1 - 2 * nu))
mu_cells     = E_eff_cells / (2 * (1 + nu))

lambda_fn = fem.Function(V0)
mu_fn     = fem.Function(V0)
lambda_fn.x.array[:] = lambda_cells
mu_fn.x.array[:]     = mu_cells

print(f"[INFO] Effective E range: {E_eff_cells.min():.3e} .. {E_eff_cells.max():.3e}")

# ---------------------------------------------------------
# 4. Define function spaces for displacement u and concentration c
# ---------------------------------------------------------
# Displacement space: vector-valued, continuous, degree 1
Vu = fem.FunctionSpace(msh, ("CG", 1, (tdim,)))  # 2D: tdim=2 -> u = (u_x, u_y)

# Concentration space (not used yet, but we define it for later)
Vc = fem.FunctionSpace(msh, ("CG", 1))

# Trial / test functions for mechanics
u = fem.Function(Vu)             # unknown displacement
v = ufl.TestFunction(Vu)

# ---------------------------------------------------------
# 5. Small-strain tensor and stress with spatially varying lambda, mu
# ---------------------------------------------------------
def eps(u_):
    return ufl.sym(ufl.grad(u_))   # small-strain tensor

def sigma(u_):
    # Turn lambda_fn, mu_fn into UFL expressions
    lam = lambda_fn
    mu  = mu_fn
    return 2.0 * mu * eps(u_) + lam * ufl.tr(eps(u_)) * ufl.Identity(tdim)

# ---------------------------------------------------------
# 6. Boundary conditions
#    Example:
#      - Fix left edge x=0 (u = 0)
#      - Apply prescribed displacement in x at right edge x = Lx (u_x = u0)
# ---------------------------------------------------------
# Get bounding box extents from mesh coordinates
coords = msh.geometry.x
x_min = np.min(coords[:, 0])
x_max = np.max(coords[:, 0])

u0 = 0.001  # applied displacement in x-direction on right boundary

# Define functions for boundary detection
def left_boundary(x):
    return np.isclose(x[0], x_min)

def right_boundary(x):
    return np.isclose(x[0], x_max)

# Locate facets on left and right
facets_left = mesh.locate_entities_boundary(msh, tdim-1, left_boundary)
facets_right = mesh.locate_entities_boundary(msh, tdim-1, right_boundary)

# Map facets to DOFs
dofs_left = fem.locate_dofs_topological(Vu, tdim-1, facets_left)
dofs_right = fem.locate_dofs_topological(Vu, tdim-1, facets_right)

# Left BC: u = (0, 0)
u_left = np.array((0.0, 0.0), dtype=PETSc.ScalarType)
bc_left = fem.dirichletbc(u_left, dofs_left, Vu)

# Right BC: u = (u0, 0)
u_right = fem.Function(Vu)
with u_right.vector.localForm() as loc:
    loc.set(0.0)
# Set constant value (u0, 0)
u_right.x.array[0::tdim] = u0   # x-component
u_right.x.array[1::tdim] = 0.0  # y-component
bc_right = fem.dirichletbc(u_right, dofs_right)

bcs = [bc_left, bc_right]

# ---------------------------------------------------------
# 7. Variational formulation: ∫ σ(u) : ε(v) dx = 0
#    (no body forces for now)
# ---------------------------------------------------------
a = ufl.inner(sigma(u), eps(v)) * ufl.dx
L = ufl.inner(ufl.as_vector((0.0, 0.0)), v) * ufl.dx   # RHS = 0

# Set up linear problem (small-strain linear elasticity)
problem = fem.petsc.LinearProblem(a, L, bcs=bcs, u=u,
                                  petsc_options={"ksp_type": "preonly",
                                                 "pc_type": "lu"})

uh = problem.solve()
print("[INFO] Linear elasticity problem solved.")

# ---------------------------------------------------------
# 8. Save displacement and damage for visualization
# ---------------------------------------------------------
out_vtk = "rve_output/solution_elasticity_damage.vtu"
# Convert to meshio for writing VTU:
#  - we need cell connectivity and point coordinates from dolfinx mesh
#  - then attach uh and damage as data

# Gather cell connectivity and points (on rank 0 only; assume serial run)
if MPI.COMM_WORLD.rank == 0:
    # Extract topology
    ct = msh.topology.connectivity(tdim, 0)
    cells = ct.array.reshape(-1, ct.num_nodes)
    points_out = msh.geometry.x

    # Displacement as array
    uh_arr = uh.x.array.reshape(-1, tdim)
    damage_arr = damage_cells  # one per cell

    # Build a meshio mesh (quad or general polygon, but ParaView is fine)
    # We'll store cells as "quad" if num_nodes == 4, else "polygon"
    cell_type = "quad" if cells.shape[1] == 4 else "polygon"

    m_out = meshio.Mesh(
        points=points_out,
        cells=[(cell_type, cells)],
        point_data={"u": uh_arr},
        cell_data={"damage": [damage_arr]},
    )
    meshio.write(out_vtk, m_out)
    print(f"[INFO] Wrote solution VTU: {out_vtk}")

print("[DONE] RVE elasticity with material-based porosity complete.")
